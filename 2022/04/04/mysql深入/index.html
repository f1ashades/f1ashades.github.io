<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一些Mysql的深入0.0">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql深入">
<meta property="og:url" content="http://example.com/2022/04/04/mysql%E6%B7%B1%E5%85%A5/index.html">
<meta property="og:site_name" content="f1ashades&#39; blogs">
<meta property="og:description" content="一些Mysql的深入0.0">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/6zLJYsUrRBe2ZNT.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/YBGfNA1QK29bsaF.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/FnZ4XWVfNEJ5k9h.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/UFR5N6rMGEKVnIs.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/9cftzj5epWYIF6V.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/1kgTeC5UNWFiEIf.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/Q21ABD6jfdZPi8p.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/aKtQdNDGo6iLmEC.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/z2J1p8j9EChBwcN.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/ocWZvNhuSs1VBgt.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/KwRVxtr2qhoFd7g.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/WGJnCjK37u2v68o.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/brk8NdOZXlhq23t.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/zqmAFYeTyiXBrNl.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/AnONs5KXudJpZgv.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/AgFNWb4lrUYofGe.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/VRtgf75F6iyTZXM.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/oej2vmnNVUDzhWZ.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/IyqERfjPizUQOSs.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/6QNDVjHxdI5Fatu.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/ez7OVMCQshElxrT.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/LHd9CkzsG2rFv5p.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/cCjQklvUs84A76o.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/7MSNr4i3qFDPYb2.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/30/75qcEWAOeDoXujJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/TgKzdrDO5u6Mxf2.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/03/ivgQnFRIlw8AuPS.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/03/8NQSBUeDgXZ5Apy.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/03/RYzTaZNEGrg5xuk.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/PxhtBiqX7AenEkU.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/06/VwHtZGLrs3XCBof.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/jKNSIomCEZrgUYO.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/PF2Ilnyv3WgJ158.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/w3E84SoP5DQrZfz.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/Vt5c6AhszexKqJ4.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/qWYeCaVbirOBp5U.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/6NOkcM4nKSljq2P.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/O56V1xY4XIUQKdC.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/04/4TOz2eSnJlQgwMG.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/PRMQ3GcIDke2JT8.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/FkjyDKNR7I3vOJp.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/OWcUtonTPCm1AIz.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/sdyktMcIi34x7Yf.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/om9e35AVERQkFtp.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/nvBiLafzYgQoTdE.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/sGodEcNFX4xguPp.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/6iQB9kvRUHuPTaF.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/OfSv69jIyRxr2ZU.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/1YSkTZX36dUajbK.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/6sTWjenSC1rkZJK.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/Q7jpROgLsWVGa8F.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/oVfsBG8Y5zRk9g2.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/Kqopg7ycnHTEiJA.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/5tnMHfhJiLPN8zA.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/05/VZqa8Y4G7PQkyn1.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/06/PKirfo5e8sMUayt.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/06/U28D1M73bECdFNB.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/06/FPUskB4agijIlmc.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/06/NIjZkwAqCT8ag17.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/06/q3dHPWGOjCmbiuV.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/1TqV4HuaYOr72UZ.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/tJyPSdwBC9jTQKp.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/nUtDKR5ovh9GS13.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/kOgybzdqNjQ8JEI.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/n7wA5Xzhkp6cfMI.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/xofWdeGj46PXapn.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/Auf65IJFRTaBkV2.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/WNq4xmK3uFQkyEJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/1jurzLWNCq38GgR.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/elfca7NMZozb5Bs.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/K8Pkat2cEFLAWrj.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/UORIs8H4YrPA6V5.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/STAePBOwDfnj7cJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/3Y2QDaPhfWiwut7.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/sZq8wyVMIe5RbNj.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/Op8GUxfHWs54hT3.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/mtKREcBoqsPlnM8.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/SEk1IJ5BmihubyA.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/1Ak5SrFvWPBQgzC.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/M1x9wWs8PiyJDad.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/nVMW81tYsRckBX4.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/M1x9wWs8PiyJDad.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/73tWz4SUXwqK8f6.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/pebuDKW48JadAIx.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/13nhUgyF8cwzxsB.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/K2E1FBPGgZdwhQ3.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/O1EnUrXhtJMRKDP.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/dPaH7NSteDTi8hI.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/85TpM4tfOrSyZAE.png">
<meta property="og:image" content="d:/Typora/TyporaPictureBed/image-20220509170102112.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/EeXWmpy6u9o4qMV.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/6bDL1dOAgfG9ev4.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/04/ecoGstjKThgfPar.png">
<meta property="article:published_time" content="2022-04-04T07:29:48.000Z">
<meta property="article:modified_time" content="2022-06-23T10:31:00.973Z">
<meta property="article:author" content="f1ashades">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/06/04/6zLJYsUrRBe2ZNT.png">

<link rel="canonical" href="http://example.com/2022/04/04/mysql%E6%B7%B1%E5%85%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>mysql深入 | f1ashades' blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">f1ashades' blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/mysql%E6%B7%B1%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mine.jpg">
      <meta itemprop="name" content="f1ashades">
      <meta itemprop="description" content="once again I am a child">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="f1ashades' blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql深入
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-04 15:29:48" itemprop="dateCreated datePublished" datetime="2022-04-04T15:29:48+08:00">2022-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 18:31:00" itemprop="dateModified" datetime="2022-06-23T18:31:00+08:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>一些Mysql的深入0.0</p>
<span id="more"></span>

<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>基本操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 查询张三账户余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">-- 2. 将张三账户余额-1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">-- 此语句出错后张三钱减少但是李四钱没有增加</span><br><span class="line">模拟sql语句错误</span><br><span class="line">-- 3. 将李四账户余额+1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查看事务提交方式</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="line">SET @@AUTOCOMMIT = 0;</span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 设置手动提交后上面代码改为：</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>操作方式二：</p>
<p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p>
<p>操作实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>



<h2 id="1-四大特性ACID"><a href="#1-四大特性ACID" class="headerlink" title="1.四大特性ACID"></a>1.四大特性ACID</h2><ul>
<li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li>
<li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
<li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li>
</ul>
<h2 id="2-并发事务"><a href="#2-并发事务" class="headerlink" title="2.并发事务"></a>2.并发事务</h2><table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td>
</tr>
</tbody></table>
<p>①脏读（Dirty read）：</p>
<p>​	数据库中A&#x3D;200，事务1中修改了A&#x3D;100，但是这时候事务1还没有commit，而此时事务2要读取A的值，事务2读取A&#x3D;100，这是事务A修改了但是还没有commit的数据，这种数据就称为’脏数据’，此时就发生了<code>脏读</code>。</p>
<p>②不可重复读（Unrepeatable read）</p>
<p>​	数据库中id&#x3D;1的数据有一个值为A&#x3D;200，事务A第一次select<code>id=1</code>的数据查询出A&#x3D;200，此时事务2修改update<code>id=1</code>的数据使A&#x3D;100并且commit了，此时数据库中的<code>id=1</code>的数据A&#x3D;100，然后事务1第二次读取select<code>id=1</code>的数据查询出A&#x3D;100和第一次查询出的A&#x3D;200不一致，此时就发生了<code>不可重复读现象</code>。</p>
<p>③幻读（Phantom read）</p>
<p>​	幻读与不可重复读类似，事务1第一步select查询id&#x3D;1的数据，此时数据库为空没有查到，刚好此时事务2向数据库中插入了id&#x3D;1的数据，此时事务1第二步要插入id&#x3D;1的数据的时候就会报错，当事务1再次查询数据库的时候发现id为1的数据还是没有（因为已经解决了不可重复读的问题，两次查询的结果一致），这时候就发生了’幻读’。因为在插入数据的时候会因为事务2插入的数据失败，事务1会发现已经有了插入的数据，但是查询的时候又看见，就像幻觉一样<code>Phantom</code>。</p>
<p>④丢失更新（Lost to modify）</p>
<p>事务1想要修改A&#x3D;20并且读取到了A&#x3D;20数据（此时事务2页读取到了A&#x3D;20），使A&#x3D;A-1，修改的结果为19；事务2读取到A&#x3D;20数据后也要进行修改，使A&#x3D;A-3，得到的结果为17；最终结果为17，看起来就是事务1的结果丢失了。</p>
<p>注：</p>
<ol>
<li>不可重复读和幻读类似，不可重复读是发生在事务A因为事务B的修改导致两次read的数据不一致，幻读是因为事务A因为事务B的插入数据导致自身插入数据失败，但是两次查询（特别是第二次）发现没有数据（解决了不可重复度的基础上），好像出现了幻觉。</li>
</ol>
<blockquote>
<p>这三个问题的详细演示：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a> </p>
<p>丢失更新相关博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sun8112133/article/details/89853755">https://blog.csdn.net/sun8112133/article/details/89853755</a></p>
</blockquote>
<p>并发事务隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ul>
<li>√表示在当前隔离级别下该问题会出现</li>
<li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li>
</ul>
<p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p>
<h1 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h1><h2 id="1-MySQL体系结构"><a href="#1-MySQL体系结构" class="headerlink" title="1. MySQL体系结构"></a>1. MySQL体系结构</h2><p><img src="https://s2.loli.net/2022/06/04/6zLJYsUrRBe2ZNT.png" alt="image-20220604151019471"><br><img src="https://s2.loli.net/2022/06/04/YBGfNA1QK29bsaF.png" alt="image-20220604150959201"></p>
<p>Mysql结构（4层）：</p>
<p>①连接层</p>
<p>​	处理来自各个客户端的连接（验证密码等），授权认证及相关安全信息</p>
<p>②服务层</p>
<p>​	最核心的一层，mysql在这一层中完成各类服务，执行sql、sql分析和优化，过程函数都在这一层实行</p>
<p>③引擎层</p>
<p>​	mysql实现的是可插拔存储引擎，想用哪个插哪个，默认为InnoDB。同时<code>索引(index)</code>也在这一层，所以各个存储引擎实现索引的方式可能不一样。存储引擎是数据库存储数据、建立索引、更新&#x2F;查询等技术的实现方式，存储引擎是基于表的</p>
<p>④存储层</p>
<p>​	主要是将存储的数据存入系统硬盘上，完成与存储引擎的交互</p>
<p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p>
<p>相关操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询建表语句</span><br><span class="line">show create table account;</span><br><span class="line">-- 建表时指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">	...</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line">-- 查看当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure>



<h2 id="2-常见引擎"><a href="#2-常见引擎" class="headerlink" title="2. 常见引擎"></a>2. 常见引擎</h2><h3 id="1）InnoDB"><a href="#1）InnoDB" class="headerlink" title="1）InnoDB"></a>1）InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p>
<p>特点：</p>
<ul>
<li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li>
<li><strong>行级锁</strong>，提高并发访问性能</li>
<li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li>
</ul>
<p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p>
<p>知识点：</p>
<p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p>
<p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p>
<p>InnoDB 逻辑存储结构：</p>
<p><img src="https://s2.loli.net/2022/06/04/FnZ4XWVfNEJ5k9h.png" alt="image-20220604151045297"></p>
<h3 id="2）MyISAM"><a href="#2）MyISAM" class="headerlink" title="2）MyISAM"></a>2）MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p>
<p>特点：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
<li>xxx.MYD: 存储数据</li>
<li>xxx.MYI: 存储索引</li>
</ul>
<h3 id="3）Memory"><a href="#3）Memory" class="headerlink" title="3）Memory"></a>3）Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>特点：</p>
<ul>
<li>存放在内存中，速度快</li>
<li>hash索引（默认）</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
</ul>
<h2 id="3-存储引擎特点比较"><a href="#3-存储引擎特点比较" class="headerlink" title="3. 存储引擎特点比较"></a>3. 存储引擎特点比较</h2><table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（5.6版本之后）</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="4-存储引擎的选择"><a href="#4-存储引擎的选择" class="headerlink" title="4. 存储引擎的选择"></a>4. 存储引擎的选择</h2><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li>
<li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li>
<li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ul>
<p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>
<h1 id="三、-索引"><a href="#三、-索引" class="headerlink" title="三、 索引"></a>三、 索引</h1><h2 id="1-索引结构"><a href="#1-索引结构" class="headerlink" title="1. 索引结构"></a>1. 索引结构</h2><table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree</td>
<td>最常见的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td>Hash</td>
<td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-Tree(空间索引)</td>
<td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-Text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-Tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h3 id="1）二叉搜索树"><a href="#1）二叉搜索树" class="headerlink" title="1）二叉搜索树"></a>1）二叉搜索树</h3><p><img src="https://s2.loli.net/2022/06/04/UFR5N6rMGEKVnIs.png" alt="image-20220604151133266"></p>
<p>二叉树的缺点可以用红黑树来解决：<br><img src="https://s2.loli.net/2022/06/04/9cftzj5epWYIF6V.png" alt="image-20220604151200671"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p>
<h3 id="2）B-Tree"><a href="#2）B-Tree" class="headerlink" title="2）B Tree"></a>2）B Tree</h3><p>B Tree相较于二叉搜索树维护了自平衡（左右高度差距不会过大）并且增加了一个节点的字节点数量，eg：</p>
<p>如下图degree&#x3D;5（子节点个数），一共可存4个key（值），<code>x</code>&lt;20，20&lt;&#x3D;<code>x</code>&lt;30，…，…，89&#x3D;&lt;x</p>
<p>为了解决上述问题，可以使用 B-Tree 结构：</p>
<p>​	B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p>
<p><img src="https://s2.loli.net/2022/06/04/1kgTeC5UNWFiEIf.png" alt="image-20220604151214322"></p>
<blockquote>
<p>B-Tree 的数据插入过程动画参照：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p>
</blockquote>
<h3 id="3）B-Tree"><a href="#3）B-Tree" class="headerlink" title="3）B+Tree"></a>3）B+Tree</h3><p>B+ Tree 相较于B Tree就是将数据全部存储在了叶子节点，如下图左下角x&lt;16，16&lt;&#x3D;x&lt;29，29&lt;&#x3D;x</p>
<p>这样key&#x3D;16的数据就存储在了第二个叶子节点</p>
<p>结构图：</p>
<p><img src="https://s2.loli.net/2022/06/04/Q21ABD6jfdZPi8p.png" alt="image-20220604151223679"></p>
<blockquote>
<p>演示地址：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p>
</blockquote>
<p>与 B Tree 的区别：</p>
<ul>
<li>所有的数据都会出现在叶子节点</li>
<li>叶子节点形成一个单向链表</li>
</ul>
<h3 id="4）InooDB的改进B-Tree"><a href="#4）InooDB的改进B-Tree" class="headerlink" title="4）InooDB的改进B+ Tree"></a>4）InooDB的改进B+ Tree</h3><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p>
<p><img src="https://s2.loli.net/2022/06/04/aKtQdNDGo6iLmEC.png" alt="image-20220604151239993"></p>
<p>​	mysql中的B+树对经典的B+树做了优化，1.在叶子相邻叶子节点间添加了一个向前的指针使其成为了双向链表（首尾也是双向指针），这是便于<code>范围搜索</code>和<code>排序</code></p>
<h3 id="5）Hash索引"><a href="#5）Hash索引" class="headerlink" title="5）Hash索引"></a>5）Hash索引</h3><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>
<p><img src="https://s2.loli.net/2022/06/04/z2J1p8j9EChBwcN.png" alt="image-20220604151249990"></p>
<p>特点：</p>
<ul>
<li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li>
<li>无法利用索引完成排序操作</li>
<li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li>
</ul>
<p>存储引擎支持：</p>
<ul>
<li>Memory</li>
<li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li>
</ul>
<h3 id="6）面试题"><a href="#6）面试题" class="headerlink" title="6）面试题"></a>6）面试题</h3><ol>
<li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li>
</ol>
<ul>
<li>相对于二叉树，层级更少，搜索效率高</li>
<li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li>
<li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li>
<li>mine：<ul>
<li><img src="https://s2.loli.net/2022/04/30/ocWZvNhuSs1VBgt.png" alt="image-20220429152507413"></li>
<li>二叉搜索树在顺序插入的时候会形成一个链表，查询的过程就变成线性的一条一条查询；如果数据量较大，层级变深，搜索效率变慢</li>
<li>B Tree 无论节点还是非叶子节点都会保存数据，而每一个节点都是存储在一页中的，如果非叶子节点要保存value，那么这一页存储的keys就会减少，指针也变少了，要存储更多的数据，只能增加树的高度，导致性能降低了</li>
<li>同时因为改进后的B+树在叶子节点间添加了双向指针，便于范围匹配和排序，而Hash索引不能</li>
</ul>
</li>
</ul>
<h2 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2. 索引分类"></a>2. 索引分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>演示图：</p>
<p><img src="https://s2.loli.net/2022/06/04/KwRVxtr2qhoFd7g.png" alt="image-20220604151410748"><br><img src="https://s2.loli.net/2022/06/04/WGJnCjK37u2v68o.png" alt="image-20220604151429077"></p>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一(UNIQUE)列作为聚集索引</li>
<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li>
</ul>
<p>思考题</p>
<p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure>

<p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p>
<p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p>
<p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p>
<p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p>
<p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p>
<h2 id="3-索引语法"><a href="#3-索引语法" class="headerlink" title="3. 索引语法"></a>3. 索引语法</h2><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p>
<p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p>
<p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="line">create index idx_user_name on tb_user(name);</span><br><span class="line">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user (phone);</span><br><span class="line">-- 为profession, age, status创建联合索引</span><br><span class="line">create index idx_user_pro_age_stat on tb_user(profession, age, status);</span><br><span class="line">-- 为email建立合适的索引来提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">drop index idx_user_email on tb_user;</span><br></pre></td></tr></table></figure>



<h2 id="4-sql性能分析"><a href="#4-sql性能分析" class="headerlink" title="4. sql性能分析"></a>4. sql性能分析</h2><p>①首先查看执行频次来分析当前数据库，是增删改语句执行的多，还是select语句执行的多</p>
<p>②通过慢查询日志可以定位哪台主机通过哪个user执行了哪条<code>sql语句</code>，执行效率较低</p>
<p>③慢查询日志只会记录超过设定时间的sql，如果要查看没有超过时限的sql则需要通过profiles来查询</p>
<p>④explain会查看sql具体的执行信息</p>
<h3 id="1）查看执行频次"><a href="#1）查看执行频次" class="headerlink" title="1）查看执行频次"></a>1）查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>全局：SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> </p>
<p><code>会话：SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code></p>
<p>例：<code>show global status like &#39;Com_______&#39;</code></p>
<h3 id="2）慢查询日志"><a href="#2）慢查询日志" class="headerlink" title="2）慢查询日志"></a>2）慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p>
<p>#开启慢查询日志开关</p>
<p><code>slow_query_log=1</code></p>
<p>#设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志：</p>
<p><code>long_query_time=2</code></p>
<p>更改后重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p>
<p><code>systemctl restart mysqld</code></p>
<p>查看慢查询日志开关状态：</p>
<p><code>show variables like &#39;slow_query_log&#39;;</code></p>
<h3 id="3）profile"><a href="#3）profile" class="headerlink" title="3）profile"></a>3）profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：</p>
<p><code>SELECT @@have_profiling;</code></p>
<p>profiling 默认关闭，可查询其开启情况（0是关闭）</p>
<p><code>select @@profiling;</code></p>
<p>可以通过set语句在session&#x2F;global级别开启 profiling：</p>
<p><code>SET profiling = 1;</code></p>
<p>查看所有语句的耗时：</p>
<p><code>show profiles;</code></p>
<p>查看指定query_id的SQL语句各个阶段的耗时：</p>
<p><code>show profile for query query_id;</code></p>
<p>查看指定query_id的SQL语句CPU的使用情况</p>
<p><code>show profile cpu for query query_id;</code></p>
<h3 id="4）explain"><a href="#4）explain" class="headerlink" title="4）explain"></a>4）explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br>    # 直接在select语句之前加上关键字 explain &#x2F; desc<br>    EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p>
<p>EXPLAIN 各字段含义：</p>
<ul>
<li><p>id*：select </p>
<ul>
<li>查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li>
</ul>
</li>
<li><p>select_type：</p>
<ul>
<li>表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li>
</ul>
</li>
<li><p>type*：</p>
<ul>
<li>表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li>
<li>用主键索引或者唯一索引查询，const</li>
<li>用普通索引，ref</li>
<li>select ‘A’，NULL</li>
</ul>
</li>
<li><p>possible_key*：</p>
<ul>
<li>可能应用在这张表上的索引，一个或多个</li>
</ul>
</li>
<li><p>Key*：</p>
<ul>
<li>实际使用的索引，如果为 NULL，则没有使用索引</li>
</ul>
</li>
<li><p>Key_len*：</p>
<ul>
<li>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li>
</ul>
</li>
<li><p>rows：</p>
<ul>
<li>MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li>
</ul>
</li>
<li><p>filtered：</p>
<ul>
<li>表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li>
</ul>
</li>
</ul>
<h2 id="5-使用规则"><a href="#5-使用规则" class="headerlink" title="5. 使用规则"></a>5. 使用规则</h2><h3 id="1）最左前缀法则（联合索引）"><a href="#1）最左前缀法则（联合索引）" class="headerlink" title="1）最左前缀法则（联合索引）"></a>1）最左前缀法则（联合索引）</h3><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>
<p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p>
<p><img src="https://s2.loli.net/2022/06/04/brk8NdOZXlhq23t.png" alt="image-20220430160710489"></p>
<p>​	在这样一条联合索引中，索引的顺序分别是：profession（47），age（2），status（5），</p>
<ul>
<li><p>profession列一定存在，但在where中的顺序不影响</p>
<ul>
<li><img src="https://s2.loli.net/2022/04/30/zqmAFYeTyiXBrNl.png" alt="image-20220430160919490"></li>
<li>这样两条sql都会走该联合索引，只是索引长度可能不一致，第一条会按顺序查询 pro，age，status三条索引（54）</li>
<li>下面一条没有status，只会顺序查询pro，age两条索引（49）</li>
</ul>
</li>
<li><p>中间跳过某一列后，后面的索引就会失效</p>
<ul>
<li><p><img src="https://s2.loli.net/2022/04/30/AnONs5KXudJpZgv.png" alt="image-20220430161324620"></p>
</li>
<li><p>这样两条sql都会走联合查询，因为有pro在（最左边的列在）（where后and的顺序不重要）</p>
</li>
<li><p>但是只会查询pro索引，因为跳过了中间的age索引（没有），那么age后status索引也不会查询（47）</p>
</li>
<li><p>可以这样说：age单说是没有索引的，因为如果只根据age去查，没有pro的话，age的索引也不会用到</p>
</li>
<li><p>注：如果select字段中包含了该联合查询的字段而不需要回表查询也会使用联合查询</p>
<p><img src="https://s2.loli.net/2022/04/30/AgFNWb4lrUYofGe.png" alt="image-20220430182127493"></p>
<p><img src="https://s2.loli.net/2022/04/30/VRtgf75F6iyTZXM.png" alt="image-20220430182201299"></p>
</li>
</ul>
</li>
</ul>
<p>​				因为select字段在pro_age_sta的联合索引中都含有，而id则是联合索引的叶子节点值，所以通过索引能将这些值全部查询出来，这样就会使用索引，虽然不满足最左前缀原则，之前不使用是因为select * ，不能直接通过该联合索引获取所有值，需要回表查询</p>
<p>联合索引失效tips：</p>
<ul>
<li>跳过联合索引中的某一列，该列右边的所有索引都会失效</li>
<li>若在索引上使用了&gt;，&lt; 等范围查询会让该索引右边的列索引失效（自身不会失效）<ul>
<li><img src="https://s2.loli.net/2022/04/30/oej2vmnNVUDzhWZ.png" alt="image-20220430162904070"></li>
<li>上面这条查询会查询pro，age，但是age使用了范围查询&gt;，所以age不会失效，status索引会失效（49）</li>
<li>解决办法：在业务允许的情况下，尽量使用&gt;&#x3D;和&lt;&#x3D;</li>
<li><img src="https://s2.loli.net/2022/04/30/IyqERfjPizUQOSs.png" alt="image-20220430163118495"></li>
<li>这样查询就会查询pro，age，status三条索引</li>
</ul>
</li>
</ul>
<p>​			</p>
<h3 id="2）普通索引失效情况"><a href="#2）普通索引失效情况" class="headerlink" title="2）普通索引失效情况"></a>2）普通索引失效情况</h3><ol>
<li><p>在索引列上进行运算操作（如函数运算），索引将失效。</p>
<p>如：查询手机号后两位是15的用户</p>
<p><code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></p>
<p>这样不会走phone索引，因为在phone索引上进行了函数运算</p>
</li>
<li><p>字符串类型字段使用时，不加引号，索引将失效。</p>
<p>如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</p>
<p>虽然可以查询出来，但是并不会走phone的索引</p>
</li>
<li><p>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。</p>
<p>如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code> 前面有%会失效</p>
<p>​	    <code>explain select * from tb_user where profession like &#39;工程%&#39;;</code>后面有%不会失效</p>
<p>注：’_’ 和 ‘%’ 的情况是一样的</p>
</li>
<li><p>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</p>
<p><img src="https://s2.loli.net/2022/04/30/6QNDVjHxdI5Fatu.png" alt="image-20220430165521463"><img src="https://s2.loli.net/2022/04/30/ez7OVMCQshElxrT.png" alt="image-20220430165544822"></p>
<p>如该条数据，可能会走主键索引，但是最后没走索引，因为age没有索引，解决办法就是为age添加上索引</p>
</li>
<li><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</p>
<p>如：<code>explain select * from tb_user where profession is null;</code> pro字段只有少部分是null，所以会走索引</p>
</li>
</ol>
<p>​			   <code>explain select * from tb_user where profession is not null;</code> pro字段大部分都不是null，这样还不如扫描all，所以不会走索引</p>
<h3 id="3）SQL-提示"><a href="#3）SQL-提示" class="headerlink" title="3）SQL 提示"></a>3）SQL 提示</h3><p>​	是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的：</p>
<p>如用户告诉mysql在有多个索引的情况下，选择哪个索引而不是让mysql的优化选择器自己选择</p>
<p>例如：</p>
<ol>
<li><p>在可能多个索引的情况下：</p>
<p>使用哪个索引：</p>
<p><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p>
<p>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p>
</li>
</ol>
<p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p>
<h3 id="4）覆盖索引-amp-回表查询"><a href="#4）覆盖索引-amp-回表查询" class="headerlink" title="4）覆盖索引&amp;回表查询"></a>4）覆盖索引&amp;回表查询</h3><ul>
<li>覆盖索引：根据索引可以查询出所有数据</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/30/LHd9CkzsG2rFv5p.png" alt="image-20220430184740825"></p>
<p><img src="https://s2.loli.net/2022/04/30/cCjQklvUs84A76o.png" alt="image-20220430184754971"></p>
<p>查询的数据中id值在该联合索引（二级索引）的叶子节点，所以只需要查一次联合索引就可以查询出所有值而不需要回表查询</p>
<ul>
<li>回表查询：二级索引不能查询出所有值，需要通过查询出的主键id来查询聚集索引获取值</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/30/7MSNr4i3qFDPYb2.png" alt="image-20220430185245418"></p>
<p><img src="https://s2.loli.net/2022/04/30/75qcEWAOeDoXujJ.png" alt="image-20220430185302627"></p>
<p>虽然使用了索引查询，但是因为查询的字段中的gender和email是无法通过该联合索引查询出来的，所以在通过二级索引获取了id，profession，age后，还需要通过id值查询聚集索引来获取剩下的gender和email，这就进行了回表查询</p>
<h3 id="5）前缀索引"><a href="#5）前缀索引" class="headerlink" title="5）前缀索引"></a>5）前缀索引</h3><p>当字段类型为字符串（varchar, text等）时，如果在这些字段上建立索引会导致建立的索引较大，查询时，也会浪费大量的磁盘IO，影响</p>
<p>查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>比如要在email上建立索引，我们可以截取email的前几个char作为索引，这样就可以减小索引长度，可以根据一个比值选择性k来判断取值的合理性：不同的subString&#x2F;all，eg：当我们截取email字段前5个的时候，10个email中8个的前5个char都不一样，只有两个的前5个char是一样的，这时候k&#x3D;8&#x2F;10&#x3D;0.8，我就可以在k和长度之间做取舍</p>
<p>求选择性公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</span><br></pre></td></tr></table></figure>

<p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code></p>
<p>show index 里面的sub_part可以看到接取的长度</p>
<h3 id="6）单列索引-amp-联合索引"><a href="#6）单列索引-amp-联合索引" class="headerlink" title="6）单列索引&amp;联合索引"></a>6）单列索引&amp;联合索引</h3><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>这句只会用到phone索引字段，该sql会进行回表查询，因为phone的单列索引中并不包含name列</p>
<p>所以我们可以根据查询条件构建联合索引（注意顺序——最左前缀法则）</p>
<p><code>create index idx_user_phone_name on tb_user(phone,name);</code></p>
<p>注意事项</p>
<ul>
<li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li>
</ul>
<h3 id="7）设计原则"><a href="#7）设计原则" class="headerlink" title="7）设计原则"></a>7）设计原则</h3><ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li>
<li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li>
</ol>
<h1 id="四、-sql优化"><a href="#四、-sql优化" class="headerlink" title="四、 sql优化"></a>四、 sql优化</h1><p><img src="https://s2.loli.net/2022/05/04/TgKzdrDO5u6Mxf2.png" alt="image-20220503171504262"></p>
<h2 id="1-插入数据（insert，load）"><a href="#1-插入数据（insert，load）" class="headerlink" title="1.插入数据（insert，load）"></a>1.插入数据（insert，load）</h2><p>普通插入：</p>
<ol>
<li>采用批量插入（一次插入的数据不建议超过1000条）</li>
<li>手动提交事务（mysql默认自动提交事务，执行3条insert就会有三次事务，可以直接start transaction (3条insert) commit）</li>
<li>主键顺序插入</li>
</ol>
<p>大批量插入（load本地文件）：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p>
<p>①客户端连接服务端时，加上参数 –local-infile（这一行在bash&#x2F;cmd界面输入）<br><code>mysql --local-infile -u root -p</code></p>
<p>②设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</p>
<p><code>set global local_infile = 1;</code><br><code>select @@local_infile;</code></p>
<p>③执行load指令将准备好的数据，加载到表结构中</p>
<p><code>load data local infile &#39;/root/sql1.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;</code></p>
<h2 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2.主键优化"></a>2.主键优化</h2><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p>
<p>a. 页分裂：</p>
<p><img src="https://s2.loli.net/2022/05/03/ivgQnFRIlw8AuPS.png" alt="image-20220501184608187"></p>
<p><img src="https://s2.loli.net/2022/05/03/8NQSBUeDgXZ5Apy.png" alt="image-20220501184715525"></p>
<p>若不按顺序排列，在后面就会涉及到一个重新排序的页分裂动作</p>
<p>b. 页合并：</p>
<p><img src="https://s2.loli.net/2022/05/03/RYzTaZNEGrg5xuk.png" alt="image-20220501184804556"></p>
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p>
<p>如图中14，15，16三条数据已经被标记不被使用，如果此时page2的删除达到阈值，就会尝试将右边的17，18，19合并进一个page</p>
<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p>
<blockquote>
<p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p>
</blockquote>
<p>个主键设计原则：</p>
<ul>
<li><p>满足业务需求的情况下，尽量降低主键的长度</p>
<ul>
<li>二级索引叶子节点挂的是主键，如果主键较长，二级索引较大会占用IO，效率变低</li>
</ul>
</li>
<li><p>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</p>
</li>
<li><p>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</p>
<ul>
<li>因为这些是无序插入，会产生页分裂现象，并且长度可能较长</li>
</ul>
</li>
<li><p>业务操作时，避免对主键的修改</p>
</li>
</ul>
<h2 id="3-order-by优化"><a href="#3-order-by优化" class="headerlink" title="3.order by优化"></a>3.order by优化</h2><ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li>
</ol>
<p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p>
<p>总结：</p>
<ul>
<li><p>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</p>
<ul>
<li>order by phone，age; 在index&#x3D;age，phone的情况下是不会使用索引的，因为首先按phone排序，但是索引第一个是age</li>
</ul>
</li>
<li><p>尽量使用覆盖索引</p>
</li>
<li><p>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</p>
</li>
<li><p>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</p>
</li>
</ul>
<h2 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4.group by优化"></a>4.group by优化</h2><ul>
<li>在分组操作时，可以通过索引来提高效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<p>如索引为<code>idx_user_pro_age_stat</code>，</p>
<p><code>select profession,age,coun(*) from tb_user group by profession</code> </p>
<p><code>select age where profession group by age</code> （where 后有了profession，也算是最左）</p>
<p>以上两条都符合最左前缀法则</p>
<p>注意：</p>
<p><code>explain select age,count(age) from tb_user group by age;</code></p>
<p>虽然也用到了索引，但是也用到了临时表，其实效率并不高</p>
<h2 id="5-limit优化"><a href="#5-limit优化" class="headerlink" title="5.limit优化"></a>5.limit优化</h2><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过<code>覆盖索引</code>加<code>子查询</code>形式进行优化</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 此语句耗时很长</span><br><span class="line">select * from tb_sku limit 9000000, 10;</span><br><span class="line">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="line">select id from tb_sku order by id limit 9000000, 10;</span><br><span class="line">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="line">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="line">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="line">select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</span><br></pre></td></tr></table></figure>



<h2 id="6-count优化"><a href="#6-count优化" class="headerlink" title="6.count优化"></a>6.count优化</h2><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p>
<p><img src="https://s2.loli.net/2022/05/04/PxhtBiqX7AenEkU.png" alt="image-20220503163840118"></p>
<p>​	从上面可以看出，count(1)和count(*)是没有取值的过程，所以小</p>
<h2 id="7-update优化（避免行锁升级为表锁）"><a href="#7-update优化（避免行锁升级为表锁）" class="headerlink" title="7.update优化（避免行锁升级为表锁）"></a>7.update优化（避免行锁升级为表锁）</h2><p>InnoDB 的<code>行锁是针对索引加的锁</code>，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>
<p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p>
<h1 id="五、视图-x2F-存储过程-x2F-触发器"><a href="#五、视图-x2F-存储过程-x2F-触发器" class="headerlink" title="五、视图&#x2F;存储过程&#x2F;触发器"></a>五、视图&#x2F;存储过程&#x2F;触发器</h1><p><img src="https://s2.loli.net/2022/05/06/VwHtZGLrs3XCBof.png" alt="image-20220506163730446"></p>
<h2 id="1-视图"><a href="#1-视图" class="headerlink" title="1. 视图"></a>1. 视图</h2><p>①语法</p>
<p><img src="https://s2.loli.net/2022/05/04/jKNSIomCEZrgUYO.png" alt="image-20220504160140852"></p>
<p>1）with cascaded check option</p>
<p>v1 通过 user基表建立，v2通过v1建立，v3通过v2建立</p>
<p><img src="https://s2.loli.net/2022/05/04/PF2Ilnyv3WgJ158.png" alt="image-20220504161658280"></p>
<p><img src="https://s2.loli.net/2022/05/04/w3E84SoP5DQrZfz.png" alt="image-20220504162025288"></p>
<p>当v2表cascaded后，它在insert数据的时候也会检查其所依赖的v1条件；v3没有cascaded，虽然它依赖了cascaded的v2，但是insert的数据检查也只会检查v1，v2的条件，并不会检查v3</p>
<p>2）with local check option</p>
<p><img src="https://s2.loli.net/2022/05/04/Vt5c6AhszexKqJ4.png" alt="image-20220504162607548"></p>
<p>local就是会递归的去寻找，满足v2后会看v1的option，如果没有则不会管v1的条件</p>
<p>3）相关事项及实例</p>
<p>注意：</p>
<ul>
<li>视图的增删改操作必须是视图中的一条数据对应基表的一条数据，若使用了聚合函数、group by、distinct、having、union(all)等，视图是无法更新的</li>
<li>视图的作用：<ul>
<li>简单：方便用户对数据理解，可以将经常查询的数据定义成一张视图</li>
<li>安全：视图能让用户只浏览和修改到他们被允许的数据（mysql的表权限中不包含columns的权限）</li>
<li>数据独立：屏蔽真实表结构变化带来的影响 name -&gt; stuName</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/05/04/qWYeCaVbirOBp5U.png" alt="image-20220504164219294"></p>
<p>​	三表联查：</p>
<p>​	<img src="https://s2.loli.net/2022/05/04/6NOkcM4nKSljq2P.png" alt="image-20220504165031609"></p>
<h2 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2. 存储过程"></a>2. 存储过程</h2><h3 id="1）变量"><a href="#1）变量" class="headerlink" title="1）变量"></a>1）变量</h3><p>1）系统变量（@@）</p>
<p>​	session：会话变量，在另外一个会话中则不存在，未指定默认是session</p>
<p>​	global：全局变量，在所有会话中都存在，但是在restart mysql后还是不会改变（持久改变需要在配置文件中配置）</p>
<p><img src="https://s2.loli.net/2022/05/04/O56V1xY4XIUQKdC.png" alt="image-20220504205411850"></p>
<p>2）用户自定义变量（@）</p>
<p><img src="https://s2.loli.net/2022/05/04/4TOz2eSnJlQgwMG.png" alt="image-20220504205426856"></p>
<p>3）局部变量</p>
<p>​	只在存储过程中生效</p>
<p><img src="https://s2.loli.net/2022/05/05/PRMQ3GcIDke2JT8.png" alt="image-20220505210448969"></p>
<h3 id="2）存储过程中的语法"><a href="#2）存储过程中的语法" class="headerlink" title="2）存储过程中的语法"></a>2）存储过程中的语法</h3><h4 id="①if"><a href="#①if" class="headerlink" title="①if"></a>①if</h4><p><img src="https://s2.loli.net/2022/05/05/FkjyDKNR7I3vOJp.png" alt="image-20220505154639503"></p>
<p>​	</p>
<h4 id="②case"><a href="#②case" class="headerlink" title="②case"></a>②case</h4><p><img src="https://s2.loli.net/2022/05/05/OWcUtonTPCm1AIz.png" alt="image-20220505154816329"></p>
<p>​	<img src="https://s2.loli.net/2022/05/05/sdyktMcIi34x7Yf.png" alt="image-20220505155327524"></p>
<h4 id="③while"><a href="#③while" class="headerlink" title="③while"></a>③while</h4><p><img src="https://s2.loli.net/2022/05/05/om9e35AVERQkFtp.png" alt="image-20220505164543557"></p>
<h4 id="④repeat"><a href="#④repeat" class="headerlink" title="④repeat"></a>④repeat</h4><p><img src="https://s2.loli.net/2022/05/05/nvBiLafzYgQoTdE.png" alt="image-20220505164840620"></p>
<h4 id="⑤loop"><a href="#⑤loop" class="headerlink" title="⑤loop"></a>⑤loop</h4><p><img src="https://s2.loli.net/2022/05/05/sGodEcNFX4xguPp.png" alt="image-20220505164923239"></p>
<p><img src="https://s2.loli.net/2022/05/05/6iQB9kvRUHuPTaF.png" alt="image-20220505165923716"></p>
<h4 id="⑥cursor-游标"><a href="#⑥cursor-游标" class="headerlink" title="⑥cursor 游标"></a>⑥cursor 游标</h4><p>游标类似于一个集合、迭代器，每次从游标中取一行数据</p>
<p>​	<img src="https://s2.loli.net/2022/05/05/OfSv69jIyRxr2ZU.png" alt="image-20220505172302719"></p>
<p>eg：</p>
<p><img src="https://s2.loli.net/2022/05/05/1YSkTZX36dUajbK.png" alt="image-20220505172434324"></p>
<h4 id="⑦handler-条件处理程序"><a href="#⑦handler-条件处理程序" class="headerlink" title="⑦handler 条件处理程序"></a>⑦handler 条件处理程序</h4><p>类似于异常处理，根据捕获的异常码来处理</p>
<p><img src="https://s2.loli.net/2022/05/05/6sTWjenSC1rkZJK.png" alt="image-20220505211156206"></p>
<p>eg：</p>
<p><img src="https://s2.loli.net/2022/05/05/Q7jpROgLsWVGa8F.png" alt="image-20220505172652900"></p>
<p><img src="https://s2.loli.net/2022/05/05/oVfsBG8Y5zRk9g2.png" alt="image-20220505211219491"></p>
<p>这个对游标的改进就是在，游标抛出异常02000（not found）后关闭cursor</p>
<h3 id="3）存储函数"><a href="#3）存储函数" class="headerlink" title="3）存储函数"></a>3）存储函数</h3><p><img src="https://s2.loli.net/2022/05/05/Kqopg7ycnHTEiJA.png" alt="image-20220505211335765"></p>
<p><img src="https://s2.loli.net/2022/05/05/5tnMHfhJiLPN8zA.png" alt="image-20220505173415696"></p>
<h2 id="3-触发器"><a href="#3-触发器" class="headerlink" title="3. 触发器"></a>3. 触发器</h2><p>触发器可以在insert&#x2F;update&#x2F;delete 语句执行之后，执行触发器中定义的sql，可以完成日志记录、数据校验等工作</p>
<p>触发器目前只支持 <code>行级触发</code>：如一条语句影响了5行数据，那么触发器会被执行5次</p>
<p>​								<code>语句级触发</code>：如一条语句影响了多行数据，但是触发器只会触发一次</p>
<p><img src="https://s2.loli.net/2022/05/05/VZqa8Y4G7PQkyn1.png" alt="image-20220505211434421"></p>
<p>1）语法</p>
<p><img src="https://s2.loli.net/2022/05/06/PKirfo5e8sMUayt.png" alt="image-20220506160024421"></p>
<p>2）案例</p>
<p>eg1：insert案例</p>
<p><img src="https://s2.loli.net/2022/05/06/U28D1M73bECdFNB.png" alt="image-20220506162909736"></p>
<p>eg2：update案例</p>
<p><img src="https://s2.loli.net/2022/05/06/FPUskB4agijIlmc.png" alt="image-20220506162935928"></p>
<p>eg3：delete案例</p>
<p><img src="https://s2.loli.net/2022/05/06/NIjZkwAqCT8ag17.png" alt="image-20220506163012628"></p>
<h1 id="六、锁"><a href="#六、锁" class="headerlink" title="六、锁"></a>六、锁</h1><p><img src="https://s2.loli.net/2022/06/06/q3dHPWGOjCmbiuV.png" alt="image-20220507164328021"></p>
<h2 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1. 全局锁"></a>1. 全局锁</h2><p>​	1）全局锁是对整个数据库加锁，加锁后可以查询DQL，但是DDL和DML语句都不能执行，主要用于备份：</p>
<p><img src="https://s2.loli.net/2022/05/09/1TqV4HuaYOr72UZ.png" alt="image-20220506195714936"></p>
<p>​	如在备份库存的过程中，用户下单后，库存扣减，但是备份后的库存还是扣减前的数据，然后开始备份订单表和订单日志表，下单后这些数据都会增加，这两个的备份库都会有新的用户下单的数据，这样就和备份的库存数据不一致了，丧失了数据一致性</p>
<p>2）使用过程</p>
<p><img src="https://s2.loli.net/2022/05/09/tJyPSdwBC9jTQKp.png" alt="image-20220506200002758"></p>
<p><img src="https://s2.loli.net/2022/05/09/nUtDKR5ovh9GS13.png" alt="image-20220506195947699"></p>
<h2 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2. 表级锁"></a>2. 表级锁</h2><h3 id="1）表锁"><a href="#1）表锁" class="headerlink" title="1）表锁"></a>1）表锁</h3><p><img src="https://s2.loli.net/2022/05/09/kOgybzdqNjQ8JEI.png" alt="image-20220506200850896"></p>
<p>读锁（表共享读锁）：读锁本会话可读不可写，其他会话也是可读不可写</p>
<p>写锁（表独占写锁）：写锁本会话可读可写，其他会话不可读不可写（会被阻塞，释放锁以后会继续执行）</p>
<h3 id="2）元数据锁"><a href="#2）元数据锁" class="headerlink" title="2）元数据锁"></a>2）元数据锁</h3><p>在事务中使用sql语句的时候，系统会自动添加</p>
<p><img src="https://s2.loli.net/2022/05/09/n7wA5Xzhkp6cfMI.png" alt="image-20220507110751888"></p>
<p><img src="https://s2.loli.net/2022/05/09/xofWdeGj46PXapn.png" alt="image-20220507110905936"></p>
<p>事务A在做select查询并且事务没结束，那么这时候通过alter改变表结构（元数据）是不被允许的</p>
<h3 id="3）意向锁"><a href="#3）意向锁" class="headerlink" title="3）意向锁"></a>3）意向锁</h3><p>意向锁的作用，一个例子：</p>
<p><img src="https://s2.loli.net/2022/05/09/Auf65IJFRTaBkV2.png" alt="image-20220507151137396"></p>
<p>​	当线程A中的事务中执行update语句的时候（根据id索引）会锁住这一行的数据，如果此时有另外一个线程要为该表加read&#x2F;write lock，那么这个线程有需要一条一条的检查看是否有行锁，这样效率太低了</p>
<p>​	为解决这一问题，在事务中执行sql语句的时候，mysql除了添加行锁，还会为整张表添加一个意向锁，当其他线程要为该表加锁的时候，就可以根据所加的意向锁判断是否能加锁，而不需要一条一条检查数据</p>
<p><img src="https://s2.loli.net/2022/05/09/WNq4xmK3uFQkyEJ.png" alt="image-20220507151525142"></p>
<ul>
<li><p>select …. lock in share mode 会添加意向共享锁，可以与表共享读锁（read）兼容，与表独占写锁（write）互斥（会发生阻塞）</p>
</li>
<li><p>增删改、查询for update 会添加意向排他锁，与read和write都互斥</p>
</li>
<li><p>意向锁直接都是兼容的，意向共享锁和read锁兼容和write锁互斥，意向排他锁与read锁和write都互锁</p>
</li>
</ul>
<h2 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3. 行级锁"></a>3. 行级锁</h2><p><img src="https://s2.loli.net/2022/05/09/1jurzLWNCq38GgR.png" alt="image-20220507164656196"></p>
<h3 id="1）行锁"><a href="#1）行锁" class="headerlink" title="1）行锁"></a>1）行锁</h3><p>行锁有两种：s（共享锁）、x（排他锁）</p>
<p><img src="https://s2.loli.net/2022/05/09/elfca7NMZozb5Bs.png" alt="image-20220507161617768"></p>
<p><img src="https://s2.loli.net/2022/05/09/K8Pkat2cEFLAWrj.png" alt="image-20220507161648455"></p>
<p>总结：</p>
<ul>
<li>增删改操作都是加排他锁</li>
<li>普通select不加锁</li>
<li>select语句后加lock in share mode 共享锁，加for update 加排他锁</li>
</ul>
<p>注意：</p>
<ul>
<li>mysql的行级锁是针对索引的锁，锁住的是聚集索引叶子结点的一个数据，若在增删改的时候没有用到索引，那么行锁就会升级成为表锁</li>
<li>查询元数据锁和行锁的语句<ul>
<li>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from<br>performance_schema.data_locks;</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/05/09/UORIs8H4YrPA6V5.png" alt="image-20220507163229143"></p>
<p><img src="https://s2.loli.net/2022/05/09/STAePBOwDfnj7cJ.png" alt="image-20220507163251643"></p>
<h3 id="2）间隙锁、临键锁"><a href="#2）间隙锁、临键锁" class="headerlink" title="2）间隙锁、临键锁"></a>2）间隙锁、临键锁</h3><p><img src="https://s2.loli.net/2022/05/09/3Y2QDaPhfWiwut7.png" alt="image-20220507164737508"></p>
<p>默认情况下，使用的是next-key临键锁来进行搜索和索引扫描，当某些情况下临键锁可以优化成间隙锁：</p>
<p>如当用主键查询不存在的数据的时候：</p>
<p><img src="https://s2.loli.net/2022/05/09/sZq8wyVMIe5RbNj.png" alt="image-20220507165107119"></p>
<p>事务A我们想插入一条id&#x3D;4的数据，第一次查询id&#x3D;4发现没有数据，这时候临键锁优化为间隙锁，将3与5的间隙锁起来（B+树结构中，这两个row是相邻的），那么事务B就不能在3和5间插入id&#x3D;4的事务，那么事务A在插入id&#x3D;4的数据的时候就不会出现幻读的现象</p>
<h1 id="七、InnoDB引擎"><a href="#七、InnoDB引擎" class="headerlink" title="七、InnoDB引擎"></a>七、InnoDB引擎</h1><h2 id="1-架构图"><a href="#1-架构图" class="headerlink" title="1. 架构图"></a>1. 架构图</h2><h3 id="1）逻辑结构"><a href="#1）逻辑结构" class="headerlink" title="1）逻辑结构"></a>1）逻辑结构</h3><p><img src="https://s2.loli.net/2022/05/09/Op8GUxfHWs54hT3.png" alt="image-20220508165847667"></p>
<h3 id="2）物理结构"><a href="#2）物理结构" class="headerlink" title="2）物理结构"></a>2）物理结构</h3><p><img src="https://s2.loli.net/2022/05/09/mtKREcBoqsPlnM8.png" alt="image-20220507202940981"></p>
<p>逻辑结构：<img src="https://s2.loli.net/2022/05/09/SEk1IJ5BmihubyA.png" alt="image-20220507203031934"></p>
<h2 id="2-事务原理"><a href="#2-事务原理" class="headerlink" title="2. 事务原理"></a>2. 事务原理</h2><p><img src="https://s2.loli.net/2022/05/09/1Ak5SrFvWPBQgzC.png" alt="image-20220507203617939"></p>
<p><img src="https://s2.loli.net/2022/05/09/M1x9wWs8PiyJDad.png" alt="image-20220509203029027"></p>
<p>​	MVCC（无锁）+锁保证了事务的隔离性，redo log 保证了事务的持久性，undo log 保证了事务的原子性，redo log 和 undo log 一起保证了事务的一致性。</p>
<h3 id="1）redo-log"><a href="#1）redo-log" class="headerlink" title="1）redo log"></a>1）redo log</h3><p>​	redo log保证了事务的<code>持久性</code></p>
<p><img src="https://s2.loli.net/2022/05/09/nVMW81tYsRckBX4.png" alt="image-20220507204134284"></p>
<p>问题情境：</p>
<p>​	InnoDB内存结构中，主要的内存区就是缓冲池，缓冲池中缓冲了很多的数据页。当我们在一个事务中执行增删改操作的时候，InnoDB会先操作缓冲池中的数据，将缓冲池中的数据修改，在缓冲区中被修改过的数据页称为脏页。脏页会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区中数据和磁盘中的数据一致。因此缓冲区的脏页数据并不是实时刷新的，若过一段时间后在从缓冲区向磁盘刷新数据的过程中出错了，但提示给用户事务提交成功，但是数据却没持久化下来。</p>
<p>解决办法redo log：</p>
<p>​	有了redo log 后，在对缓冲区的数据进行增删改操作后，会首先将数据页的变化记录在redo log buffer中，在事务提交时会将redo log buffer中的数据刷新到redo log磁盘文件中。如果脏页数据出错，此时就可以借助于redo log来进行数据恢复，以此来保护数据持久性。若 脏页数据已经成功刷新到磁盘 或 涉及到的数据已经落盘，那么redo log就没用了，可以删除了，所以存在的两个redo log文件是循环写的（一个没用了删掉用另一个）</p>
<p>总结：</p>
<ul>
<li>redo log 有两部分<ul>
<li>内存：redo log buffer 在事务提交后马上刷新给磁盘中的redo log</li>
<li>磁盘：两个redo log 循环写</li>
</ul>
</li>
<li>为什么不能直接将脏页数据实时刷新，而是刷新redo log buffer中的数据？<ul>
<li>因为操作的数据页地址是随机的，如果实时刷新脏数据，那么就是随机IO（随机读写磁盘），性能低</li>
<li>redo log的刷新是顺序IO（日志按顺序写的），数据效率高</li>
</ul>
</li>
</ul>
<h3 id="2）undo-log"><a href="#2）undo-log" class="headerlink" title="2）undo log"></a>2）undo log</h3><p>​	undo log 保证了事务的<code>原子性</code></p>
<p>​	undo log 主要是为了 <code>回滚事务</code> 和 <code>MVCC</code>，不同于redo log 是物理日志，undo log 是逻辑日志：</p>
<p>​	当在事务中执行了一条insert语句后，undo log就会记录一条相反逻辑的delete语句，执行一条update语句后，undo log就会记录一条相反逻辑的update语句</p>
<ul>
<li><p>undo log 的销毁：</p>
<ul>
<li>在执行完事务后（commit 或 rollback后），并不会马上删除，因为MVCC还可能用到undo log</li>
</ul>
</li>
<li><p>undo log 的存储：undo log 通过段segment的方式存储，（segment有 数据段—B+树叶子节点，索引段—非叶子节点，回滚段—undo log）</p>
</li>
<li><p>两个作用：</p>
<ul>
<li>回滚：回滚是在事务结束的时候（commit或rollback），如果选择回滚，那么mysql会执行undo log中的逻辑记录</li>
<li>MVCC：undo log 中记录了版本链，版本链配合readview来完成MVCC版本控制</li>
</ul>
</li>
</ul>
<h3 id="3）MVCC"><a href="#3）MVCC" class="headerlink" title="3）MVCC"></a>3）MVCC</h3><p><img src="https://s2.loli.net/2022/05/09/M1x9wWs8PiyJDad.png" alt="image-20220509203029027"></p>
<p>MVCC是在快照读的时候通过<code>事务id</code>，<code>undo log 版本链</code>，<code>ReadView</code>来查找返回的历史版本数据。</p>
<p>MVCC就是通过表中的隐藏字段<code>事务id</code>，<code>undo log 版本链</code>，<code>ReadView</code>（事务确定）三者来实现的：</p>
<p>查询的时候会根据<code>当前的事务活动情况</code>和<code>事务id</code>来确定<code>ReadView</code>，然后再从<code>undo log版本链</code>头部开始通过查看<code>事务id</code>是否满足<code>ReadView</code>的匹配条件，满足条件则返回该版本</p>
<h4 id="①当前读和快照读"><a href="#①当前读和快照读" class="headerlink" title="①当前读和快照读"></a>①当前读和快照读</h4><p>a）当前读</p>
<p><img src="https://s2.loli.net/2022/05/09/73tWz4SUXwqK8f6.png" alt="image-20220509155839795"></p>
<p>当前读读取的是记录的最新版本，读取的需要保证其他并发事务，所以会对读取的数据加锁</p>
<p>eg：</p>
<p><img src="https://s2.loli.net/2022/05/09/pebuDKW48JadAIx.png" alt="image-20220509161941938"></p>
<p>​	当A事务开启后，①的查询结果id&#x3D;2是PHP，此时开启B事务并执行修改id&#x3D;2为JSP数据操作，再次通过事务A的①查，查不出该次变化，因为当前隔离级别是可重复读，保证了两次读取事务的一致性；如果读取到当前事务的最新数据，可以使用select …. lock in share mode 来进行当前读，这样读取到的就是最新的数据id&#x3D;2是JSP。</p>
<p>b）快照读</p>
<p><img src="https://s2.loli.net/2022/05/09/13nhUgyF8cwzxsB.png" alt="image-20220509155825016"></p>
<p>​	快照读是根据一定规则MVCC读取记录数据的可见版本，有可能是历史数据，这个过程是不加锁的</p>
<pre><code>* 读已提交：每次的select都是一个快照读
* 可重复读：开启事务后的第一个select是快照读，后续的select只是直接使用第一个快照读的数据（查询的实际上是第一个快照数据）
* 串行化：快照读退化成当前读
</code></pre>
<h4 id="②隐藏字段"><a href="#②隐藏字段" class="headerlink" title="②隐藏字段"></a>②隐藏字段</h4><p><img src="https://s2.loli.net/2022/05/09/K2E1FBPGgZdwhQ3.png" alt="image-20220509162454905"></p>
<p>​	每一张表都会有两个隐藏字段：最近事务id、回滚指针，如果该表结构未指定主键，那么会生成隐藏字段row_id。</p>
<h4 id="③undo-log"><a href="#③undo-log" class="headerlink" title="③undo log"></a>③undo log</h4><p>undo log 是回滚日志，在insert、update、delete的时候会产生回滚数据来产生。</p>
<p>当insert的时候，数据只需要回滚的时候使用，所以commit后（证明没有rollback）可以直接删除</p>
<p>update、delete，数据不仅在回滚的时候需要使用，在快照读的时候也需要，所以不能删除</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=143&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=143&amp;spm_id_from=pageDriver</a></p>
<p>undo log 版本链：</p>
<p><img src="https://s2.loli.net/2022/05/09/O1EnUrXhtJMRKDP.png" alt="image-20220509163719909"></p>
<ul>
<li>每当要修改一条记录的时候，就会在undo log存储该版本（包括事务id，回滚指针指向上个版本），最新记录的回滚指针指向该版本</li>
<li>版本之间通过回滚指针连接，头部是最新记录，尾部是最旧记录</li>
</ul>
<h4 id="④readview-读视图）"><a href="#④readview-读视图）" class="headerlink" title="④readview(读视图）"></a>④readview(读视图）</h4><p>readview是每个事务独有的，主要内容有两部分：有四个字段、定义了 <code>快照读sql</code>访问版本链的规则</p>
<p>a）字段</p>
<p><img src="https://s2.loli.net/2022/05/09/dPaH7NSteDTi8hI.png" alt="image-20220509164846607"></p>
<p>注意max_trx_id 并不是目前最大id，而是最大事务id+1（下一个分配的id）</p>
<p>b）定义的访问undo log 版本链的规则</p>
<p><img src="https://s2.loli.net/2022/05/09/85TpM4tfOrSyZAE.png" alt="image-20220509165041625"></p>
<p>trx_id 代表的当前版本链中隐藏字段中的 <code>事务id</code></p>
<p>注意：不同的隔离级别，会在不同的时机生成readview来进行快照读</p>
<ul>
<li><p>读已提交</p>
<ul>
<li>会在每次select时都生成一个readview来作为此次快照读的依据（读已提交每次select都是一个快照读）</li>
</ul>
</li>
<li><p>可重复读</p>
<ul>
<li>会在第一次select时生成一个readview来作为本次快照读的依据（可重复读只有第一次select是快照读，后序select都是复用该次数据）</li>
</ul>
</li>
</ul>
<h4 id="⑤RC和RR的MVCC"><a href="#⑤RC和RR的MVCC" class="headerlink" title="⑤RC和RR的MVCC"></a>⑤RC和RR的MVCC</h4><p>a）RC 隔离级别</p>
<p><img src="D:/Typora/TyporaPictureBed/image-20220509170102112.png" alt="image-20220509170102112"></p>
<p>PC的每次select都是一个快照读，所以事务5的两次select会有两个ReadView</p>
<p><img src="https://s2.loli.net/2022/05/09/EeXWmpy6u9o4qMV.png" alt="image-20220509170537409"></p>
<p>​	MVCC就是在快照读的时候，根据该次select产生的readView，将undo log 的版本链中从头开始 通过每条数据中隐藏字段中的<code>事务id</code>与readView指定的规则做匹配，如果匹配了则返回该条版本记录。</p>
<p>b）RR 隔离级别</p>
<p><img src="https://s2.loli.net/2022/05/09/6bDL1dOAgfG9ev4.png" alt="image-20220509202827554"></p>
<p>​	在RR隔离级别下，只有在第一个select快照读的时候会生成ReadView，后序的select都是复用该ReadView，所以可以保证多次select的数据是一致的。</p>
<h1 id="八、数据库"><a href="#八、数据库" class="headerlink" title="八、数据库"></a>八、数据库</h1><h2 id="1-基本表"><a href="#1-基本表" class="headerlink" title="1. 基本表"></a>1. 基本表</h2><p><img src="https://s2.loli.net/2022/06/04/ecoGstjKThgfPar.png" alt="image-20220509205237239"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/15/3.%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="prev" title="计网-网络层">
      <i class="fa fa-chevron-left"></i> 计网-网络层
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/04/mysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" rel="next" title="mysql基本语法">
      mysql基本语法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="nav-text">一、事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7ACID"><span class="nav-text">1.四大特性ACID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1"><span class="nav-text">2.并发事务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-text">二、存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">1. MySQL体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B8%B8%E8%A7%81%E5%BC%95%E6%93%8E"><span class="nav-text">2. 常见引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89InnoDB"><span class="nav-text">1）InnoDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89MyISAM"><span class="nav-text">2）MyISAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89Memory"><span class="nav-text">3）Memory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9%E6%AF%94%E8%BE%83"><span class="nav-text">3. 存储引擎特点比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">4. 存储引擎的选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81-%E7%B4%A2%E5%BC%95"><span class="nav-text">三、 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-text">1. 索引结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">1）二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89B-Tree"><span class="nav-text">2）B Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89B-Tree"><span class="nav-text">3）B+Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89InooDB%E7%9A%84%E6%94%B9%E8%BF%9BB-Tree"><span class="nav-text">4）InooDB的改进B+ Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89Hash%E7%B4%A2%E5%BC%95"><span class="nav-text">5）Hash索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">6）面试题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-text">2. 索引分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="nav-text">3. 索引语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-sql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">4. sql性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E9%A2%91%E6%AC%A1"><span class="nav-text">1）查看执行频次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-text">2）慢查询日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89profile"><span class="nav-text">3）profile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89explain"><span class="nav-text">4）explain</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-text">5. 使用规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99%EF%BC%88%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="nav-text">1）最左前缀法则（联合索引）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="nav-text">2）普通索引失效情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89SQL-%E6%8F%90%E7%A4%BA"><span class="nav-text">3）SQL 提示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-amp-%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-text">4）覆盖索引&amp;回表查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-text">5）前缀索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95-amp-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-text">6）单列索引&amp;联合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%89%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-text">7）设计原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81-sql%E4%BC%98%E5%8C%96"><span class="nav-text">四、 sql优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%88insert%EF%BC%8Cload%EF%BC%89"><span class="nav-text">1.插入数据（insert，load）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="nav-text">2.主键优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-order-by%E4%BC%98%E5%8C%96"><span class="nav-text">3.order by优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-group-by%E4%BC%98%E5%8C%96"><span class="nav-text">4.group by优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-limit%E4%BC%98%E5%8C%96"><span class="nav-text">5.limit优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-count%E4%BC%98%E5%8C%96"><span class="nav-text">6.count优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-update%E4%BC%98%E5%8C%96%EF%BC%88%E9%81%BF%E5%85%8D%E8%A1%8C%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%A1%A8%E9%94%81%EF%BC%89"><span class="nav-text">7.update优化（避免行锁升级为表锁）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%A7%86%E5%9B%BE-x2F-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-x2F-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">五、视图&#x2F;存储过程&#x2F;触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%A7%86%E5%9B%BE"><span class="nav-text">1. 视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">2. 存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%8F%98%E9%87%8F"><span class="nav-text">1）变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-text">2）存储过程中的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0if"><span class="nav-text">①if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1case"><span class="nav-text">②case</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2while"><span class="nav-text">③while</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3repeat"><span class="nav-text">④repeat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4loop"><span class="nav-text">⑤loop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5cursor-%E6%B8%B8%E6%A0%87"><span class="nav-text">⑥cursor 游标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A6handler-%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">⑦handler 条件处理程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="nav-text">3）存储函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">3. 触发器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%94%81"><span class="nav-text">六、锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%85%A8%E5%B1%80%E9%94%81"><span class="nav-text">1. 全局锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-text">2. 表级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E8%A1%A8%E9%94%81"><span class="nav-text">1）表锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="nav-text">2）元数据锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-text">3）意向锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-text">3. 行级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E8%A1%8C%E9%94%81"><span class="nav-text">1）行锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E9%97%B4%E9%9A%99%E9%94%81%E3%80%81%E4%B8%B4%E9%94%AE%E9%94%81"><span class="nav-text">2）间隙锁、临键锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81InnoDB%E5%BC%95%E6%93%8E"><span class="nav-text">七、InnoDB引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="nav-text">1. 架构图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">1）逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">2）物理结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="nav-text">2. 事务原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89redo-log"><span class="nav-text">1）redo log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89undo-log"><span class="nav-text">2）undo log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89MVCC"><span class="nav-text">3）MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-text">①当前读和快照读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="nav-text">②隐藏字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2undo-log"><span class="nav-text">③undo log</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3readview-%E8%AF%BB%E8%A7%86%E5%9B%BE%EF%BC%89"><span class="nav-text">④readview(读视图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4RC%E5%92%8CRR%E7%9A%84MVCC"><span class="nav-text">⑤RC和RR的MVCC</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">八、数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%A1%A8"><span class="nav-text">1. 基本表</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="f1ashades"
      src="/images/mine.jpg">
  <p class="site-author-name" itemprop="name">f1ashades</p>
  <div class="site-description" itemprop="description">once again I am a child</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">f1ashades</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
