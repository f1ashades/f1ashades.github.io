<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/source/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="内存布局：程序计数器、虚拟机栈、本地方法区、堆、方法区 垃圾回收：回收对象判断、分代回收、垃圾回收器 类加载：类文件结构、字节码指令、语法糖、类加载阶段：加载-链接-初始化、类加载器、运行器优化 内存模型 JMM：原子性、可见性、有序性">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/04/14/JVM/index.html">
<meta property="og:site_name" content="f1ashades&#39; blogs">
<meta property="og:description" content="内存布局：程序计数器、虚拟机栈、本地方法区、堆、方法区 垃圾回收：回收对象判断、分代回收、垃圾回收器 类加载：类文件结构、字节码指令、语法糖、类加载阶段：加载-链接-初始化、类加载器、运行器优化 内存模型 JMM：原子性、可见性、有序性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/06/29/38qvShOQbldGms6.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/27/T5BR7JZDUELYu2b.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/27/DRCc289wK1hSv7z.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/29/8RJONkdIMucajyi.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/17/Q1FlkS3naJqXzc2.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/17/X62QFSkicJsDWgY.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/17/6sdmzebX8DKHfOn.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/01/X8dWTomO5s39Hy4.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/01/UaiIzyDN78lPbgu.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/04/Ba4miMV36pFl2qA.png">
<meta property="og:image" content="http://s2.loli.net/2022/07/03/MDU1B8s2SwPKCvt.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/04/f6kNQUgCRsy1LoF.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/04/mrs7SpCdgeYGnTV.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/04/n8QpYaRVT546dkx.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/ZdLmxzbvPAaq3co.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/p4TfQUNcydzSGKJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/H7zhawsCA5kRqSy.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/2YhecGiZz37CQRp.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/yRkZCmWE2oIrTSM.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/BUrcvYOGpoC5XMl.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/NrGaLQil8hPMbVm.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/tPIB4N3kanfDY69.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/Qpgj25ekl3w9IWa.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/GNnTSZRcuaKmQts.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/qZN6iSp4I1MKnag.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/84lNOLUYc7tCK5j.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/a5BLmiZKsHCEIo8.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/amAyIFYSldPbqVB.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/05/si5WUdxTFgOl3z4.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/RUkZOs8ogCimcND.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/ywAvFVEpiP2rgok.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/Go1bBr3kJCOKnTt.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/5hgJ9V2sucl6FqW.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/SJA1EXDwajG7mNM.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/yseV5SFGYncUvzB.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/96HIkbjWdKe4rD7.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/lwN1biXnzQRHJ6M.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/RPgxneMjTcFUSDJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/cODKJ2kIAt8lyj4.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/AD2vYyIXtlbWFJg.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/HQB2iTPMcLxwYv1.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/wIn8lk6PEeFR5qp.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/mLMXGicwy5kKWIf.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/N1agmBeFn9zOkHb.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/si21YjGunE4aXqy.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/pZhgTCaoP2ySLWU.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/AKOi1HS6yzuthD3.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/VoiR9G5yqa8Dpw3.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/G9b5aIzQAiHgXZc.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/Gsp6R9VUT3rtBID.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/ovAxhFeSTLcXUWn.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/AR4ToHIMeY2xatD.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/lIsv3fke9A6jhRP.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/8LkCYERbQ67VOng.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/c8FKsml2HzeGZJR.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/IVhC4vBSXoOLUQj.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/4qtzlM7XhYajkvr.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/XvTKt3dGIQxLOl7.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/gs245x8mK3XRFqC.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/06/LDsHQm1ibvoWceZ.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/07/ReT2BzMlSNFCv6P.png">
<meta property="article:published_time" content="2022-04-14T08:05:12.000Z">
<meta property="article:modified_time" content="2022-08-17T06:14:12.631Z">
<meta property="article:author" content="f1ashades">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/06/29/38qvShOQbldGms6.png">

<link rel="canonical" href="http://example.com/2022/04/14/JVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM | f1ashades' blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">f1ashades' blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/14/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mine.jpg">
      <meta itemprop="name" content="f1ashades">
      <meta itemprop="description" content="once again I am a child">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="f1ashades' blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-14 16:05:12" itemprop="dateCreated datePublished" datetime="2022-04-14T16:05:12+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-17 14:14:12" itemprop="dateModified" datetime="2022-08-17T14:14:12+08:00">2022-08-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>64k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:46</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>内存布局：程序计数器、虚拟机栈、本地方法区、堆、方法区</p>
<p>垃圾回收：回收对象判断、分代回收、垃圾回收器</p>
<p>类加载：类文件结构、字节码指令、语法糖、类加载阶段：加载-链接-初始化、类加载器、运行器优化</p>
<p>内存模型 JMM：原子性、可见性、有序性</p>
<span id="more"></span>

<h1 id="一、内存布局"><a href="#一、内存布局" class="headerlink" title="一、内存布局"></a>一、内存布局</h1><p><img src="https://s2.loli.net/2022/06/29/38qvShOQbldGms6.png" alt="image-20220629222922224"></p>
<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><h3 id="1）作用"><a href="#1）作用" class="headerlink" title="1）作用"></a>1）作用</h3><p>用于保存JVM中下一条所要执行的指令的地址</p>
<h3 id="2）特点"><a href="#2）特点" class="headerlink" title="2）特点"></a>2）特点</h3><ul>
<li><p>线程私有</p>
<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
<li>类似操作系统的PCB一样，程序计数器记录了线程上一次结束运行时的环境，当再次运行到该环境的时候可以根据程序计数器来恢复现场</li>
</ul>
</li>
<li><p>不会存在内存溢出</p>
</li>
<li><p>eg：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">20</span> <span class="comment">// PrintStream out = System.out; </span></span><br><span class="line"><span class="number">3</span>: astore_1 <span class="comment">// -- </span></span><br><span class="line"><span class="number">4</span>: aload_1 <span class="comment">// out.println(1); </span></span><br><span class="line"><span class="number">5</span>: iconst_1 <span class="comment">// -- </span></span><br><span class="line"><span class="number">6</span>: invokevirtual #<span class="number">26</span> <span class="comment">// -- </span></span><br><span class="line"><span class="number">9</span>: aload_1 <span class="comment">// out.println(2); </span></span><br><span class="line"><span class="number">10</span>: iconst_2 <span class="comment">// -- </span></span><br><span class="line"><span class="number">11</span>: invokevirtual #<span class="number">26</span> <span class="comment">// -- </span></span><br><span class="line"><span class="number">14</span>: aload_1 <span class="comment">// out.println(3); </span></span><br><span class="line"><span class="number">15</span>: iconst_3 <span class="comment">// -- </span></span><br><span class="line"><span class="number">16</span>: invokevirtual #<span class="number">26</span> <span class="comment">// -- </span></span><br><span class="line"><span class="number">19</span>: aload_1 <span class="comment">// out.println(4); </span></span><br><span class="line"><span class="number">20</span>: iconst_4 <span class="comment">// -- </span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">26</span> <span class="comment">// -- </span></span><br><span class="line"><span class="number">24</span>: aload_1 <span class="comment">// out.println(5); </span></span><br><span class="line"><span class="number">25</span>: iconst_5 <span class="comment">// -- </span></span><br><span class="line"><span class="number">26</span>: invokevirtual #<span class="number">26</span> <span class="comment">// -- </span></span><br><span class="line"><span class="number">29</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如该线程本次执行到了19行，那么下一次再选中该线程，就会从19行开始</li>
</ul>
</li>
</ul>
<h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><h3 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h3><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong>，也就是<strong>栈顶的方法</strong></li>
<li><code>-Xss</code> 栈内存大小</li>
</ul>
<p>​	</p>
<h3 id="2）演示"><a href="#2）演示" class="headerlink" title="2）演示"></a>2）演示</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">		method2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/06/27/T5BR7JZDUELYu2b.png" alt="image-20220627225247898"></p>
<p>在控制台中可以看到，main方法首先调用method1方法，method1方法再调用method2方法，符合栈的特点</p>
<h3 id="3）栈帧"><a href="#3）栈帧" class="headerlink" title="3）栈帧"></a>3）栈帧</h3><p>​	<strong>best origin</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fY0DKPwcyNIhjtBWvaKnew">https://mp.weixin.qq.com/s/fY0DKPwcyNIhjtBWvaKnew</a>	</p>
<p>​		JVM的虚拟机栈是描述Java方法执行的内存区域，并且是<code>线程私有</code>的。<code>栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，就是栈帧从入帧到出帧的过程。</code>当调用到某方法时，该方法进栈，如该方法没调用其它方法，那么它就是当前方法，执行完以后会出栈，完成此次方法调用。</p>
<p>​		在活动线程中，只有位于栈顶的帧才是有效的，称为<code>当前栈帧</code>。正在执行的方法称为<code>当前方法</code>，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。</p>
<p>​		StackOverflowError表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。如果把<code>JVM</code>当做一个棋盘，<code>虚拟机栈</code>就是棋盘上的将&#x2F;帅，<code>当前方法的栈帧</code>就是棋子能走的区域，而<code>操作栈</code>就是每一个棋子。操作栈的压栈和出栈如下图所示</p>
<p><img src="https://s2.loli.net/2022/06/27/DRCc289wK1hSv7z.png" alt="image-20220627230111612"></p>
<p>​		虚拟机栈通过<code>压栈</code>和<code>出栈</code>的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到下一个栈帧上。在执行的过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。栈帧在整个JVM体系中的地位颇高，包括<code>局部变量表</code>、<code>操作栈</code>、<code>动态连接</code>、<code>方法返回地址</code>等。</p>
<h4 id="①局部变量表"><a href="#①局部变量表" class="headerlink" title="①局部变量表"></a>①局部变量表</h4><p>​		局部变量表是存放<code>方法参数</code>和<code>局部变量</code>的区域。我们都知道，类属性变量一共要经历两个阶段，分为<code>准备阶段</code>和<code>初始化阶段</code>，而局部变量是没有准备阶段，只有<code>初始化阶段</code>，而且必须是<code>显示</code>的。</p>
<p>​		如果是非静态方法，则在index[0]位置上存储的是<code>方法所属对象的实例引用</code>，随后存储的是<code>参数</code>和<code>局部变量</code>。字节码指令中的STORE指令就是<code>将操作栈中计算完成的局部变量写回局部变量表的存储空间内</code>。</p>
<p>​		下方有具体例子描述了局部变量表和操作栈如何工作的。</p>
<h4 id="②操作栈"><a href="#②操作栈" class="headerlink" title="②操作栈"></a>②操作栈</h4><p>操作栈是一个<code>初始状态为空的桶式结构栈</code>。在方法执行过程中，会有各种指令往栈中写入和提取信息。JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是<code>操作栈</code>。字节码指令集的定义都是<code>基于栈类型</code>的，栈的深度在方法元信息的stack属性中，下面就通过一个例子来说明下操作栈与局部变量表的交互：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int add() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    int y = 20;</span><br><span class="line">    int z = x + y;</span><br><span class="line"></span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码操作顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int add();</span><br><span class="line">  Code:</span><br><span class="line">     0: bipush        10 // 常量 10 压入操作栈</span><br><span class="line">     2: istore_1     // 并保存到局部变量表的 slot_1 中  （第 1 处）</span><br><span class="line">     3: bipush        20 // 常量 20 压入操作栈</span><br><span class="line">     5: istore_2     // 并保存到局部变量表的 slot_2 中</span><br><span class="line">     6: iload_1      // 把局部变量表的 slot_1 元素（int x）压入操作栈</span><br><span class="line">     7: iload_2      // 把局部变量表的 slot_2 元素（int y）压入操作栈</span><br><span class="line">     8: iadd      // 把上方的两个数都取出来，在 CPU 里加一下，并压回操作栈的栈顶</span><br><span class="line">     9: istore_3     // 把栈顶的结果存储到局部变量表的 slot_3 中</span><br><span class="line">    10: iload_3</span><br><span class="line">    11: ireturn      // 返回栈顶元素值</span><br></pre></td></tr></table></figure>

<p>第 1 处说明：局部变量表就像一个快递柜，有着很多的柜子，依次编号为1,2,3，…，n，字节码指令 <code>istore_1</code> 就代表打开了 1 号柜子，再把栈顶中的值 10 存进去。栈就好如一个桶，任何时候只能对桶口的元素进行操作，所以数据只能在栈顶进行存取。部分指令可以直接在柜子里面直接进行，比如 <code>iinc</code>指令，直接对抽屉里的数值进行 <code>+1</code>操作。我们经常遇到的 i++ 和 ++i，通过字节码对比起来，答案一下子就一目了然了。如下表格所示：</p>
<p><img src="https://s2.loli.net/2022/06/29/8RJONkdIMucajyi.png" alt="image-20220629223100999"></p>
<p>​	左列中，<code>iload_1</code> 从局部变量表的第1号柜子取出一个数，压入栈顶，下一步直接在柜子里实现 + 1的操作，而这个操作时对栈顶元素的值没有任何影响，所以 <code>istore_2</code> 只是把栈顶元素赋值给 a，而右列，它是先在柜子里面进行 +1的操作，然后再通过 <code>iload_1</code> 把第1号柜子里的数压入栈顶，所以<code>istore_2</code>赋给a的值是 +1 之后的值。扩展下，i++ 并非是原子操作。即使通过<code>volatile</code>关键字来修饰，多线程情况下，还是会出现数据互相覆盖的情况。</p>
<h4 id="③动态链接"><a href="#③动态链接" class="headerlink" title="③动态链接"></a>③动态链接</h4><p>​		主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的<strong>常量池</strong>里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</p>
<h4 id="④方法返回地址"><a href="#④方法返回地址" class="headerlink" title="④方法返回地址"></a>④方法返回地址</h4><p>方法执行时有两种退出情况：</p>
<ul>
<li><p>第一，正常退出，即<code>正常执行到任何方法的返回字节码指令</code>，如 <code>RETURN</code>、<code>IRETURN</code>、<code>ARETURN</code>等；</p>
</li>
<li><p>第二，异常退出。<code>无论何种退出情况，都将返回方法当前被调用的位置</code>。方法退出的过程相当于弹出当前栈帧，而退出可能有三种方式：</p>
<ul>
<li><p>返回值压入上层调用栈帧。</p>
</li>
<li><p>异常信息抛给能够处理的栈帧。</p>
</li>
<li><p>PC 计数器指向方法调用后的下一条指令</p>
</li>
</ul>
</li>
</ul>
<h3 id="4）问题辨析"><a href="#4）问题辨析" class="headerlink" title="4）问题辨析"></a>4）问题辨析</h3><ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，</li>
<li>内存空间被大量占用，可执行的线程数就会越少。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span> <span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>( );</span><br><span class="line">    sb.append(<span class="number">1</span>);,</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>以上两种方式中的sb对象都有可能被其它线程锁修改，其它线程有可能获得该sb对象的引用。</p>
<p>​		</p>
<ul>
<li><p>内存溢出</p>
<ul>
<li><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
</li>
<li><p>发生原因</p>
<ul>
<li><p>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</p>
</li>
<li><p>每个栈帧<strong>所占用过大</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5）线程运行诊断"><a href="#5）线程运行诊断" class="headerlink" title="5）线程运行诊断"></a>5）线程运行诊断</h3><p>CPU占用过高</p>
<ul>
<li><p>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p>
<ul>
<li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li>
</ul>
<img src="https://s2.loli.net/2022/08/17/Q1FlkS3naJqXzc2.png" alt="image-20220809212643905" style="zoom:80%;" />

<ul>
<li><p><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</p>
<p><img src="https://s2.loli.net/2022/08/17/X62QFSkicJsDWgY.png" alt="image-20220809212847765"></p>
</li>
<li><p><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong>，可以看到线程状态是Runnable，还可以定位到哪一行代码有问题</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/17/6sdmzebX8DKHfOn.png" alt="image-20220809213526304"></p>
<ul>
<li>jstack还会报告死锁等问题</li>
</ul>
</li>
</ul>
<h2 id="3-本地方法区"><a href="#3-本地方法区" class="headerlink" title="3.本地方法区"></a>3.本地方法区</h2><blockquote>
<p>origin：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fY0DKPwcyNIhjtBWvaKnew">https://mp.weixin.qq.com/s/fY0DKPwcyNIhjtBWvaKnew</a>	</p>
</blockquote>
<p>​		本地方法栈（Native Method Stack）在JVM内存布局中，也是<code>线程对象私有</code>的，但是虚拟机栈“主内”，而本地方法栈“主外”。这个“内外”是针对JVM来说的，本地方法栈为<code>Native方法</code>服务。线程开始调用本地方法时，会进入一个不再受JVM约束的世界。本地方法可以通过<code>JNI</code>（Java Native Interface）来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和JVM相同的能力和权限。当大量本地方法出现时，势必会削弱JVM对系统的控制力，因为它的出错信息都比较黑盒，难以捉摸。对于内存不足的情况，本地方法栈还是会抛出 <code>native heap OutOfMemory</code>。</p>
<p>​		重点说下JNI类本地方法，最常用的本地方法应该是<code>System.currentTimeMills()</code>，<code>JNI</code>使Java深度使用操作系统的特性功能，复用非Java代码。但是在项目过程中，如果大量使用其他语言来实现<code>JNI</code>，就会丧失跨平台特性，威胁到程序运行的稳定性。假如需要与本地代码交互，就可以用中间标准框架来进行解耦，这样即使本地方法崩溃也不至于影响到<code>JVM</code>的稳定。</p>
<ul>
<li>本地方法栈是内存私有的，本地方法栈为<code>Native方法</code>服务（系统调用等）</li>
<li>本地方法区可以访问JVM运行的数据，具有和JVM相同的能力和权限</li>
<li>JNI类本地方法如<code>System.currentTimeMills()</code>，依赖于操作系统的特性功能，大量使用会失去跨平台性。若需要与本地代码交互，可以用中间标准框架解耦。</li>
</ul>
<h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><h3 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h3><p>Heap 堆</p>
<p>​	通过new关键字创建的对象都会被放在堆内存</p>
<h3 id="2）特点-1"><a href="#2）特点-1" class="headerlink" title="2）特点"></a>2）特点</h3><ul>
<li>它是线程共享，堆内存中的对象都需要考虑线程安全问题</li>
<li>有垃圾回收机制</li>
</ul>
<h3 id="3）堆内存溢出"><a href="#3）堆内存溢出" class="headerlink" title="3）堆内存溢出"></a>3）堆内存溢出</h3><ul>
<li>java.lang.OutofMemoryError ：java heap space. 堆内存溢出</li>
<li>可以使用 -Xmx 来指定堆内存，如-Xmx8m指定堆内存为8M</li>
</ul>
<h3 id="4）堆内存诊断"><a href="#4）堆内存诊断" class="headerlink" title="4）堆内存诊断"></a>4）堆内存诊断</h3><ul>
<li>jps 工具<ul>
<li>查看当前系统中有哪些 java 进程</li>
</ul>
</li>
<li>jmap 工具<ul>
<li>查看堆内存<strong>某一时刻</strong>占用情况 jmap - heap 进程id</li>
</ul>
</li>
<li>jconsole 工具<ul>
<li>图形界面的，多功能的监测工具，可以<strong>连续监测</strong></li>
</ul>
</li>
<li>jvisualvm 工具<ul>
<li>可视化JVM，比Jconsle功能更多</li>
</ul>
</li>
</ul>
<p>eg：</p>
<ul>
<li>通过JPS查到java进程号</li>
<li>通过jmap和进程id抓取某时刻堆内存情况，老年代、新生代情况</li>
<li>可以通过Jconsle和jvisualvm进行分析<ul>
<li>查看是哪一些类占用了大量内存，可以看到类中有什么属性</li>
</ul>
</li>
</ul>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p><img src="https://s2.loli.net/2022/07/01/X8dWTomO5s39Hy4.png" alt="20200608150547.png"></p>
<p>​		方法区是是一个规范，逻辑上的定义，不同厂商有不同实现，1.6的<strong>永久代</strong>实现是在<strong>堆内存</strong>中，1.8之后<strong>元空间</strong>实现就是在<strong>本地内存</strong>中了。</p>
<p>​		方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！</p>
<p>​		在JDK8版本中，元空间的前身<code>Pern</code>区已经被淘汰。在JDK7及之前的版本中，<code>Hotspot</code>还有<code>Pern</code>区，翻译为永久代，在启动时就已经确定了大小，难以进行调优，并且只有<code>FGC</code>时会移动类元信息。不同于之前版本的<code>Pern</code>（永久代），JDK8的<code>元空间</code>已经在<code>本地内存</code>中进行分配，并且，<code>Pern</code>区中的所有内容中<code>字符串常量</code>移至<code>堆内存</code>，其他内容也包括了<code>类元信息</code>、<code>字段</code>、<code>静态属性</code>、<code>方法</code>、<code>常量</code>等等都移至<code>元空间</code>内</p>
<h3 id="1）方法区内存溢出"><a href="#1）方法区内存溢出" class="headerlink" title="1）方法区内存溢出"></a>1）方法区内存溢出</h3><ul>
<li>1.8 之前会导致永久代内存溢出<ul>
<li>使用 -XX:MaxPermSize&#x3D;8m 指定永久代内存大小8m</li>
</ul>
</li>
<li>1.8 之后会导致元空间内存溢出<ul>
<li>使用 -XX:MaxMetaspaceSize&#x3D;8m 指定元空间大小8m</li>
</ul>
</li>
</ul>
<h3 id="2）运行时常量池"><a href="#2）运行时常量池" class="headerlink" title="2）运行时常量池"></a>2）运行时常量池</h3><p>下面是反编译的结果，所有地址都是**#**，运行时常量池中所有地址都是真实地址：</p>
<img src="https://s2.loli.net/2022/07/01/UaiIzyDN78lPbgu.png"  style="zoom: 80%;" />

<p>下面是字节码中的指令</p>
<img src="https://s2.loli.net/2022/07/04/Ba4miMV36pFl2qA.png" alt="在这里插入图片描述" style="zoom: 67%;" />

<p>​		Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<p>​		解释器在解释这些字节码指令的时候会，从运行时常量表中去查询具体的地址，找到要执行的类名、方法名、参数类型等</p>
<p><strong>运行时常量池</strong>：</p>
<ul>
<li><p>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</p>
</li>
<li><p>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p>
</li>
</ul>
<h3 id="3）StringTable串池"><a href="#3）StringTable串池" class="headerlink" title="3）StringTable串池"></a>3）StringTable串池</h3><ul>
<li>运行时常量池中的字符串仅是符号，只有在被用到时才会转化为对象<ul>
<li>解释器直行到对应的new String指令后才会将字符串转化为对象</li>
</ul>
</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是StringBuilder和编译器优化</li>
<li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li>
</ul>
<h4 id="①示例"><a href="#①示例" class="headerlink" title="①示例"></a>①示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String f= <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);<span class="comment">//&quot;a&quot;已经在串池中，f还是在堆中</span></span><br><span class="line">String a=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>; <span class="comment">//此时&quot;a&quot; 和 &quot;b&quot; 已经在串池中，但是a也在</span></span><br><span class="line">String b=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> c.intern();</span><br><span class="line">String g=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">System.out.println(a==b);<span class="comment">//true</span></span><br><span class="line">System.out.println(a==c);<span class="comment">//false</span></span><br><span class="line">System.out.println(a==d);<span class="comment">//false</span></span><br><span class="line">System.out.println(a==e);<span class="comment">//true</span></span><br><span class="line">System.out.println(f==g);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h4 id="②字符串变量拼接"><a href="#②字符串变量拼接" class="headerlink" title="②字符串变量拼接"></a>②字符串变量拼接</h4><p>字符串变量拼接的原理是StringBuilder和编译器优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">//懒惰的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// new StringBuilder ( ).append(&quot; a&quot; ).append(&quot;b&quot; ).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2; </span><br><span class="line"><span class="comment">// javac在编译期间的优化，结果已经在编译期确定为ab</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a” + &quot;</span>b<span class="string">&quot;; </span></span><br><span class="line"><span class="string">System.out.println(s3 =s5);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串是懒加载的，只有解释器解释到对应的语句以后才会将String加载到heap</li>
<li>字符串的拼接底层是StringBuilder<ul>
<li>s4最后调用了toString方法，实际上是new了一个新的String，所以s3!&#x3D;s4</li>
<li>s5虽然是字符串拼接，但是”a”和”b”都是常量，在编译期做了优化，可以确定为”ab”，然后去串池中找，所以s3&#x3D;&#x3D;s5</li>
</ul>
</li>
</ul>
<h4 id="③1-8intern方法"><a href="#③1-8intern方法" class="headerlink" title="③1.8intern方法"></a>③1.8intern方法</h4><p>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li><p>如果串池中没有该字符串对象，则放入成功</p>
</li>
<li><p>如果有该字符串对象，则放入失败</p>
</li>
<li><p>无论放入是否成功，都会返回串池中的字符串对象</p>
</li>
</ul>
<p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p>例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 1.str1 则存在于堆内存之中&quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 2.调用 str1 的 intern 方法，这时串池中没有 &quot;ab&quot; ，</span></span><br><span class="line">        <span class="comment">// 则会将该字符串对象放入到串池中，此时堆内存与串池中的 &quot;ab&quot; 是同一个对象</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">st2</span> <span class="operator">=</span> str1.intern();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 给 str3 赋值，因为此时串池中已有 &quot;ab&quot; ，则直接将串池中的内容返回</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 因为堆内存与串池中的 &quot;ab&quot; 是同一个对象，所以以下两条语句打印的都为 true</span></span><br><span class="line">		System.out.println(str1 == st2);</span><br><span class="line">		System.out.println(str1 == str3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2.处，串池中还没有”ab”，所以str1可以放入串池中</li>
</ul>
<p>例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.此处创建字符串对象 &quot;ab&quot; ，因为串池中还没有 &quot;ab&quot; ，所以将其放入串池中</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">// 2.&quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.此时因为在创建 str3 时，&quot;ab&quot; 已存在与串池中，所以放入失败，但是会返回串池中的 &quot;ab&quot; </span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str1.intern();</span><br><span class="line">        </span><br><span class="line">		System.out.println(str1 == str2);<span class="comment">// false</span></span><br><span class="line">		System.out.println(str1 == str3);<span class="comment">// false </span></span><br><span class="line">		System.out.println(str2 == str3);<span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.处，这时候串池中已经有了”ab”，所以str1不能被返回串池，str2返回的实际上是串池的对象</li>
</ul>
<h4 id="④1-6intern方法"><a href="#④1-6intern方法" class="headerlink" title="④1.6intern方法"></a>④1.6intern方法</h4><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[ &quot;a&quot;,&quot;b&quot;&quot;, &quot;ab&quot;&quot;]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line">    <span class="comment">//将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回/s拷贝一份，放入串池</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(s2 == x); <span class="comment">//true</span></span><br><span class="line">    System.out.println(s == x);  <span class="comment">//flase，在1.8中就是true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里是将s复制一份放入串池，所以s并不在串池中，尽管调用了intern方法</li>
</ul>
<h4 id="⑤StringTable垃圾回收"><a href="#⑤StringTable垃圾回收" class="headerlink" title="⑤StringTable垃圾回收"></a>⑤StringTable垃圾回收</h4><ul>
<li><p>-Xmx10m 指定堆内存大小<br>-XX:+PrintStringTableStatistics 打印字符串常量池信息<br>-XX:+PrintGCDetails<br>-verbose:gc 打印 gc 的次数，耗费时间等信息</p>
</li>
<li><p>演示 StringTable 垃圾回收</p>
</li>
<li><p>-Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123; <span class="comment">// j = 100, j = 10000</span></span><br><span class="line">               String.valueOf(j).intern();</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>StringTable是由HashTable实现的，虽然放入了10000个String，但最后只有7000个，说明发生了垃圾回收</li>
</ul>
</li>
</ul>
<h4 id="⑤StringTable调优"><a href="#⑤StringTable调优" class="headerlink" title="⑤StringTable调优"></a>⑤StringTable调优</h4><ul>
<li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p>
<ul>
<li><code>-XX:StringTableSize=桶个数</code></li>
</ul>
</li>
<li><p>考虑是否需要将字符串对象入池</p>
<ul>
<li>如处理500万用户学校信息并且用list存储，这么多用户，肯定有学校信息是一样的<ul>
<li>不入池，会在堆中大量建立String，list指向了这些String，所以并不会垃圾回收</li>
<li>入池，重复的String.intern会从串池返回，list指向的是串池中的String，那么堆中的String就会被GC掉<ul>
<li>下例中addres.add的就是串池中的String，堆中的String会被gc掉</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://s2.loli.net/2022/07/03/MDU1B8s2SwPKCvt.png" alt="image-20220703230949398"></p>
</li>
</ul>
<h4 id="⑥Java-Integer的缓存策略"><a href="#⑥Java-Integer的缓存策略" class="headerlink" title="⑥Java Integer的缓存策略"></a>⑥Java Integer的缓存策略</h4><blockquote>
<p>类似stringTable：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a5d3c1f03d5d">https://www.jianshu.com/p/a5d3c1f03d5d</a></p>
</blockquote>
<h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h2><h3 id="1）基本功能"><a href="#1）基本功能" class="headerlink" title="1）基本功能"></a>1）基本功能</h3><p><img src="https://s2.loli.net/2022/07/04/f6kNQUgCRsy1LoF.png" alt="普通IO和直接内存IO的对比"></p>
<ul>
<li>普通IO<ul>
<li>在读取文件的时候，文件先是到系统内存，java无法从系统内存读入，所以还需备份到java堆内存中才能读入。</li>
<li>堆内存中缓冲区的大小就是我们通过<code>byte[ ] buf = new byte[_1Mb]</code>设定的</li>
</ul>
</li>
<li>直接内存<ul>
<li>直接内存，java和操作系统都可以访问</li>
<li>磁盘文件存入 <strong>direct memory</strong>（在操作系统的内存中）后 java可以直接使用，提高了效率</li>
</ul>
</li>
</ul>
<h3 id="2）直接内存的管理"><a href="#2）直接内存的管理" class="headerlink" title="2）直接内存的管理"></a>2）直接内存的管理</h3><ul>
<li><p>java垃圾回收不能管理到直接内存，直接内存的释放是由底层的<strong>Unsafe</strong>类管理的（进行分配和释放）</p>
</li>
<li><p>ByteBuffer</p>
<ul>
<li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法</li>
</ul>
<ul>
<li>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</li>
</ul>
</li>
<li><p>一个问题：</p>
<ul>
<li><p>一般用 jvm 调优时，会加上下面的参数：</p>
<ul>
<li><p><code>-XX:+DisableExplicitGC  // 静止显示的 GC</code></p>
</li>
<li><p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，ByteBuffer并不会被gc掉，所以其内部的虚引用Cleaner也不会释放内存。它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。在禁用后，我们需要通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h1><h2 id="1-回收对象判断"><a href="#1-回收对象判断" class="headerlink" title="1.回收对象判断"></a>1.回收对象判断</h2><h3 id="1）引用计数法"><a href="#1）引用计数法" class="headerlink" title="1）引用计数法"></a>1）引用计数法</h3><p>​	当一个对象被引用时，就当引用对象的值加一，当值为 0 时，就表示该对象不被引用，可以被垃圾收集器回收。但有一个弊端，如下图所示，循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。</p>
<p>​	<img src="https://s2.loli.net/2022/07/04/mrs7SpCdgeYGnTV.png" alt="image-20220704183223700"></p>
<h3 id="2）可达性分析算法"><a href="#2）可达性分析算法" class="headerlink" title="2）可达性分析算法"></a>2）可达性分析算法</h3><ul>
<li><p>JVM 中的垃圾回收器通过可达性分析来探索所有存活的对象</p>
</li>
<li><p>扫描堆中的对象，看能否沿着 GC Root 对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p>
</li>
<li><p>可以作为 GC Root 的对象：</p>
<ul>
<li><p>系统类：启动类加载器加载的，如Object类对象等</p>
</li>
<li><p>本地方法区中 JNI（即一般说的Native方法）引用的对象</p>
</li>
<li><p>虚拟机栈：栈帧中的局部变量引用的对象</p>
</li>
<li><p>monitor加锁的对象引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38007185/article/details/108093716">https://blog.csdn.net/weixin_38007185/article/details/108093716</a></p>
</li>
</ul>
<h3 id="3）五种引用"><a href="#3）五种引用" class="headerlink" title="3）五种引用"></a>3）五种引用</h3><p><img src="https://s2.loli.net/2022/07/04/n8QpYaRVT546dkx.png" alt="image-20220704183516505"></p>
<h4 id="①强引用"><a href="#①强引用" class="headerlink" title="①强引用"></a>①强引用</h4><p><code>List&lt; Integer &gt; one = new ArrayList&lt;&gt;();</code> </p>
<p>one就强引用了该对象，强引用没断，那么该对象就不会被gc</p>
<h4 id="②软引用（SoftReference）"><a href="#②软引用（SoftReference）" class="headerlink" title="②软引用（SoftReference）"></a>②软引用（SoftReference）</h4><ul>
<li><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</p>
</li>
<li><p>可以配合引用队列来释放软引用自身</p>
</li>
<li><p>软引用演示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*演示 软引用</span></span><br><span class="line"><span class="comment">jvm参数：-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_08_SoftReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       method2();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 -Xmx20m , 因为list是强引用，不会gc掉这些byte[]</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">   		&#125;</span><br><span class="line">		System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示 软引用，软引用了byte[]，所以gc的时候将前4个byte[]gc掉了</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       ArrayList&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">           System.out.println(ref.get());</span><br><span class="line">           list.add(ref);</span><br><span class="line">           System.out.println(list.size());</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">       <span class="keyword">for</span>(SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">           System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>软引用配合引用队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示 软引用 搭配引用队列</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();    </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 关联了引用队列，当软引用所关联的 byte[] 被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB], queue);<span class="comment">//在这里关联了queue</span></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">    Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="③弱引用（WeakReference）"><a href="#③弱引用（WeakReference）" class="headerlink" title="③弱引用（WeakReference）"></a>③弱引用（WeakReference）</h4><ul>
<li><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p>
</li>
<li><p>可以配合引用队列来释放弱引用自身</p>
</li>
<li><p>软、弱引用的释放</p>
<ul>
<li>因为软、弱引用本身也是对象，当他们引用的对象被GC掉后，它们自身会进入一个引用队列，通过遍历释放掉</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/ZdLmxzbvPAaq3co.png" alt="image-20220704183559559"></p>
<ul>
<li><p>弱引用演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> *<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 弱引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">            list.add(weakReference);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(WeakReference&lt;<span class="type">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">                System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示 弱引用搭配 引用队列</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB], queue);<span class="comment">//queue</span></span><br><span class="line">            list.add(weakReference);</span><br><span class="line">            <span class="keyword">for</span>(WeakReference&lt;<span class="type">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">                System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (poll != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(WeakReference&lt;<span class="type">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">            System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="④虚引用（PhantomReference）"><a href="#④虚引用（PhantomReference）" class="headerlink" title="④虚引用（PhantomReference）"></a>④虚引用（PhantomReference）</h4><ul>
<li><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p>
<ul>
<li>当ByteBuffer不再被强引用后就能够被GC掉，ByteBuffer占用的内存虽然被释放掉了，但是直接内存还没有被释放掉</li>
<li>ByteBuffer中有一个Cleaner虚引用，当虚引用引用的ByteBuffer被GC掉，那么虚引用就会进入一个引用队列，有Reference Handler线程来调用Cleaner其中的方法来释放掉直接内存</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/p4TfQUNcydzSGKJ.png" alt="image-20220704185950334"></p>
</li>
</ul>
<h4 id="⑤终结器引用（FinalReference）"><a href="#⑤终结器引用（FinalReference）" class="headerlink" title="⑤终结器引用（FinalReference）"></a>⑤终结器引用（FinalReference）</h4><ul>
<li><p>内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</p>
</li>
<li><p>所以一般需要两次gc，才能把终结期引用的对象回收掉</p>
<img src="https://s2.loli.net/2022/07/06/H7zhawsCA5kRqSy.png" alt="image-20220704190320893" style="zoom: 80%;" />
</li>
<li><p>额外参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1751370">https://cloud.tencent.com/developer/article/1751370</a></p>
</li>
</ul>
<h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h2><h3 id="1）标记-清除"><a href="#1）标记-清除" class="headerlink" title="1）标记-清除"></a>1）标记-清除</h3><p><img src="https://s2.loli.net/2022/07/06/2YhecGiZz37CQRp.png" alt="image-20220704225924900"></p>
<ul>
<li>首先标记垃圾，然后原地清除<ul>
<li>清除就是将这些区域添加到<strong>空闲表</strong>中，类似于操作系统中的<strong>空闲表法</strong>（还有<strong>空闲链表法</strong>）</li>
</ul>
</li>
<li>优点：速度快</li>
<li>缺点：空间不连续，容易产生内存碎片</li>
</ul>
<h3 id="2）标记整理"><a href="#2）标记整理" class="headerlink" title="2）标记整理"></a>2）标记整理</h3><p><img src="https://s2.loli.net/2022/07/06/yRkZCmWE2oIrTSM.png" alt="image-20220704231658043"></p>
<ul>
<li>先标记，再整理</li>
<li>优点：没有内存碎片</li>
<li>缺点：整理会有对象移动，导致整体效率较低</li>
</ul>
<h3 id="3）复制算法"><a href="#3）复制算法" class="headerlink" title="3）复制算法"></a>3）复制算法</h3><p><img src="https://s2.loli.net/2022/07/06/BUrcvYOGpoC5XMl.png" alt="image-20220704231830987"></p>
<ul>
<li><p>将内存区域划分成大小相等的两块区域，先标记，然后将存活对象放到to区，清理from区，最后交换from区和to区</p>
<ul>
<li>将存活的对象放到to区同时也完成了整理工作</li>
</ul>
</li>
<li><p>优点：没有内存碎片</p>
</li>
<li><p>缺点：需要双倍内存空间</p>
</li>
</ul>
<h2 id="3-分代回收"><a href="#3-分代回收" class="headerlink" title="3.分代回收"></a>3.分代回收</h2><h3 id="1）形象理解"><a href="#1）形象理解" class="headerlink" title="1）形象理解"></a>1）形象理解</h3><p>​		对于一个小区的垃圾，日常垃圾如卫生纸、包装纸等，还有家中不是很需要的家具等</p>
<ul>
<li><p>对于需要频繁清理的日常垃圾</p>
<ul>
<li>我们选择将其放入小区中的垃圾场，每天都要回收，发生较为频繁，清理也较快，<strong>类似新生代</strong></li>
</ul>
</li>
<li><p>对于家中不常用家具</p>
<ul>
<li>我们首先暂存在家中，等到空间实在不够了，就来一次大清理，发生的不太频繁，清理时间也较长，<strong>类似老年代</strong></li>
</ul>
</li>
</ul>
<h3 id="2）具体流程"><a href="#2）具体流程" class="headerlink" title="2）具体流程"></a>2）具体流程</h3><ul>
<li><p>整个堆内存分为<strong>新生代</strong>和<strong>老年代</strong>，其中新生代分为<strong>伊甸园</strong>、<strong>幸存区From</strong>、<strong>幸存区to</strong></p>
<p><img src="https://s2.loli.net/2022/07/06/NrGaLQil8hPMbVm.png" alt="image-20220705134633859"></p>
</li>
<li><p>new的新对象会被存入到新生代中的伊甸园中，当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象先复制到<strong>幸存区TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p>
<ul>
<li><p>保证幸存区From有对象的，幸存区To没有对象</p>
<p><img src="https://s2.loli.net/2022/07/06/tPIB4N3kanfDY69.png" alt="image-20220705135112014"></p>
</li>
</ul>
</li>
<li><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><img src="https://s2.loli.net/2022/07/06/Qpgj25ekl3w9IWa.png" alt="image-20220705135402679"></p>
</li>
<li><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），代表这个对象回收的可能性较低，就会被<strong>放入老年代</strong>中</p>
<ul>
<li><p>并不是一定要达到阈值才会晋升到老年代，如果幸存区空间紧张，也有可能提前晋升到老年代（OOM大对象）</p>
<p><img src="https://s2.loli.net/2022/07/06/GNnTSZRcuaKmQts.png" alt="image-20220705135454441"></p>
</li>
</ul>
</li>
<li><p>如果新生代老年代中的内存都满了，就会先触发<strong>Minor GC</strong>，尝试回收新生代内。如果新生代内存还是不足，老年代内存也不足，就会触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<p><img src="https://s2.loli.net/2022/07/06/qZN6iSp4I1MKnag.png" alt="image-20220705135711129"></p>
</li>
</ul>
<h3 id="3）注意事项"><a href="#3）注意事项" class="headerlink" title="3）注意事项"></a>3）注意事项</h3><ul>
<li><p>Minor GC</p>
<ul>
<li>采用的复制算法</li>
<li>会触发stop the world，因为复制的过程涉及到对象地址的改变</li>
</ul>
</li>
<li><p>Full GC</p>
<ul>
<li>采用的标记清除或标记整理</li>
<li>同样会STW，STW的时间会比Minor GC长</li>
</ul>
</li>
<li><p>一个线程中发生了堆内存溢出，并不会导致主线程的结束</p>
<ul>
<li>一个线程内的out of memory不会导致整个java线程结束</li>
</ul>
</li>
<li><p>大对象OOM在<strong>新生代空间不够</strong>，<strong>老年代空间足够</strong>的情况下会直接晋升到老年代</p>
</li>
</ul>
<h2 id="4-JVM参数"><a href="#4-JVM参数" class="headerlink" title="4.JVM参数"></a>4.JVM参数</h2><table>
<thead>
<tr>
<th align="left">含义</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td align="left">堆最大大小</td>
<td>-Xmx 或 -XX:MaxHeapSize&#x3D;size</td>
</tr>
<tr>
<td align="left">新生代大小</td>
<td>-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td>
</tr>
<tr>
<td align="left">幸存区比例</td>
<td>-XX:SurvivorRatio&#x3D;ratio</td>
</tr>
<tr>
<td align="left">晋升阈值</td>
<td>-XX:MaxTenuringThreshold&#x3D;threshold</td>
</tr>
<tr>
<td align="left">晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td align="left">打印GC详情</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td align="left">FullGC 前 MinorGC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<h2 id="5-垃圾回收器"><a href="#5-垃圾回收器" class="headerlink" title="5.垃圾回收器"></a>5.垃圾回收器</h2><h3 id="1）串行垃圾回收器（单线程）"><a href="#1）串行垃圾回收器（单线程）" class="headerlink" title="1）串行垃圾回收器（单线程）"></a>1）串行垃圾回收器（单线程）</h3><ul>
<li>单线程<ul>
<li>只会有一个线程执行垃圾回收</li>
</ul>
</li>
<li>适用于堆内存较小的情况（个人电脑）</li>
<li>-XX:+UseSerialGC&#x3D;serial + serialOld<ul>
<li>serial：新生代垃圾回收器，使用的是复制算法  serialOld：老年代垃圾回收器，使用的是</li>
</ul>
</li>
<li>安全点<ul>
<li>让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象<br>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/84lNOLUYc7tCK5j.png" alt="image-20220705144310887"></p>
<ul>
<li><p><strong>Serial 收集器</strong></p>
<ul>
<li>Serial收集器是最基本的、发展历史最悠久的收集器</li>
<li>特点：<ul>
<li>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ParNew 收集器</strong></p>
<ul>
<li>ParNew收集器其实就是Serial收集器的多线程版本</li>
<li>特点：<ul>
<li>多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Serial Old 收集器</strong></p>
<ul>
<li>Serial Old是Serial收集器的老年代版本</li>
<li>特点：<ul>
<li>同样是单线程收集器，采用<strong>标记-整理算法</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2）吞吐量优先（并行）"><a href="#2）吞吐量优先（并行）" class="headerlink" title="2）吞吐量优先（并行）"></a>2）吞吐量优先（并行）</h3><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>单位时间内，STW总体（stop the world，停掉其他所有工作线程）时间最短</li>
<li><strong>JDK1.8默认使用</strong>的垃圾回收器</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/a5BLmiZKsHCEIo8.png" alt="image-20220705150208030"></p>
<p>注意：</p>
<ul>
<li><p>③和④是冲突的，③一般通过增大堆大小来减少GC频率，而当堆大小增大，则每次gc的最大时间肯定会增大</p>
</li>
<li><p><strong>Parallel Scavenge 收集器</strong>：</p>
<ul>
<li>与吞吐量关系密切，故也称为吞吐量优先收集器</li>
<li>特点：<ul>
<li>属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</li>
</ul>
</li>
<li>GC自适应调节策略：<ul>
<li>Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</li>
</ul>
</li>
<li>Parallel Scavenge收集器使用两个参数控制吞吐量：<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Parallel Old 收集器</strong>：<ul>
<li>是Parallel Scavenge收集器的老年代版本</li>
<li>特点：<ul>
<li>多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3）响应时间优先（并发）"><a href="#3）响应时间优先（并发）" class="headerlink" title="3）响应时间优先（并发）"></a>3）响应时间优先（并发）</h3><ul>
<li><p>多线程</p>
</li>
<li><p>堆内存较大，多核CPU</p>
</li>
<li><p>尽可能让单次STW时间变短（尽量不影响其他线程运行）</p>
</li>
<li><p>吞吐量优先和响应时间优先的差别：</p>
<ul>
<li>吞吐量优先是一段时间内STW时间最短，单次不是最短，但可能一小时就发生2次，响应时间是单次最短，但是一小时可能发生多次（加起来就没吞吐量优先短了）</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/amAyIFYSldPbqVB.png" alt="image-20220705152416011"></p>
<p>注意：</p>
<ul>
<li><p>一个问题：</p>
<ul>
<li><p>由于老年代采用的是标记清除算法，所以可能会产生大量碎片，当老年代碎片过多，新生代内存不，两边都没有空间的时候，老年代的CMS会退化成单线程回收器，进行标记整理工作，这样响应时间就会大大降低，不再是响应优先</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/z69183787/article/details/104921492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164679536916780264056627%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164679536916780264056627&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104921492.pc_search_result_control_group&amp;utm_term=CMS%E5%B9%B6%E5%8F%91%E5%A4%B1%E8%B4%A5&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/z69183787/article/details/104921492?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164679536916780264056627%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164679536916780264056627&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104921492.pc_search_result_control_group&amp;utm_term=CMS%E5%B9%B6%E5%8F%91%E5%A4%B1%E8%B4%A5&amp;spm=1018.2226.3001.4187</a></p>
<ul>
<li><p>新生代可以晋升的时候，老年代无足够空间，就会触发Full GC，Full GC会STW并串行清理</p>
</li>
<li><p>新生代可以晋升的时候，老年代有空间但是是碎片化，无法容纳下，这时候只能STW进行整理移动工作</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>CMS 收集器</strong></p>
<ul>
<li><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p>
</li>
<li><p>特点：</p>
<ul>
<li>基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li>适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b&#x2F;s服务</li>
</ul>
</li>
<li><p>CMS收集器的运行过程分为下列4步：</p>
<ul>
<li><p>初始标记：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
</li>
<li><p>并发标记：进行GC Roots Tracing（通过root找到引用对象）的过程，找出存活对象且用户线程可并发执行</p>
</li>
<li><p>重新标记：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>
</li>
<li><p>并发清除：对标记的对象进行清除回收</p>
</li>
</ul>
</li>
<li><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
</li>
</ul>
</li>
</ul>
<h3 id="4）G1"><a href="#4）G1" class="headerlink" title="4）G1"></a>4）G1</h3><ul>
<li>JDK 9以后默认使用，而且替代了CMS 收集器</li>
<li>使用场景<ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/05/si5WUdxTFgOl3z4.png" alt="image-20220705154815612"></p>
<p><img src="https://s2.loli.net/2022/07/06/RUkZOs8ogCimcND.png" alt="image-20220705155959668"></p>
<h4 id="①Young-Collection"><a href="#①Young-Collection" class="headerlink" title="①Young Collection"></a>①Young Collection</h4><p>​	分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<p><img src="https://s2.loli.net/2022/07/06/ywAvFVEpiP2rgok.png" alt="image-20220705161138453">‘</p>
<ul>
<li>流程<ul>
<li>新对象会被放入伊甸园中</li>
<li>young Collection会将E中幸存的对象复制到幸存区中</li>
<li>幸存区中对象年龄达到阈值（15）就会晋升到老年代，通过复制方式</li>
</ul>
</li>
<li>因为是通过复制方式，所以会STW</li>
</ul>
<h4 id="②Young-Collection-CM（concurrent-mark）"><a href="#②Young-Collection-CM（concurrent-mark）" class="headerlink" title="②Young Collection + CM（concurrent mark）"></a>②Young Collection + CM（concurrent mark）</h4><ul>
<li>在 Young GC 时会<strong>对 GC Root 进行初始并发标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定，默认45%</li>
</ul>
<img src="https://s2.loli.net/2022/07/06/Go1bBr3kJCOKnTt.png" alt="image-20220705161926099" style="zoom:50%;" />



<h4 id="③Mixed-Collection"><a href="#③Mixed-Collection" class="headerlink" title="③Mixed Collection"></a>③Mixed Collection</h4><p>会对E S O 进行<strong>全面的回收</strong></p>
<ul>
<li>最终标记：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，会STW</li>
<li><strong>拷贝</strong>存活</li>
</ul>
<p><strong>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</strong></p>
<img src="https://s2.loli.net/2022/07/06/5hgJ9V2sucl6FqW.png" alt="image-20220705162734905" style="zoom:50%;" />

<ul>
<li><p>因为设定了单次最长STW时间，所以会对老年代进行选择性复制</p>
</li>
<li><p>问：为什么有的老年代被拷贝了，有的没拷贝？</p>
<ul>
<li>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</li>
</ul>
</li>
</ul>
<h2 id="5-Minor-GC和Full-GC辨析"><a href="#5-Minor-GC和Full-GC辨析" class="headerlink" title="5.Minor GC和Full GC辨析"></a>5.Minor GC和Full GC辨析</h2><ul>
<li>SerialGC<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足发生的垃圾收集- full gc</li>
</ul>
</li>
<li>ParallelGc<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足发生的垃圾收集- full gc</li>
</ul>
</li>
<li>CMS<ul>
<li>新生代内存不足发生的垃圾收集-minor gc</li>
<li>老年代内存不足</li>
</ul>
</li>
<li>G1<ul>
<li>新生代内存不足发生的垃圾收集-minor gc</li>
<li>老年代内存不足</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>CMS老年代采用<strong>标记-清除</strong>算法，G1采用<strong>标记-复制</strong>算法<ul>
<li>两者在老年代内存不足时（老年代所占内存超过阈值）<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC，并发失败退化为串行收集</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-Young-Collection-跨代引用"><a href="#6-Young-Collection-跨代引用" class="headerlink" title="6.Young Collection 跨代引用"></a>6.Young Collection 跨代引用</h2><p>​	有这样一个问题，在进行<strong>可达性分析</strong>的时候，有一些GC Root对象是老年代的对象，新生代的对象被这些老年代对象引用着。对于这样一种情况，我们如果通过遍历的方式来遍历老年代的GC Root，那么效率就太低了，可以通过<strong>脏卡</strong>方式来改善。</p>
<p><img src="https://s2.loli.net/2022/07/06/SJA1EXDwajG7mNM.png" alt="image-20220705172515478"></p>
<ul>
<li>将老年代分成一个个card，当某一card中对象引用了新生代对象，就将该card标记为脏卡<ul>
<li>在遍历的时候只需要关注脏卡对象即可</li>
</ul>
</li>
<li>在引用发生更新的时候，由其它线程异步进行更新</li>
</ul>
<h2 id="7-重标记remark"><a href="#7-重标记remark" class="headerlink" title="7.重标记remark"></a>7.重标记remark</h2><p>在垃圾回收时，收集器处理对象的过程中</p>
<ul>
<li><p>黑色：已被处理，需要保留的 </p>
</li>
<li><p>灰色：正在处理中的 </p>
</li>
<li><p>白色：还未处理的</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/yseV5SFGYncUvzB.png" alt="image-20220705173424123"></p>
<p>但是在<strong>并发标记过程中</strong>，考虑下面情况</p>
<ul>
<li>并发标记的过程中，根据A来找引用对象的时候A还没引用C，这时候C没被引用，会被标记为需要清理。而check完后，A又引用了C对象，这时候C就不能被GC掉，再最终标记阶段就会对这种情况做检查。</li>
</ul>
<p>重标记：</p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li>
<li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/96HIkbjWdKe4rD7.png" alt="image-20220705174004628"></p>
<h2 id="8-JDK-GC新特性"><a href="#8-JDK-GC新特性" class="headerlink" title="8.JDK GC新特性"></a>8.JDK GC新特性</h2><h3 id="1）JDK-8u20-字符串去重"><a href="#1）JDK-8u20-字符串去重" class="headerlink" title="1）JDK 8u20 字符串去重"></a>1）JDK 8u20 字符串去重</h3><p>过程</p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>注意，其与String.intern的区别<ul>
<li>intern关注的是字符串对象</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//char[]&#123; &#x27;h&#x27;,&#x27;e &#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//char[]&#123; &#x27;h&#x27;,&#x27;e &#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个对象的char[]都是一样的，就会将s1和s2引用同一个char[]</span></span><br></pre></td></tr></table></figure>

<p>优点与缺点</p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h3 id="2）JDK-8u40-并发标记类卸载"><a href="#2）JDK-8u40-并发标记类卸载" class="headerlink" title="2）JDK 8u40 并发标记类卸载"></a>2）JDK 8u40 并发标记类卸载</h3><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<h3 id="3）JDK-8u60-回收巨型对象"><a href="#3）JDK-8u60-回收巨型对象" class="headerlink" title="3）JDK 8u60 回收巨型对象"></a>3）JDK 8u60 回收巨型对象</h3><ul>
<li><p>一个对象大于region的一半时，就称为巨型对象</p>
</li>
<li><p>G1不会对巨型对象进行拷贝</p>
</li>
<li><p>回收时被优先考虑</p>
</li>
<li><p>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象（即老年代没有再引用该巨型对象）就可以在新生代垃圾回收时处理掉</p>
<p><img src="https://s2.loli.net/2022/07/06/lwN1biXnzQRHJ6M.png" alt="image-20220705174631567"></p>
</li>
</ul>
<h2 id="9-GC调优"><a href="#9-GC调优" class="headerlink" title="9.GC调优"></a>9.GC调优</h2><p>查看虚拟机参数命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;F:\JAVA\JDK8.0\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;Copy</span><br></pre></td></tr></table></figure>

<p>可以根据参数去查询具体的信息</p>
<p><strong>调优领域</strong></p>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<p><strong>确定目标</strong></p>
<p>低延迟&#x2F;高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC</li>
<li>ParallelGC</li>
<li>Zing</li>
</ul>
<p><strong>最快的GC是不发生GC</strong></p>
<p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>
<li>数据是不是太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏<ul>
<li>定义了Static map，只存不删，可通过软、弱引用来解决</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> <strong>新生代调优</strong></p>
<ul>
<li>新生代的特点<ul>
<li>所有的new操作分配内存都是非常廉价的<ul>
<li>TLAB</li>
</ul>
</li>
<li>死亡对象回收零代价</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li>新生代内存越大越好么？<ul>
<li>不是<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
</ul>
</li>
<li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li>
</ul>
</li>
</ul>
<p><strong>幸存区调优</strong></p>
<ul>
<li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold=threshold 晋升阈值</span><br><span class="line"></span><br><span class="line">-XX : +PrintTenuringDistribution</span><br></pre></td></tr></table></figure>



<p><strong>老年代调优</strong></p>
<ul>
<li>以CMS为例</li>
<li>CMS的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有Full GC，那么目前的设置是OK的<ul>
<li>否则先尝试调优新生代</li>
<li>观察发生Full GC时老年代内存占用，将老年代内存预设调大1&#x2F;4~1&#x2F;3</li>
<li><code>-XX:CMSInitiating0ccupancyFraction=percent</code><ul>
<li>当老年代内存占用达到percent阈值时进行CMS垃圾回收</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="三、类加载与字节码"><a href="#三、类加载与字节码" class="headerlink" title="三、类加载与字节码"></a>三、类加载与字节码</h1><h2 id="1-类从源码到运行"><a href="#1-类从源码到运行" class="headerlink" title="1.类从源码到运行"></a>1.类从源码到运行</h2><img src="https://s2.loli.net/2022/07/06/RPgxneMjTcFUSDJ.png" alt="image-20220705183657556" style="zoom: 80%;" />

<p><img src="https://s2.loli.net/2022/07/06/cODKJ2kIAt8lyj4.png" alt="image-20220705183548700" style="zoom:67%;" />编译期</p>
<h3 id="1）编译期"><a href="#1）编译期" class="headerlink" title="1）编译期"></a>1）编译期</h3><p>​		创建完源文件之后，程序先要被 JVM中 的 Java 编译器进行编译为 .class 文件。Java 编译一个类时，如果这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用。如果 Java 编译器在指定的目录下找不到该类所依赖的类的 .class 文件或者 .java 源文件，就会报 “Cant found sysbol” 的异常错误。</p>
<p>​		编译后的字节码文件格式主要分为两部分：常量池和方法字节码。</p>
<ul>
<li>常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、方法引用，成员变量引用等）</li>
<li>方法字节码中放的是各个方法的字节码。</li>
</ul>
<h3 id="2）运行期"><a href="#2）运行期" class="headerlink" title="2）运行期"></a>2）运行期</h3><p>​		Java 类运行的过程大概分为：类的加载和类的执行。需要说明的一点的是：JVM 并不是在运行时就会把<strong>所有使用到的类</strong>都加载到内存中，JVM主要在程序第一次运行时主动使用类的时候，才会立即去加载。</p>
<p>​		在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<ul>
<li>origin：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127553/4328152">https://blog.51cto.com/u_15127553/4328152</a></li>
</ul>
<h2 id="2-类文件结构"><a href="#2-类文件结构" class="headerlink" title="2.类文件结构"></a>2.类文件结构</h2><p>以下是.class文件的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000</span> ca fe ba be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">23</span> 0a <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">15</span> 09  </span><br><span class="line"><span class="number">0000020</span> <span class="number">00</span> <span class="number">16</span> <span class="number">00</span> <span class="number">17</span> 08 <span class="number">00</span> <span class="number">18</span> 0a <span class="number">00</span> <span class="number">19</span> <span class="number">00</span> 1a <span class="number">07</span> <span class="number">00</span> 1b <span class="number">07</span> </span><br><span class="line"><span class="number">0000040</span> <span class="number">00</span> 1c <span class="number">01</span> <span class="number">00</span> <span class="number">06</span> 3c <span class="number">69</span> 6e <span class="number">69</span> <span class="number">74</span> 3e <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span>  </span><br><span class="line"><span class="number">0000060</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span> <span class="number">6f</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0f</span> 4c <span class="number">69</span> 6e <span class="number">65</span> 4e  </span><br><span class="line">.......</span><br></pre></td></tr></table></figure>



<p>根据 JVM规范，<strong>类文件结构</strong>如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">u4 			 magic  <span class="comment">//魔数 ca fe ba be，u4代表占4个字节</span></span><br><span class="line">u2       minor_version;    </span><br><span class="line">u2       major_version;   </span><br><span class="line">u2       constant_pool_count;    </span><br><span class="line">cp_info     constant_pool[constant_pool_count-<span class="number">1</span>];    </span><br><span class="line">u2       access_flags;    </span><br><span class="line">u2       this_class;    </span><br><span class="line">u2       super_class;   </span><br><span class="line">u2       interfaces_count;    </span><br><span class="line">u2       interfaces[interfaces_count];   </span><br><span class="line">u2       fields_count;    field_info   fields[fields_count];   </span><br><span class="line">u2       methods_count;    method_info   methods[methods_count];   </span><br><span class="line">u2       attributes_count;    attribute_info attributes[attributes_count];</span><br></pre></td></tr></table></figure>



<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>u4 magic</p>
<p>对应字节码文件的0~3个字节</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>u2 minor_version;</p>
<p>u2 major_version;</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p>34H &#x3D; 52，代表JDK8</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><img src="https://s2.loli.net/2022/07/06/AD2vYyIXtlbWFJg.png" alt="image-20220705185251860"></p>
<h2 id="3-字节码指令"><a href="#3-字节码指令" class="headerlink" title="3.字节码指令"></a>3.字节码指令</h2><h3 id="1）图解方法执行流程"><a href="#1）图解方法执行流程" class="headerlink" title="1）图解方法执行流程"></a>1）图解方法执行流程</h3><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_1</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>①常量池载入运行时常量池</strong></p>
<p>注意：常量池也属于方法区，在这里单独提出来了</p>
<p><img src="https://s2.loli.net/2022/07/06/HQB2iTPMcLxwYv1.png" alt="image-20220706125116079"></p>
<p><strong>②方法字节码载入方法区</strong></p>
<p>（stack&#x3D;2，locals&#x3D;4，.class文件中记录了） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="https://s2.loli.net/2022/07/06/wIn8lk6PEeFR5qp.png" alt="image-20220706125145763"></p>
<p><strong>③执行引擎开始执行字节码</strong></p>
<p><strong>bipush 10</strong></p>
<ul>
<li>将一个 byte 压入操作数栈（每个操作数栈要求4字节，其长度不够会补齐 4 个字节），类似的指令还有<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/mLMXGicwy5kKWIf.png" alt="image-20220706125216517"></p>
<p><strong>③istore 1</strong></p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中（也就是a）</p>
<p>对应java代码中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/07/06/N1agmBeFn9zOkHb.png" alt="image-20220706125340216"></p>
<p><strong>④ldc #3</strong></p>
<ul>
<li><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p>
<ul>
<li>short以内的数字是和字节码指令一起的，超过了Short.MAX_VALUE + 1会存在运行时常量池</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>Short.MAX_VALUE 是 32767，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算好的</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/si21YjGunE4aXqy.png" alt="image-20220706125440533"></p>
<p><strong>⑤istore 2</strong></p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置，即<code>b=Short.MAX_VALUE + 1</code> </p>
<p><img src="https://s2.loli.net/2022/07/06/pZhgTCaoP2ySLWU.png" alt="image-20220706125533554"></p>
<p><strong>⑥iload1 iload2</strong></p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<ul>
<li>因为只能在操作数栈中执行运算操作</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/AKOi1HS6yzuthD3.png" alt="image-20220706125759484"></p>
<p><strong>⑦iadd</strong></p>
<p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><img src="https://s2.loli.net/2022/07/06/VoiR9G5yqa8Dpw3.png" alt="image-20220706125834363"></p>
<p><strong>⑧istore 3</strong></p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><img src="https://s2.loli.net/2022/07/06/G9b5aIzQAiHgXZc.png" alt="image-20220706125942299"></p>
<p><strong>⑨getstatic #4</strong></p>
<ul>
<li><p>在运行时常量池中找到#4，发现是一个对象</p>
</li>
<li><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><img src="https://s2.loli.net/2022/07/06/Gsp6R9VUT3rtBID.png" alt="image-20220706130017948"></p>
</li>
</ul>
<p><strong>⑩iload 3</strong></p>
<p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><img src="https://s2.loli.net/2022/07/06/ovAxhFeSTLcXUWn.png" alt="image-20220706130033223"></p>
<p><strong>⑪invokevirtual 5</strong></p>
<ul>
<li><p>找到常量池 #5 项，定位到方法区 java&#x2F;io&#x2F;PrintStream.println:(I)V 方法，</p>
</li>
<li><p>有了一个新的方法，生成新的栈帧（分配 locals、stack等）</p>
<ul>
<li><p>传递参数（32778这是上个栈帧的运算结果），执行新栈帧中的字节码</p>
</li>
<li><p><img src="https://s2.loli.net/2022/07/06/AR4ToHIMeY2xatD.png" alt="image-20220706130049277"></p>
</li>
<li><p>执行完毕，弹出栈帧</p>
</li>
<li><p>清除 main 操作数栈内容</p>
</li>
<li><p><img src="https://s2.loli.net/2022/07/06/lIsv3fke9A6jhRP.png" alt="image-20220706130239602"></p>
</li>
</ul>
</li>
</ul>
<p><strong>⑫return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
<h3 id="2）a-问题"><a href="#2）a-问题" class="headerlink" title="2）a++问题"></a>2）a++问题</h3><h4 id="①字节码详解"><a href="#①字节码详解" class="headerlink" title="①字节码详解"></a>①字节码详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从字节码角度分析a++相关题目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++ + ++a + a--;</span><br><span class="line">        system.out.println(a); <span class="comment">//11</span></span><br><span class="line">        system.out.println(b); <span class="comment">//34</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><p>注意 iinc 指令是直接在局部变量 slot 上进行运算 </p>
</li>
<li><p>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</p>
</li>
<li><p>首先读入10，并把其压入操作数栈</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/8LkCYERbQ67VOng.png" alt="image-20220706130803106"></p>
<ul>
<li>把操作数栈中的10放入局部变量表的slot 1中，</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/c8FKsml2HzeGZJR.png" alt="image-20220706131106104"></p>
<ul>
<li><p>注意a++，首先是将slot 1中的10压入操作数栈，然后在让slot 1中的数+1</p>
<p><img src="https://s2.loli.net/2022/07/06/IVhC4vBSXoOLUQj.png" alt="image-20220706131155623"></p>
</li>
<li><p>++a，则是让slot 1中的数+1，然后再压入操作数栈中</p>
<p><img src="https://s2.loli.net/2022/07/06/4qtzlM7XhYajkvr.png" alt="image-20220706131254111"></p>
</li>
<li><p>a–同理，是先在slot 1中-1，然后再压入操作数栈中</p>
<p><img src="https://s2.loli.net/2022/07/06/XvTKt3dGIQxLOl7.png" alt="image-20220706131402230"></p>
</li>
<li><p>最后计算完以后将结果放入slot 2也就是b对应的slot中</p>
<p><img src="https://s2.loli.net/2022/07/06/gs245x8mK3XRFqC.png" alt="image-20220706131515190"></p>
</li>
</ul>
<h4 id="②test"><a href="#②test" class="headerlink" title="②test"></a>②test</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; 	</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>; 	</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; 	</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">10</span>) &#123; </span><br><span class="line">    	x = x++; 	</span><br><span class="line">        i++; 	</span><br><span class="line">    &#125; 	</span><br><span class="line">    System.out.println(x); <span class="comment">//结果为0 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>x&#x3D;x++<ul>
<li>首先将slot 1&#x3D;0压入操作数栈（x&#x3D;0），然后使slot 1&#x3D;0+1</li>
<li>此时slot 1&#x3D;1，操作数栈（x&#x3D;0），最后将操作数栈中的x&#x3D;0重新覆盖掉slot 1中的x&#x3D;1，因此结果最终结果为0</li>
</ul>
</li>
</ul>
<h3 id="3）构造方法"><a href="#3）构造方法" class="headerlink" title="3）构造方法"></a>3）构造方法</h3><h4 id="①静态构造方法-cinit"><a href="#①静态构造方法-cinit" class="headerlink" title="①静态构造方法 cinit()"></a>①静态构造方法 cinit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_12_CinitTest</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	System.out.println(i); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 cinit()V ：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">7</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">        <span class="number">10</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">12</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h4 id="②非静态构造方法-init"><a href="#②非静态构造方法-init" class="headerlink" title="②非静态构造方法 init()"></a>②非静态构造方法 init()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_13_InitTest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Code_13_InitTest</span><span class="params">(String a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Code_13_InitTest</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Code_13_InitTest</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(d.a);</span><br><span class="line">        System.out.println(d.b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法init()V，但原始构造方法内的代码总是在后</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">   <span class="number">0</span>: aload_0</span><br><span class="line">   <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="number">4</span>: aload_0</span><br><span class="line">   <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String s1</span></span><br><span class="line">   <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">  <span class="number">10</span>: aload_0</span><br><span class="line">  <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">  <span class="number">13</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">  <span class="number">16</span>: aload_0</span><br><span class="line">  <span class="number">17</span>: bipush        <span class="number">10</span></span><br><span class="line">  <span class="number">19</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">  <span class="number">22</span>: aload_0</span><br><span class="line">  <span class="number">23</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String s2</span></span><br><span class="line">  <span class="number">25</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">  <span class="comment">// 原始构造方法在最后执行-------------------------------------------------</span></span><br><span class="line">  <span class="number">28</span>: aload_0</span><br><span class="line">  <span class="number">29</span>: aload_1</span><br><span class="line">  <span class="number">30</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">  <span class="number">33</span>: aload_0</span><br><span class="line">  <span class="number">34</span>: iload_2</span><br><span class="line">  <span class="number">35</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">  <span class="number">38</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h3 id="4）方法调用"><a href="#4）方法调用" class="headerlink" title="4）方法调用"></a>4）方法调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo5</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Demo5</span> <span class="variable">demo5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line">		demo5.test1();</span><br><span class="line">		demo5.test2();</span><br><span class="line">		demo5.test3();</span><br><span class="line">		Demo5.test4();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同方法在调用时，对应的虚拟机指令有所区别：</p>
<ul>
<li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li>
<li>普通成员方法在调用时，使用<strong>invokevirtual</strong>指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>
<li>静态方法在调用时使用<strong>invokestatic</strong>指令，如果用对象调用会先让对象进栈再出栈，然后直接通过类调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/nyima/JVM/day5/Demo5 </span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method test1:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method test2:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method test3:()V</span></span><br><span class="line">        <span class="number">20</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line">        <span class="number">23</span>: returnCopy</span><br></pre></td></tr></table></figure>

<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li>
<li>终方法（ﬁnal），私有方法（private），构造方法都是由 <strong>invokespecial</strong> 指令来调用，属于静态绑定，因为通过类就可以确定</li>
<li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，因为不知道是执行父的方法还是子的方法<ul>
<li>即支持多态成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li>
</ul>
</li>
<li>补充：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/651630">https://developer.aliyun.com/article/651630</a></li>
<li><a target="_blank" rel="noopener" href="https://www.csdn.net/tags/MtTaIgwsNDMxMTAxLWJsb2cO0O0O.html">https://www.csdn.net/tags/MtTaIgwsNDMxMTAxLWJsb2cO0O0O.html</a></li>
</ul>
<h3 id="5）多态原理"><a href="#5）多态原理" class="headerlink" title="5）多态原理"></a>5）多态原理</h3><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong>，vtable存储了这些普通成员方法的具体地址（父类方法的地址或子类重写方法的地址）</li>
<li>查询vtable找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h3 id="6）异常原理"><a href="#6）异常原理" class="headerlink" title="6）异常原理"></a>6）异常原理</h3><h4 id="①单个catch"><a href="#①单个catch" class="headerlink" title="①单个catch"></a>①单个catch</h4><p>try-catch：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			i = <span class="number">10</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			i = <span class="number">20</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">12</span></span><br><span class="line">        <span class="number">8</span>: astore_2</span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_1</span><br><span class="line">       <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">     <span class="comment">//多出来一个异常表</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/ExceptionCopy</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（就是Exception e中的e）</li>
</ul>
<h4 id="②多个single-catch"><a href="#②多个single-catch" class="headerlink" title="②多个single-catch"></a>②多个single-catch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			i = <span class="number">10</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">			i = <span class="number">20</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			i = <span class="number">30</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">19</span></span><br><span class="line">        <span class="number">8</span>: astore_2			<span class="comment">//将捕获到的e存入slot 2</span></span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_1</span><br><span class="line">       <span class="number">12</span>: goto          <span class="number">19</span></span><br><span class="line">       <span class="number">15</span>: astore_2			<span class="comment">//将捕获到的e存入slot 2</span></span><br><span class="line">       <span class="number">16</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">18</span>: istore_1</span><br><span class="line">       <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/ArithmeticException</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">15</span>   Class java/lang/ExceptionCopy</span><br><span class="line">     LineNumberTable: ...</span><br><span class="line"> 	 LocalVariableTable: </span><br><span class="line">		Start  Length 	 Slot 	 Name</span><br><span class="line">            <span class="number">9</span>		<span class="number">3</span>		<span class="number">2</span>		e</span><br><span class="line">           <span class="number">16</span> 		<span class="number">3</span> 		<span class="number">2</span> 		e</span><br><span class="line">           <span class="number">23</span> 		<span class="number">3</span> 		<span class="number">2</span>		e</span><br><span class="line">       		<span class="number">0</span>	   <span class="number">27</span>		<span class="number">0</span>	 args</span><br><span class="line">           	<span class="number">2</span> 	   <span class="number">25</span>		<span class="number">1</span>		i	</span><br></pre></td></tr></table></figure>

<ul>
<li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong>，捕获到的e存入其中</li>
</ul>
<h4 id="③finally"><a href="#③finally" class="headerlink" title="③finally"></a>③finally</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			i = <span class="number">10</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			i = <span class="number">20</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			i = <span class="number">30</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//try块</span></span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="comment">//try块执行完后，会执行finally    </span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">7</span>: istore_1</span><br><span class="line">        <span class="number">8</span>: goto          <span class="number">27</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//catch块     </span></span><br><span class="line">       <span class="number">11</span>: astore_2 <span class="comment">//异常信息放入局部变量表的2号槽位</span></span><br><span class="line">       <span class="number">12</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">14</span>: istore_1</span><br><span class="line">       <span class="comment">//catch块执行完后，会执行finally        </span></span><br><span class="line">       <span class="number">15</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">17</span>: istore_1</span><br><span class="line">       <span class="number">18</span>: goto          <span class="number">27</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span></span><br><span class="line">       <span class="number">21</span>: astore_3</span><br><span class="line">       <span class="number">22</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">24</span>: istore_1</span><br><span class="line">       <span class="number">25</span>: aload_3</span><br><span class="line">       <span class="number">26</span>: athrow  <span class="comment">//抛出异常</span></span><br><span class="line">       <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">11</span>   Class java/lang/Exception</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">21</span>   any</span><br><span class="line">           <span class="number">11</span>    <span class="number">15</span>    <span class="number">21</span>   any </span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p>
<ul>
<li>在catch块中也可能会抛出异常，抛出异常后进入any异常块</li>
</ul>
</li>
<li><p>注意虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p>
</li>
</ul>
<h4 id="④finally中的return"><a href="#④finally中的return" class="headerlink" title="④finally中的return"></a>④finally中的return</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Demo3.test();</span><br><span class="line">        <span class="comment">//结果为20</span></span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			i = <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			i = <span class="number">20</span>;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: iload_0</span><br><span class="line">        <span class="number">4</span>: istore_1  <span class="comment">//暂存返回值10到slot 1</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0	<span class="comment">//暂存返回值20到slot 2</span></span><br><span class="line">        <span class="number">8</span>: iload_0	<span class="comment">//将返回值20从slot 2压入栈顶</span></span><br><span class="line">        <span class="number">9</span>: ireturn	<span class="comment">//ireturn会返回操作数栈顶的整型值20</span></span><br><span class="line">       <span class="comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span></span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0		<span class="comment">//暂存返回值20到slot 2</span></span><br><span class="line">       <span class="number">14</span>: iload_0		<span class="comment">//将返回值20从slot 2压入栈顶</span></span><br><span class="line">       <span class="number">15</span>: ireturn	<span class="comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">0</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li>
<li>字节码中第 2-4，暂存返回值</li>
<li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong><ul>
<li>所以<strong>不要在finally中进行返回操作</strong></li>
</ul>
</li>
</ul>
<h4 id="⑤被吞掉的异常"><a href="#⑤被吞掉的异常" class="headerlink" title="⑤被吞掉的异常"></a>⑤被吞掉的异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Demo3.test();</span><br><span class="line">      <span class="comment">//最终结果为20</span></span><br><span class="line">      System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         i = <span class="number">10</span>;</span><br><span class="line">         <span class="comment">//这里应该会抛出异常</span></span><br><span class="line">         i = i/<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         i = <span class="number">20</span>;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>会发现打印结果为20，并未抛出异常，而时return了20</li>
</ul>
<h4 id="⑥finally不带return"><a href="#⑥finally不带return" class="headerlink" title="⑥finally不带return"></a>⑥finally不带return</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Demo4.test();</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			i = <span class="number">20</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0 <span class="comment">//赋值给i 10</span></span><br><span class="line">        <span class="number">3</span>: iload_0	<span class="comment">//加载到操作数栈顶</span></span><br><span class="line">        <span class="number">4</span>: istore_1 <span class="comment">//加载到局部变量表的1号位置</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0 <span class="comment">//赋值给i 20</span></span><br><span class="line">        <span class="number">8</span>: iload_1 <span class="comment">//加载局部变量表1号位置的数10到操作数栈</span></span><br><span class="line">        <span class="number">9</span>: ireturn <span class="comment">//返回操作数栈顶元素 10</span></span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: aload_2 <span class="comment">//加载异常</span></span><br><span class="line">       <span class="number">15</span>: athrow <span class="comment">//抛出异常</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line">     LineNumberTable: ... </span><br><span class="line">         LocalVariableTable: <span class="comment">//可以看到局部变量表中没有slot 1</span></span><br><span class="line">			Start Length Slot Name	Signature</span><br><span class="line">				<span class="number">3</span> 	  <span class="number">13</span> 	<span class="number">0</span> 	 i 			I</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>return 中的数会先存到一个无名的slot，return的时候会load该slot，并return该数</li>
</ul>
<h3 id="7）synchronized代码块"><a href="#7）synchronized代码块" class="headerlink" title="7）synchronized代码块"></a>7）synchronized代码块</h3><p>test：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line">		<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_1</span><br><span class="line">        <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/nyima/JVM/day06/Lock</span></span><br><span class="line">        <span class="number">6</span>: dup <span class="comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span></span><br><span class="line">        <span class="number">7</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">10</span>: astore_2 <span class="comment">//剩下的一份放到局部变量表的2号位置</span></span><br><span class="line">       <span class="number">11</span>: aload_2 <span class="comment">//加载到操作数栈</span></span><br><span class="line">       <span class="number">12</span>: dup <span class="comment">//复制一份，放到操作数栈，用于加锁时消耗</span></span><br><span class="line">       <span class="number">13</span>: astore_3 <span class="comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span></span><br><span class="line">       <span class="number">14</span>: monitorenter <span class="comment">//加锁</span></span><br><span class="line">       <span class="comment">//锁住后代码块中的操作    </span></span><br><span class="line">       <span class="number">15</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">18</span>: iload_1</span><br><span class="line">       <span class="number">19</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">       <span class="comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span></span><br><span class="line">       <span class="number">22</span>: aload_3    </span><br><span class="line">       <span class="number">23</span>: monitorexit <span class="comment">//解锁</span></span><br><span class="line">       <span class="number">24</span>: goto          <span class="number">34</span></span><br><span class="line">       <span class="comment">//异常操作    </span></span><br><span class="line">       <span class="number">27</span>: astore        <span class="number">4</span></span><br><span class="line">       <span class="number">29</span>: aload_3</span><br><span class="line">       <span class="number">30</span>: monitorexit <span class="comment">//解锁</span></span><br><span class="line">       <span class="number">31</span>: aload         <span class="number">4</span></span><br><span class="line">       <span class="number">33</span>: athrow</span><br><span class="line">       <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line">     <span class="comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           <span class="number">15</span>    <span class="number">24</span>    <span class="number">27</span>   any</span><br><span class="line">           <span class="number">27</span>    <span class="number">31</span>    <span class="number">27</span>   any</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Lock lock &#x3D; new Lock()</p>
<ul>
<li>new的时候会复制一份引用，消耗掉复制用于构造函数，另一份引用存入slot 2中</li>
</ul>
</li>
<li><p>取出slot 2中的引用在复制一份，然后放入slot 3存储</p>
<ul>
<li>上锁操作的monitorenter消耗掉slot 2中的引用</li>
</ul>
</li>
<li><p>解锁操作取出slot 3中的引用，然后进行释放</p>
<ul>
<li>这里利用了Exception table</li>
<li>如果<strong>代码块中</strong>或<strong>解锁</strong>出现any异常，都会跳转到指定的行<ul>
<li>跳转到该行后会取出slot 3的引用，<strong>重复</strong>进行解锁操作</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>以上操作就保证了，当同步代码块中出现异常，或者解锁出现异常，一定能释放锁，不会占用</li>
<li>synchronized方法，即方法级别的synchronized不会再字节码中有所体现</li>
</ul>
</li>
</ul>
<h2 id="4-编译期处理（语法糖）"><a href="#4-编译期处理（语法糖）" class="headerlink" title="4.编译期处理（语法糖）"></a>4.编译期处理（语法糖）</h2><p>​	编译期处理就是所谓的<strong>语法糖</strong>，其实就是指 java 编译器把 .java 源码编译为 .class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担。</p>
<p>​	注意，以下代码都是.class的等价转化。</p>
<h3 id="1）默认构造器"><a href="#1）默认构造器" class="headerlink" title="1）默认构造器"></a>1）默认构造器</h3><p>当我们没有重写构造器的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy1</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过编译期优化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy1</span> &#123;</span><br><span class="line">   <span class="comment">// 这个无参构造器是java编译器帮我们加上的</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Candy1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2）自动拆装箱"><a href="#2）自动拆装箱" class="headerlink" title="2）自动拆装箱"></a>2）自动拆装箱</h3><p>基本类型和其包装类型的相互转换过程，称为拆装箱。在 JDK 5 以后，它们的转换可以在编译期自动完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy2</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy2</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 基本类型赋值给包装类型，称为装箱</span></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 包装类型赋值给基本类型，称谓拆箱</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>int-&gt;Integer：Integer.valueOf()</li>
<li>Integer-&gt;int：x.intValue();</li>
</ul>
<h3 id="3）泛型集合取值"><a href="#3）泛型集合取值" class="headerlink" title="3）泛型集合取值"></a>3）泛型集合取值</h3><h4 id="①泛型擦除"><a href="#①泛型擦除" class="headerlink" title="①泛型擦除"></a>①泛型擦除</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      list.add(<span class="number">10</span>);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/util/ArrayList</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">      <span class="number">11</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">      <span class="comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span></span><br><span class="line">      <span class="number">14</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line"></span><br><span class="line">      <span class="number">19</span>: pop</span><br><span class="line">      <span class="number">20</span>: aload_1</span><br><span class="line">      <span class="number">21</span>: iconst_0</span><br><span class="line">      <span class="comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span></span><br><span class="line">      <span class="number">22</span>: invokeinterface #<span class="number">6</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span></span><br><span class="line">	  <span class="comment">//这里进行了类型转换，将Object转换成了Integer</span></span><br><span class="line">      <span class="number">27</span>: checkcast     #<span class="number">7</span>                  <span class="comment">// class java/lang/Integer</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      <span class="number">31</span>: returnCopy</span><br></pre></td></tr></table></figure>

<p>所以调用get函数取值时，实际上有一个类型转换的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> (Integer) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (Integer) list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型擦除其实就是在字节码层面向集合add或get的时候，集合中的对象都会被当做object<ul>
<li>add前会<strong>擦除泛型</strong>，调用add(Objcet o)</li>
<li>get实际上是get(Object o) ，然后再进行<strong>类型转换</strong></li>
</ul>
</li>
</ul>
<h4 id="②可变参数"><a href="#②可变参数" class="headerlink" title="②可变参数"></a>②可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">      <span class="comment">//将args赋值给arr，可以看出String...实际就是String[] </span></span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);<span class="number">4</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> Demo4 &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      foo(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<ul>
<li>如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</li>
</ul>
</li>
</ul>
<h3 id="4）foreach"><a href="#4）foreach" class="headerlink" title="4）foreach"></a>4）foreach</h3><p>原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//数组赋初值的简化写法也是一种语法糖。</span></span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x : arr) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会帮我们转换为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Demo5 &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[i];</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是集合使用foreach：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Demo5 &#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">//获得该集合的迭代器</span></span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">         <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5）switch字符串"><a href="#5）switch字符串" class="headerlink" title="5）switch字符串"></a>5）switch字符串</h3><p>原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;world&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在编译器中执行的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Demo6</span><span class="params">()</span> &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//通过字符串的hashCode+value来判断是否匹配</span></span><br><span class="line">      <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">         <span class="comment">//hello的hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">99162322</span> :</span><br><span class="line">            <span class="comment">//再次比较，因为字符串的hashCode有可能相等</span></span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">//world的hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">11331880</span> :</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//用第二个switch在进行输出判断</span></span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译期间，单个的 switch 被分为了两个</p>
<ul>
<li>第一个用来匹配字符串，并给 x 赋值<ul>
<li>字符串的匹配用到了字符串的 hashCode ，还用到了 equals 方法</li>
<li>使用 hashCode 是为了提高比较效率，使用 equals 是防止有 hashCode 相等的情况（如 BM 和 C .的hash值就是一样的）</li>
<li>在成功匹配后会得到一个x的值，通过该值来在第二个switch中完成对应操作</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
<h3 id="6）switch枚举"><a href="#6）switch枚举" class="headerlink" title="6）switch枚举"></a>6）switch枚举</h3><p>原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">SEX</span> <span class="variable">sex</span> <span class="operator">=</span> SEX.MALE;</span><br><span class="line">      <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">         <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SEX</span> &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器中执行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line">   <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span></span><br><span class="line"><span class="comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span></span><br><span class="line"><span class="comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span></span><br><span class="line"><span class="comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">$MAP</span> &#123;</span><br><span class="line">      <span class="comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span></span><br><span class="line">         map[SEX.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">SEX</span> <span class="variable">sex</span> <span class="operator">=</span> SEX.MALE;</span><br><span class="line">      <span class="comment">//将对应位置枚举元素的值赋给x，用于case操作</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> $MAP.map[sex.ordinal()];</span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SEX</span> &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>



<h3 id="7）枚举类"><a href="#7）枚举类" class="headerlink" title="7）枚举类"></a>7）枚举类</h3><p>原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SEX</span> &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sex</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Sex&gt; &#123;   </span><br><span class="line">   <span class="comment">//对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;       </span><br><span class="line">    	<span class="comment">//调用构造函数，传入枚举元素的值及ordinal</span></span><br><span class="line">    	MALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> <span class="title class_">Sex</span>[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> 	</span><br><span class="line">   <span class="comment">//调用父类中的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sex</span><span class="params">(String name, <span class="type">int</span> ordinal)</span> &#123;     </span><br><span class="line">        <span class="built_in">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title function_">valueOf</span><span class="params">(String name)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举类其实一个也是一个类，但是不同于普通类，其实例对象的数量是固定的，枚举类中的每一个定义都是一个实例对象</li>
<li>枚举类的static方法在初始化的时候会new这些定义的变量并且分配他们<strong>枚举类编号ordinal</strong></li>
<li>枚举类的构造方法是private，这也保证了不能通过构造方法的方式来修改枚举类的信息</li>
<li>枚举类有两个方法<ul>
<li>values()，克隆了枚举实例数组并返回</li>
<li>valueOf(String name)：根据枚举类的字符串名称来得到对应的枚举实例</li>
</ul>
</li>
<li>相关：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-enum.html">https://www.runoob.com/java/java-enum.html</a></li>
</ul>
<h3 id="8）try-with-resource"><a href="#8）try-with-resource" class="headerlink" title="8）try with resource"></a>8）try with resource</h3><p>DK 7 开始新增了对需要关闭的资源处理的特殊语法，‘try-with-resources’</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源变量 = 创建资源对象) &#123;</span><br><span class="line">	</span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口</p>
<p>都实现了 AutoCloseable ，使用 try-with- resources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy9</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\1.txt&quot;</span>))&#123;	<span class="comment">//这里new了一个FIS流</span></span><br><span class="line">			System.out.println(is); </span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">			e.printStackTrace(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy9</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\1.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//....................以下为添加的代码...................................</span></span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(is); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e1) &#123; </span><br><span class="line">                <span class="comment">// t 是我们代码出现的异常 </span></span><br><span class="line">                t = e1; </span><br><span class="line">                <span class="keyword">throw</span> e1; </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 判断了资源不为空 </span></span><br><span class="line">                <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123; </span><br><span class="line">                    <span class="comment">// 如果我们代码有异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123; </span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            is.close(); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e2) &#123; </span><br><span class="line">                            <span class="comment">// 如果 close 出现异常，作为被压制异常添加</span></span><br><span class="line">                            t.addSuppressed(e2); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                        <span class="comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e </span></span><br><span class="line">                        is.close(); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//....................以上为添加的代码...................................</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要设计一个 addSuppressed(Throwable e) （添加被压制异常）的方法呢？<ul>
<li>是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常：如close时抛出异常）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		<span class="keyword">try</span> (<span class="type">MyResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyResource</span>()) &#123; </span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>; </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">			e.printStackTrace(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyResource</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;close 异常&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>本例中先会产生一个int i &#x3D; 1&#x2F;0导致的Exception e，然后再close的时候再产生一个new Exception(“close 异常”)</li>
</ul>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero <span class="comment">//1.第一个异常</span></span><br><span class="line">	at test.Test6.main(Test6.java:<span class="number">7</span>) </span><br><span class="line">	Suppressed: java.lang.Exception: close 异常 </span><br><span class="line">		at test.MyResource.close(Test6.java:<span class="number">18</span>) <span class="comment">//第二个关闭资源时的异常</span></span><br><span class="line">		at test.Test6.main(Test6.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到两个异常都没有丢失</li>
</ul>
<h3 id="9）方法重写时的桥接方法"><a href="#9）方法重写时的桥接方法" class="headerlink" title="9）方法重写时的桥接方法"></a>9）方法重写时的桥接方法</h3><p>我们都知道，方法重写时对返回值分两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> Number <span class="title function_">m</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; </span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 	</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">m</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意Number是Integer的父类</li>
</ul>
<p>对于子类，java 编译器会做如下处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">m</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此方法才是真正重写了父类 public Number m() 方法 </span></span><br><span class="line">	<span class="keyword">public</span> synthetic bridge Number <span class="title function_">m</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="comment">// 调用 public Integer m() </span></span><br><span class="line">		<span class="keyword">return</span> m(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JVM生成了合成桥接方法，在其内部调用<code>public Integer m() &#123; &#125;</code>，因为Integer是Number的子类，所以这也是符合要求的</li>
<li>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以<ul>
<li>用下面反射代码来验证：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Method m : B.class.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="10）匿名内部类"><a href="#10）匿名内部类" class="headerlink" title="10）匿名内部类"></a>10）匿名内部类</h3><h4 id="①普通情况"><a href="#①普通情况" class="headerlink" title="①普通情况"></a>①普通情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy10</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>转换后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy10</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candy10$1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个额外的类，实现了 Runnable 接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Candy10$1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②传入final-参数"><a href="#②传入final-参数" class="headerlink" title="②传入final 参数"></a>②传入final 参数</h4><p>引用局部变量的匿名内部类，源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123; <span class="comment">//必须要传入final变量</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; </span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; 	</span><br><span class="line">				System.out.println(<span class="string">&quot;ok:&quot;</span> + x); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Candy11$1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">	<span class="type">int</span> val$x; <span class="comment">//传递进的final参数作为了成员变量</span></span><br><span class="line">	Candy11$<span class="number">1</span>(<span class="type">int</span> x) &#123; </span><br><span class="line">		<span class="built_in">this</span>.val$x = x; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="built_in">this</span>.val$x); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Candy11</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123; </span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candy11$1</span>(x); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：<ul>
<li>因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 值后，如果不是 final 声明的 x 值发生了改变，匿名内部类则值不一致。</li>
<li>即final保证了匿名内部类中的成员变量x的值，和外面的是一样的</li>
</ul>
</li>
</ul>
<h2 id="5-类加载阶段"><a href="#5-类加载阶段" class="headerlink" title="5.类加载阶段"></a>5.类加载阶段</h2><h3 id="1）加载"><a href="#1）加载" class="headerlink" title="1）加载"></a>1）加载</h3><ul>
<li>将类的字节码（即.class文件）载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表：多态</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，<strong>先加载父类</strong></li>
<li>加载和链接可能是<strong>交替运行</strong>的</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/06/LDsHQm1ibvoWceZ.png" alt="image-20220706181132259"></p>
<ul>
<li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>java_mirror（即我们java代码中的<strong>String.class</strong>等）则是保存在<strong>堆内存</strong>中</li>
<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>instanceKlass、java_mirror（如String.class）、对象三者间的区别<ul>
<li>instanceKlass具体描述了一个类的所有信息，是C++描述的</li>
<li>_java_mirror（如String.class）相当于一个桥梁，InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址。在java程序中我们想知道类的相关信息，可以通过java_mirror（如String.class）来找到InstanceKlass并且以java的方式获得类中的信息</li>
<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>
</ul>
</li>
</ul>
<h3 id="2）链接"><a href="#2）链接" class="headerlink" title="2）链接"></a>2）链接</h3><h4 id="①验证"><a href="#①验证" class="headerlink" title="①验证"></a>①验证</h4><ul>
<li>验证类是否符合 JVM规范，安全性检查</li>
</ul>
<p>根据 JVM规范，<strong>类文件结构</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">u4 			 magic  <span class="comment">//魔数 ca fe ba be，u4代表占4个字节</span></span><br><span class="line">u2       minor_version;    </span><br><span class="line">u2       major_version;   </span><br><span class="line">u2       constant_pool_count;    </span><br><span class="line">cp_info     constant_pool[constant_pool_count-<span class="number">1</span>];    </span><br><span class="line">u2       access_flags;    </span><br><span class="line">u2       this_class;    </span><br><span class="line">u2       super_class;   </span><br><span class="line">u2       interfaces_count;    </span><br><span class="line">u2       interfaces[interfaces_count];   </span><br><span class="line">u2       fields_count;    field_info   fields[fields_count];   </span><br><span class="line">u2       methods_count;    method_info   methods[methods_count];   </span><br><span class="line">u2       attributes_count;    attribute_info attributes[attributes_count];</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到.class文件首先就是magic魔术，并且是ca fe ba be才是正确的java的.class文件<ul>
<li>在链接中的验证，就会验证加载的.class是否满足JVM的规范</li>
</ul>
</li>
</ul>
<h4 id="②准备"><a href="#②准备" class="headerlink" title="②准备"></a>②准备</h4><p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了<ul>
<li>instanceKlass在方法区，_java_mirror在heap中，</li>
</ul>
</li>
<li>static变量在分配空间和赋值是在两个阶段完成的：一般来说，分配空间在准备阶段完成，赋值在初始化阶段完成<ul>
<li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong><ul>
<li>如<code>static final String &quot;hello&quot;</code>，<code> static final int 1</code>，这样的常量在编译阶段就能够确定了</li>
<li>如<code>static final Integer 1</code>就不能在编译阶段确定，因为还涉及到<strong>自动装箱</strong>，只能在初始化阶段完成</li>
</ul>
</li>
<li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong><ul>
<li>如<code>static final Object = new Object()；</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load8</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a; <span class="comment">//加载阶段分配空间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//加载阶段分配空间，初始化阶段赋值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">//final常量，编译阶段就把值确定了，准备期间就已经赋完值了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">string</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;he1lo&quot;</span>; <span class="comment">//final常量，编译阶段就把值确定了，准备期间就已经赋完值了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> 0<span class="type">bject</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//final的引用类型，赋值在初始化阶段完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="③解析"><a href="#③解析" class="headerlink" title="③解析"></a>③解析</h4><p><strong>解析的含义</strong></p>
<p>将常量池中的<strong>符号引用</strong>解析为<strong>直接引用</strong></p>
<ul>
<li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">      <span class="comment">//1.只加载不解析</span></span><br><span class="line">      <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Demo1.class.getClassLoader();</span><br><span class="line">      Class&lt;?&gt; c = loader.loadClass(<span class="string">&quot;com.nyima.JVM.day8.C&quot;</span>);</span><br><span class="line">      	</span><br><span class="line">      <span class="comment">//2.加载、链接（验证、准备、解析）、初始化都会执行</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//用于阻塞主线程</span></span><br><span class="line">      System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">   <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ClassLoader loader &#x3D; Demo1.class.getClassLoader();<br>Class&lt;?&gt; c &#x3D; loader.loadClass(“com.nyima.JVM.day8.C”);</li>
<li>通过类加载器加载，不会解析</li>
<li>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</li>
<li>new C();<ul>
<li>加载、链接（验证、准备、解析）、初始化都会执行</li>
</ul>
</li>
</ul>
<h3 id="3）初始化"><a href="#3）初始化" class="headerlink" title="3）初始化"></a>3）初始化</h3><h4 id="①基本概念"><a href="#①基本概念" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，静态代码块会执行，虚拟机会保证这个类的『构造方法』的<strong>线程安全</strong></p>
<ul>
<li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li>
</ul>
<p><strong>注意</strong>：</p>
<p>​		编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p>
<h4 id="②发生时机"><a href="#②发生时机" class="headerlink" title="②发生时机"></a>②发生时机</h4><p>类的初始化的<strong>懒惰</strong>的，以下情况会初始化：</p>
<ul>
<li><p>main 方法所在的类，总会被首先初始化</p>
</li>
<li><p>首次访问这个类的静态变量或静态方法时</p>
<ul>
<li><code>static int a = 6;</code></li>
</ul>
</li>
<li><p>子类初始化，如果父类还没初始化，会引发</p>
<ul>
<li>执行A，那么B也会初始化</li>
</ul>
</li>
<li><p>子类访问父类的静态变量，只会触发父类的初始化</p>
<ul>
<li><code>System.out.println(B.a);</code></li>
</ul>
</li>
<li><p>Class.forName，默认第二个参数是true，也就是要初始化</p>
</li>
<li><p>new 会导致初始化</p>
<ul>
<li>new B()；</li>
</ul>
</li>
</ul>
<p>以下情况不会初始化：</p>
<ul>
<li>访问类的 static ﬁnal 静态常量（基本类型和字符串）<ul>
<li>如<code>static final String &quot;hello&quot;</code>，<code> static final Integer 1</code>，在编译器已经确定，准备阶段已经赋值</li>
<li>如<code>static final Integer 1</code>就不能在编译阶段确定，因为还涉及到<strong>自动装箱</strong>，只能在初始化阶段完成</li>
</ul>
</li>
<li>类对象.class 不会触发初始化<ul>
<li><strong>sout（A.class）</strong>，但A中的静态代码块不会执行，_java_mirror在加载阶段就生成好了</li>
</ul>
</li>
<li>创建该类对象的数组<ul>
<li><code>System.out.println(new B[0]);</code></li>
</ul>
</li>
<li>类加载器的.loadClass方法<ul>
<li>只会进行加载阶段</li>
</ul>
</li>
<li>Class.forName的参数2为false时<ul>
<li>参数2代表是否需要初始化，默认为true，false是不要初始化</li>
</ul>
</li>
</ul>
<p><strong>验证类是否被初始化，可以看该类的静态代码块是否被执行</strong></p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不会初始化的情况：</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.静态常量不会触发初始化</span></span><br><span class="line">        System.out.println(B.b);</span><br><span class="line">        <span class="comment">// 2.类对象.class不会触发初始化</span></span><br><span class="line">        System.out.println(B.class);</span><br><span class="line">        <span class="comment">// 3.创建该类的数组不会触发初始化</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">B</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 4.不会初始化类B，但会加载B、A\</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c1</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        c1.loadClass(<span class="string">&quot;testAll.load3.B&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.不会初始化类B，但会加载B、A</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c2</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Class.forName(<span class="string">&quot;testAll.load3.B&quot;</span>, <span class="literal">false</span>, c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.首次访问这个类的静态变量或静态方法时</span></span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">        <span class="comment">// 2.子类初始化，如果父类还没初始化，会引岗</span></span><br><span class="line">        System.out.println(B.c);</span><br><span class="line">        <span class="comment">// 3.子类访问父类静态变量，只触发父类初始化</span></span><br><span class="line">        System.out.println(B.a);</span><br><span class="line">        <span class="comment">// 4.会初始化类B，并先初始化类A</span></span><br><span class="line">        Class.forName(<span class="string">&quot;testAll.B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out. println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4）application"><a href="#4）application" class="headerlink" title="4）application"></a>4）application</h3><h4 id="①test"><a href="#①test" class="headerlink" title="①test"></a>①test</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(E.a);<span class="comment">//不会初始化</span></span><br><span class="line">        System.out.println(E.b);<span class="comment">//不会初始化</span></span><br><span class="line">        <span class="comment">// 会导致 E 类初始化，因为 Integer 是包装类</span></span><br><span class="line">        <span class="comment">//涉及到自动装箱，编译器无法确定，需要到初始化阶段才行</span></span><br><span class="line">        System.out.println(E.c);<span class="comment">//会初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;E cinit&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②懒惰初始化单例模式"><a href="#②懒惰初始化单例模式" class="headerlink" title="②懒惰初始化单例模式"></a>②懒惰初始化单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON= <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lazyHolder init...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过单例类的内部类来new单例对象</li>
<li>线程安全问题是可以保证的，因为<strong>类加载器可以保证构造方法的线程安全</strong><ul>
<li>调用getInstance方法才会使用到LazyHolder这个类</li>
<li>然后该类才会初始化SINGLETON对象，类加载器保证了构造方法的线程安全</li>
<li>如果只用到Singleton是不会初始化的</li>
</ul>
</li>
</ul>
<h2 id="6-类加载器"><a href="#6-类加载器" class="headerlink" title="6.类加载器"></a>6.类加载器</h2><h3 id="1）基本概念"><a href="#1）基本概念" class="headerlink" title="1）基本概念"></a>1）基本概念</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，<strong>只要加载它们的类加载器不同，那这两个类就必定不相等</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td>
<td>上级为Bootstrap，显示为nul</td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody></table>
<ul>
<li><p>Extension ClassLoader(拓展类加载器)在getParent的时候会打印一个null，因为Bootstrap ClassLoader（启动类加载器）并不是java代码写的，是c++代码写的，不允许java代码访问</p>
</li>
<li><p>可通过在控制台输入指令，使得类被启动类加器加载</p>
</li>
<li><p>如果classpath和JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
</li>
</ul>
<h3 id="2）双亲委派模式"><a href="#2）双亲委派模式" class="headerlink" title="2）双亲委派模式"></a>2）双亲委派模式</h3><p>​				在加载一个类的时候，会从下往上查询看是和否有上级加载器加载过该类，如果加载过了，下级就不会再加载了。</p>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先查找该类是否已经被该类加载器加载过了（从该类加载器的缓存中查找）</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有被加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.如果父类是null，那么说明现在是扩展类加载器，父类因为是启动加载器（c++写的），所以是null</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//2.调用父类加载器的loadClass方法</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3.如果父类是启动加载器，那么就会执行该方法，因为parent是null</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">//捕获异常，但不做任何处理，继续执行下面代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果还是没有找到，先让拓展类加载器调用 findClass 方法去找到该类，如果还是没找到，就抛出异常</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="comment">//4.根据本类定义的方式去找，找不到会抛出异常回到上一级的catch中</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录时间</span></span><br><span class="line">            sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">            sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">            sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li>首先类加载器会在自己的缓存中寻找，如果没有找到，则会调用父类的loadClass方法：<code>parent.loadClass</code><ul>
<li>直到this是扩展类加载器，得到的parent就是null，那么就会执行findBootstrapClassOrNull方法</li>
<li>如果所有缓存中没找到（此时已经到启动类加载器了），就会根据该类加载器的规则来寻找<ul>
<li>如启动类加载器，就会从JAVA_HOME&#x2F;jre&#x2F;lib下找</li>
<li>如扩展类加载器，就会从JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext下找</li>
</ul>
</li>
</ul>
</li>
<li>如我们写的Stu类，最后就回被应用类加载器加载，因为会在classpath路径下找到</li>
</ul>
<ol>
<li><p><code>sun.misc.Launcher$AppClassLoader</code> &#x2F;&#x2F;1 处， 开始查看已加载的类，结果没有 </p>
</li>
<li><p><code>sun.misc.Launcher$AppClassLoader</code> &#x2F;&#x2F; 2 处，委派上级 sun.misc.Launcher$ExtClassLoader.loadClass()</p>
</li>
<li><p><code>sun.misc.Launcher$ExtClassLoader</code> &#x2F;&#x2F; 1 处，查看已加载的类，结果没有 </p>
</li>
<li><p><code>sun.misc.Launcher$ExtClassLoader</code> &#x2F;&#x2F; 3 处，没有上级了，则委派 BootstrapClassLoader 查找</p>
</li>
<li><p><code>BootstrapClassLoader</code> 是在 JAVA_HOME&#x2F;jre&#x2F;lib 下找 H 这个类，显然没有 </p>
</li>
<li><p><code>sun.misc.Launcher$ExtClassLoader</code> &#x2F;&#x2F; 4 处，调用自己的 findClass 方法，是在 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下找 H 这个类，显然没有，抛出异常，回到 sun.misc.Launcher$AppClassLoader 的 2 处</p>
</li>
<li><p>继续执行到 <code>sun.misc.Launcher$AppClassLoader</code> &#x2F;&#x2F; 4 处，调用它自己的 findClass 方法，在<br>classpath 下查找，找到了</p>
</li>
</ol>
<h3 id="3）线程上下文类加载器"><a href="#3）线程上下文类加载器" class="headerlink" title="3）线程上下文类加载器"></a>3）线程上下文类加载器</h3><p>我们在使用 JDBC 时，不写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>也是可以让 com.mysql.jdbc.Driver 正确加载的，你知道是怎么做的吗？</p>
<p>让我们追踪一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123; </span><br><span class="line">  <span class="comment">// 注册驱动的集合 </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化驱动 </span></span><br><span class="line">  <span class="keyword">static</span> &#123; </span><br><span class="line">    loadInitialDrivers(); <span class="comment">//在这里加载com.mysql.jdbc.Driver</span></span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>先不看别的，看看 <strong>DriverManager 的类加载器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(DriverManager.class.getClassLoader());</span><br></pre></td></tr></table></figure>

<p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME&#x2F;jre&#x2F;lib 下搜索类，但JAVA_HOME&#x2F;jre&#x2F;lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？</p>
<p>继续看 loadInitialDrivers() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span> &#123; </span><br><span class="line">  String drivers; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    drivers = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt; () &#123; </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">    drivers = <span class="literal">null</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1）使用 ServiceLoader 机制加载驱动，即 SPI </span></span><br><span class="line">  AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123; </span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">      ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); </span><br><span class="line">      Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); </span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(driversIterator.hasNext()) &#123; </span><br><span class="line">          driversIterator.next(); </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; <span class="keyword">catch</span>(Throwable t) &#123; </span><br><span class="line">        <span class="comment">// Do nothing </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">  println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2）使用 jdbc.drivers 定义的驱动名加载驱动 </span></span><br><span class="line">  <span class="keyword">if</span> (drivers == <span class="literal">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123; </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>); </span><br><span class="line">  println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length); </span><br><span class="line">  <span class="keyword">for</span> (String aDriver : driversList) &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver); </span><br><span class="line">      <span class="comment">// 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器 </span></span><br><span class="line">      Class.forName(aDriver, <span class="literal">true</span>, ClassLoader.getSystemClassLoader()); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">      println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		先看 2）发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此可以顺利完成类加载，破坏了双亲委派机制，直接让应用程序类加载器加载。</p>
<p>​		再看 1）它就是大名鼎鼎的 <strong>Service Provider Interface （SPI）</strong></p>
<p><img src="https://s2.loli.net/2022/07/07/ReT2BzMlSNFCv6P.png" alt="image-20220706225434542"></p>
<p>约定如下：</p>
<p>​	在 jar 包的 META-INF&#x2F;services 包下，以<strong>接口全限定名为文件名</strong>，<strong>文件内容是实现类名称</strong>	</p>
<p>这样就可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class); </span><br><span class="line">Iterator&lt;接口类型&gt; iter = allImpls.iterator(); </span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123; </span><br><span class="line">  iter.next(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SPI通过接口来得到实现类</strong>，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：</p>
<ul>
<li>JDBC</li>
<li>Servlet 初始化器</li>
<li>Spring 容器</li>
<li>Dubbo（对 SPI 进行了扩展）</li>
</ul>
<p>接着看 ServiceLoader.load 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123; </span><br><span class="line">  <span class="comment">// 获取线程上下文类加载器 </span></span><br><span class="line">  <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader(); </span><br><span class="line">  <span class="keyword">return</span> ServiceLoader.load(service, cl); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类LazyIterator 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (!hasNextService()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(); </span><br><span class="line">  <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName; </span><br><span class="line">  nextName = <span class="literal">null</span>; </span><br><span class="line">  Class&lt;?&gt; c = <span class="literal">null</span>; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// loader即线程上下文类加载器</span></span><br><span class="line">    c = Class.forName(cn, <span class="literal">false</span>, loader); </span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123; </span><br><span class="line">    fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123; </span><br><span class="line">    fail(service, <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not a subtype&quot;</span>); </span><br><span class="line">  &#125;<span class="keyword">try</span> &#123;</span><br><span class="line">    Sp = service.cast(c.newInstance()); </span><br><span class="line">    providers.put(cn, p); </span><br><span class="line">    <span class="keyword">return</span> p; </span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable x) &#123; </span><br><span class="line">    fail(service, <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>, x); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(); </span><br><span class="line">  <span class="comment">// This cannot happen </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>SPI内部首先获得了<strong>线程上下文加载器</strong>（默认是应用加载器），然后通过<strong>线程上下文加载器</strong>来加载对应的类，具体也是使用了forName的方式来加载类</li>
<li>DriverManager的加载器是启动加载器，但是其内部应用了SPI，所以内部使用的是<strong>线程上下文加载器</strong>，也就是默认的<strong>应用加载器</strong>，来加载<code>com.mysql.jdbc.Driver</code>，打破了双亲委派机制</li>
</ul>
<h3 id="4）自定义类加载器"><a href="#4）自定义类加载器" class="headerlink" title="4）自定义类加载器"></a>4）自定义类加载器</h3><h4 id="①使用场景"><a href="#①使用场景" class="headerlink" title="①使用场景"></a>①使用场景</h4><ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<h4 id="②步骤"><a href="#②步骤" class="headerlink" title="②步骤"></a>②步骤</h4><ul>
<li>继承 ClassLoader 父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法，也就是在什么路径中去找</li>
<li>不是重写 loadClass 方法，否则不会走双亲委派机制</li>
<li>读取类文件的字节码</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ul>
<h4 id="③example"><a href="#③example" class="headerlink" title="③example"></a>③example</h4><p>自定义加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// name_就是类名称</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findclass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;e:\\myclasspath\\&quot;</span> + name + <span class="string">&quot;.class&quot;</span>;<span class="comment">//这个路径下的class都会走自定义</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            Files.copy(Paths.get(path), os);</span><br><span class="line">            <span class="comment">//得到字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = os.toByteArray();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//byte[] -&gt; *.class</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;类文件未到&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load7</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyclassLoader</span>();</span><br><span class="line">            Class&lt;?&gt; c1 = classLoader.loadClass(<span class="string">&quot;MapImpl1&quot;</span>);</span><br><span class="line">            Class&lt;?&gt; c2 = classLoader. loadClass(<span class="string">&quot;MapImp1&quot;</span>);</span><br><span class="line">            <span class="comment">//true,无论加载同一个.class多少次，得到的_java_mirror都是一样的</span></span><br><span class="line">            System.out.println(c1 == c2);</span><br><span class="line"></span><br><span class="line">            <span class="type">MyclassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">            Class&lt;?&gt; c3 = classLoader2.loadClass(<span class="string">&quot;HapImpl1&quot;</span>);</span><br><span class="line">            System.out.println(c1 == c3);<span class="comment">//false,两者不是同一个类加载器加载的</span></span><br><span class="line">            c1.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="④破坏双亲委派模式"><a href="#④破坏双亲委派模式" class="headerlink" title="④破坏双亲委派模式"></a>④破坏双亲委派模式</h4><ul>
<li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul>
<li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li>
</ul>
</li>
<li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul>
<li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li>
</ul>
</li>
<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul>
<li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li>
</ul>
</li>
</ul>
<p>例：tomcat打破双亲委派机制</p>
<ul>
<li>tomcat本身也是一个java的应用，也会用到一些jar包A 2.5，而部署的应用也要用到jar包 3.5，这样两个jar的版本就不同，但是仍然是同名，如果走双亲委派，让同一个类加载器加载，就会出现jar包覆盖而报错</li>
<li>如果部署了多个应用，如两个应用中分别有同名的两个servlet，那么在加载了第一个后，第二个加载的时候就会去加载缓存中查，查到了直接返回，这是不可接受的，所以需要做到web应用间的隔离</li>
<li>多个web应用可能会用到同样的jar包，如spring3.5，那么这部分公共内容应该公用，以免多次加载</li>
<li>详见：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1890187">https://cloud.tencent.com/developer/article/1890187</a></li>
</ul>
<h2 id="7-运行期优化"><a href="#7-运行期优化" class="headerlink" title="7.运行期优化"></a>7.运行期优化</h2><h3 id="1）分层编译"><a href="#1）分层编译" class="headerlink" title="1）分层编译"></a>1）分层编译</h3><p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>
<p>即时编译器（JIT）与解释器的区别</p>
<ul>
<li>解释器<ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>​	 对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码。</p>
<h3 id="2）逃逸分析"><a href="#2）逃逸分析" class="headerlink" title="2）逃逸分析"></a>2）逃逸分析</h3><p>先来看个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T01_RunTime_EscapeAnalysis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 循环创建对象</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\n&quot;</span>, i, (end - start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时间片段如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>	<span class="number">86861</span></span><br><span class="line"><span class="number">1</span>	<span class="number">89557</span></span><br><span class="line"><span class="number">2</span>	<span class="number">68333</span></span><br><span class="line"><span class="number">3</span>	<span class="number">64021</span></span><br><span class="line"><span class="number">4</span>	<span class="number">67292</span></span><br><span class="line"><span class="number">5</span>	<span class="number">63446</span></span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"><span class="number">67</span>	<span class="number">22369</span></span><br><span class="line"><span class="number">68</span>	<span class="number">44501</span></span><br><span class="line"><span class="number">69</span>	<span class="number">30545</span></span><br><span class="line"><span class="number">70</span>	<span class="number">17963</span></span><br><span class="line"><span class="number">71</span>	<span class="number">21750</span></span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"><span class="number">195</span>	<span class="number">13104</span></span><br><span class="line"><span class="number">196</span>	<span class="number">14453</span></span><br><span class="line"><span class="number">197</span>	<span class="number">23107</span></span><br><span class="line"><span class="number">198</span>	<span class="number">13574</span></span><br><span class="line"><span class="number">199</span>	<span class="number">14051</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先第一次优化是针对热点代码的优化，由于<code>new Object(); // 循环创建对象</code>执行频率较高，所以JVM针对其做了优化，存储在了code cache中，在后面要执行相同的代码的时候不再解释，而是使用<strong>即时编译器</strong>直接执行</li>
<li>第二次用到了<strong>逃逸分析</strong>的策略，因为JVM分析出该对象只是new出来了，在整个环境中根本没有被使用，对象逃逸了，所以JVM后面就直接不再new对象了</li>
<li>可以使用 <code>-XX:-DoEscapeAnalysis</code> 关闭，默认打开</li>
</ul>
<h3 id="3）方法内联"><a href="#3）方法内联" class="headerlink" title="3）方法内联"></a>3）方法内联</h3><p>（Inlining）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> i * i; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure>

<p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>还能够进行常量折叠（constant folding）的优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure>

<p>test：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JIT2</span> &#123; </span><br><span class="line">  <span class="comment">// -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining （解锁隐藏参数）打印 inlining 信息 </span></span><br><span class="line">  <span class="comment">// -XX:CompileCommand=dontinline,*JIT2.square 禁止某个方法 inlining </span></span><br><span class="line">  <span class="comment">// -XX:+PrintCompilation 打印编译信息 </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123; </span><br><span class="line">      <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime(); </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123; </span><br><span class="line">        x = square(<span class="number">9</span>); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime(); </span><br><span class="line">      System.out.printf(<span class="string">&quot;%d\t%d\t%d\n&quot;</span>,i,x,(end - start)); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> i * i; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在执行的过程中，JVM发现square是hot spot代码，所以会针对其进行优化</p>
<ul>
<li><p>因为方法较简单，可以直接复制一份在调用处，这样 x &#x3D; 9*9</p>
<p>又因为这里的传参一直都是9，所以结果也一致，最后会直接使x&#x3D;81</p>
</li>
</ul>
</li>
</ul>
<h3 id="4）循环中的字段优化"><a href="#4）循环中的字段优化" class="headerlink" title="4）循环中的字段优化"></a>4）循环中的字段优化</h3><p>利用JMH观察，JMH 基准测试请参考： <a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a></p>
<p>创建 maven 工程，添加依赖如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>字段优化代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行期优化 —— 字段优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 热身，先热身再优化</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 5, time = 1)</span></span><br><span class="line"><span class="comment">// 5轮测试</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1)</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T03_RunTime_FieldOptimize</span> &#123;</span><br><span class="line"><span class="type">int</span>[] elements = randomInts(<span class="number">1_000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] randomInts(<span class="type">int</span> size) &#123;</span><br><span class="line">    <span class="type">ThreadLocalRandom</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line">    <span class="type">int</span>[] values = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        values[i] = random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Benchmark</span> <span class="comment">//要测试的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">        doSum(elements[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] local = <span class="built_in">this</span>.elements;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">        doSum(elements[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : elements) &#123;</span><br><span class="line">        doSum(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@CompilerControl(CompilerControl.Mode.INLINE)</span>  <span class="comment">// 控制调用方法时是不是要进行方法内联；允许内联</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSum</span><span class="params">(<span class="type">int</span> x)</span> &#123; sum += x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">    <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(T03_RunTime_FieldOptimize.class.getSimpleName())</span><br><span class="line">            .forks(<span class="number">1</span>)</span><br><span class="line">            .build();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>①test1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span> <span class="comment">//要测试的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">        doSum(elements[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在允许方法内联的情况下，这里会在生成一个本地局部变量，不再去堆中读取成员变量（可能在读取了多次成员变量后才会生成本地局部变量）</li>
</ul>
<p><strong>②test2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] local = <span class="built_in">this</span>.elements;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">        doSum(elements[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实际上就是手动添加了一个本地局部变量，只会去堆中读取一次成员变量</li>
</ul>
<p><strong>③test3</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : elements) &#123;</span><br><span class="line">        doSum(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>foreach针对集合就是iterate遍历，针对数组fori遍历，字节码其实适合test2一致的</li>
</ul>
<h3 id="5）反射优化"><a href="#5）反射优化" class="headerlink" title="5）反射优化"></a>5）反射优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect1</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Demo3.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;=<span class="number">16</span>; i++) &#123;</span><br><span class="line">         foo.invoke(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现的<ul>
<li>由于是native方法执行的，所以效率较低</li>
</ul>
</li>
</ul>
<p>invoke 方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span></span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">ma</span> <span class="operator">=</span> methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="literal">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireMethodAccessor会由 DelegatingMehodAccessorImpl 去调用 NativeMethodAccessorImpl<br>NativeMethodAccessorImpl 源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numInvocations;</span><br><span class="line">NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">    <span class="built_in">this</span>.method = var1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span></span><br><span class="line"><span class="comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">    <span class="keyword">if</span> (++<span class="built_in">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="built_in">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="type">MethodAccessorImpl</span> <span class="variable">var3</span> <span class="operator">=</span> (MethodAccessorImpl)(<span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>()).generateMethod(<span class="built_in">this</span>.method.getDeclaringClass(), <span class="built_in">this</span>.method.getName(), <span class="built_in">this</span>.method.getParameterTypes(), <span class="built_in">this</span>.method.getReturnType(), <span class="built_in">this</span>.method.getExceptionTypes(), <span class="built_in">this</span>.method.getModifiers());</span><br><span class="line">        <span class="built_in">this</span>.parent.setDelegate(var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> invoke0(<span class="built_in">this</span>.method, var1, var2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent = var1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title function_">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReflectionFactory.inflationThreshold()方法的返回值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inflationThreshold</span> <span class="operator">=</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一开始if条件不满足，就会调用本地方法 invoke0</p>
</li>
<li><p>随着 numInvocation 的增大，当它大于 ReflectionFactory.inflationThreshold 的值 16 时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率</p>
<ul>
<li>这时会从反射调用变为正常调用，即直接调用 Reflect1.foo()（因为该方法是静态方法，所以直接通过类调用）</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>最开始使用反射调用方法的时候，使用的方法执行器中的一个native方法的执行<ul>
<li>它有一个阈值，默认是15</li>
</ul>
</li>
<li>调用次数超过15后，说明这个方法调用是经常执行的，JVM就会在运行期间动态生成一段代码，运行期间通过这段代码正常调用对应的方法（从反射方法变成了直接调用）</li>
</ul>
<h1 id="四、内存模型JMM"><a href="#四、内存模型JMM" class="headerlink" title="四、内存模型JMM"></a>四、内存模型JMM</h1><p>详情见JUC：<a target="_blank" rel="noopener" href="https://f1ashades.github.io/2022/04/14/JUC/#more">https://f1ashades.github.io/2022/04/14/JUC/#more</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/14/JUC/" rel="prev" title="JUC并发">
      <i class="fa fa-chevron-left"></i> JUC并发
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/15/1redis%20-%20%E5%89%AF%E6%9C%AC/" rel="next" title="Redis相关">
      Redis相关 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">一、内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">1.程序计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E4%BD%9C%E7%94%A8"><span class="nav-text">1）作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E7%89%B9%E7%82%B9"><span class="nav-text">2）特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-text">2.虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%AE%9A%E4%B9%89"><span class="nav-text">1）定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%BC%94%E7%A4%BA"><span class="nav-text">2）演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%A0%88%E5%B8%A7"><span class="nav-text">3）栈帧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-text">①局部变量表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%93%8D%E4%BD%9C%E6%A0%88"><span class="nav-text">②操作栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">③动态链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-text">④方法返回地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E9%97%AE%E9%A2%98%E8%BE%A8%E6%9E%90"><span class="nav-text">4）问题辨析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="nav-text">5）线程运行诊断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">3.本地方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%A0%86"><span class="nav-text">4.堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%AE%9A%E4%B9%89-1"><span class="nav-text">1）定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E7%89%B9%E7%82%B9-1"><span class="nav-text">2）特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">3）堆内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD"><span class="nav-text">4）堆内存诊断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">5.方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">1）方法区内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">2）运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89StringTable%E4%B8%B2%E6%B1%A0"><span class="nav-text">3）StringTable串池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E7%A4%BA%E4%BE%8B"><span class="nav-text">①示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E6%8B%BC%E6%8E%A5"><span class="nav-text">②字符串变量拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A21-8intern%E6%96%B9%E6%B3%95"><span class="nav-text">③1.8intern方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A31-6intern%E6%96%B9%E6%B3%95"><span class="nav-text">④1.6intern方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4StringTable%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">⑤StringTable垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4StringTable%E8%B0%83%E4%BC%98"><span class="nav-text">⑤StringTable调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5Java-Integer%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-text">⑥Java Integer的缓存策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-text">6.直接内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="nav-text">1）基本功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-text">2）直接内存的管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">二、垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD"><span class="nav-text">1.回收对象判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-text">1）引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-text">2）可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-text">3）五种引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-text">①强引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88SoftReference%EF%BC%89"><span class="nav-text">②软引用（SoftReference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88WeakReference%EF%BC%89"><span class="nav-text">③弱引用（WeakReference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88PhantomReference%EF%BC%89"><span class="nav-text">④虚引用（PhantomReference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8%EF%BC%88FinalReference%EF%BC%89"><span class="nav-text">⑤终结器引用（FinalReference）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-text">2.垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="nav-text">1）标记-清除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="nav-text">2）标记整理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-text">3）复制算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="nav-text">3.分代回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3"><span class="nav-text">1）形象理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-text">2）具体流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">3）注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-JVM%E5%8F%82%E6%95%B0"><span class="nav-text">4.JVM参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">5.垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="nav-text">1）串行垃圾回收器（单线程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%EF%BC%88%E5%B9%B6%E8%A1%8C%EF%BC%89"><span class="nav-text">2）吞吐量优先（并行）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88%E5%B9%B6%E5%8F%91%EF%BC%89"><span class="nav-text">3）响应时间优先（并发）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89G1"><span class="nav-text">4）G1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0Young-Collection"><span class="nav-text">①Young Collection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1Young-Collection-CM%EF%BC%88concurrent-mark%EF%BC%89"><span class="nav-text">②Young Collection + CM（concurrent mark）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2Mixed-Collection"><span class="nav-text">③Mixed Collection</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Minor-GC%E5%92%8CFull-GC%E8%BE%A8%E6%9E%90"><span class="nav-text">5.Minor GC和Full GC辨析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Young-Collection-%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8"><span class="nav-text">6.Young Collection 跨代引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%87%8D%E6%A0%87%E8%AE%B0remark"><span class="nav-text">7.重标记remark</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-JDK-GC%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">8.JDK GC新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89JDK-8u20-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="nav-text">1）JDK 8u20 字符串去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89JDK-8u40-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="nav-text">2）JDK 8u40 并发标记类卸载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89JDK-8u60-%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">3）JDK 8u60 回收巨型对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-GC%E8%B0%83%E4%BC%98"><span class="nav-text">9.GC调优</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">三、类加载与字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%B1%BB%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C"><span class="nav-text">1.类从源码到运行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E7%BC%96%E8%AF%91%E6%9C%9F"><span class="nav-text">1）编译期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E8%BF%90%E8%A1%8C%E6%9C%9F"><span class="nav-text">2）运行期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-text">2.类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AD%94%E6%95%B0"><span class="nav-text">魔数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC"><span class="nav-text">版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">常量池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="nav-text">3.字节码指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">1）图解方法执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89a-%E9%97%AE%E9%A2%98"><span class="nav-text">2）a++问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="nav-text">①字节码详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1test"><span class="nav-text">②test</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">3）构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-cinit"><span class="nav-text">①静态构造方法 cinit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%9D%9E%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-init"><span class="nav-text">②非静态构造方法 init()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-text">4）方法调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86"><span class="nav-text">5）多态原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89%E5%BC%82%E5%B8%B8%E5%8E%9F%E7%90%86"><span class="nav-text">6）异常原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%8D%95%E4%B8%AAcatch"><span class="nav-text">①单个catch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%A4%9A%E4%B8%AAsingle-catch"><span class="nav-text">②多个single-catch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2finally"><span class="nav-text">③finally</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3finally%E4%B8%AD%E7%9A%84return"><span class="nav-text">④finally中的return</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E8%A2%AB%E5%90%9E%E6%8E%89%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-text">⑤被吞掉的异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5finally%E4%B8%8D%E5%B8%A6return"><span class="nav-text">⑥finally不带return</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%89synchronized%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">7）synchronized代码块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86%EF%BC%88%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%89"><span class="nav-text">4.编译期处理（语法糖）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">1）默认构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="nav-text">2）自动拆装箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC"><span class="nav-text">3）泛型集合取值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-text">①泛型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-text">②可变参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89foreach"><span class="nav-text">4）foreach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89switch%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5）switch字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89switch%E6%9E%9A%E4%B8%BE"><span class="nav-text">6）switch枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-text">7）枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%EF%BC%89try-with-resource"><span class="nav-text">8）try with resource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%EF%BC%89%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="nav-text">9）方法重写时的桥接方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">10）匿名内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E6%99%AE%E9%80%9A%E6%83%85%E5%86%B5"><span class="nav-text">①普通情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E4%BC%A0%E5%85%A5final-%E5%8F%82%E6%95%B0"><span class="nav-text">②传入final 参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="nav-text">5.类加载阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%8A%A0%E8%BD%BD"><span class="nav-text">1）加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E9%93%BE%E6%8E%A5"><span class="nav-text">2）链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E9%AA%8C%E8%AF%81"><span class="nav-text">①验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%87%86%E5%A4%87"><span class="nav-text">②准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E8%A7%A3%E6%9E%90"><span class="nav-text">③解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">3）初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA"><span class="nav-text">②发生时机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89application"><span class="nav-text">4）application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0test"><span class="nav-text">①test</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">②懒惰初始化单例模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">6.类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1）基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="nav-text">2）双亲委派模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">3）线程上下文类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">4）自定义类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">①使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%AD%A5%E9%AA%A4"><span class="nav-text">②步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2example"><span class="nav-text">③example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="nav-text">④破坏双亲委派模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="nav-text">7.运行期优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="nav-text">1）分层编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-text">2）逃逸分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="nav-text">3）方法内联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BC%98%E5%8C%96"><span class="nav-text">4）循环中的字段优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="nav-text">5）反射优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM"><span class="nav-text">四、内存模型JMM</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="f1ashades"
      src="/images/mine.jpg">
  <p class="site-author-name" itemprop="name">f1ashades</p>
  <div class="site-description" itemprop="description">once again I am a child</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">f1ashades</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">744k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">20:40</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
