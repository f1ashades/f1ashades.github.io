<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/source/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基本指令使用：基本数据类型和命令、SpringData封装 redis缓存：缓存更新、缓存穿透、缓存雪崩、缓存击穿 分布式缓存：redis持久化、redis主从、redis哨兵sentinel、redis分片集群 redis实践：键值设计（BigKey）、批处理（pipeline）、服务端优化（持久化、慢查询、内存划分、集群选择） redis原理： ​	redis底层数据结构：SDS、intSet">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis相关">
<meta property="og:url" content="http://example.com/2022/04/15/1redis%20-%20%E5%89%AF%E6%9C%AC/index.html">
<meta property="og:site_name" content="f1ashades&#39; blogs">
<meta property="og:description" content="基本指令使用：基本数据类型和命令、SpringData封装 redis缓存：缓存更新、缓存穿透、缓存雪崩、缓存击穿 分布式缓存：redis持久化、redis主从、redis哨兵sentinel、redis分片集群 redis实践：键值设计（BigKey）、批处理（pipeline）、服务端优化（持久化、慢查询、内存划分、集群选择） redis原理： ​	redis底层数据结构：SDS、intSet">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/jHRLZX3azpcfnsJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/27/inZlu9SYGbxKX3j.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/27/FleVtvqiM2ZygxO.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/hAwFlYZKJf6v9j1.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/27/4XQ1Dia7W9u6oGK.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/27/sLm2fVyrcZlGQqF.png">
<meta property="og:image" content="http://s2.loli.net/2022/06/28/rZIEYCKsQzAbMFH.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/29/G1SI9JbuXOK3j86.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/9Fwdyn8fQGTOmNP.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/35ldgXYVOFkvowD.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/o9XTwQdrHa45LUm.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/nvKem3OQbojMlF2.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/IVcB1T4gWfowJDp.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/p8Tez24dPqnFQtx.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/9fJib5ONgMIeG1F.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/sbCwyoIUkniR3aK.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/30/XV5Y4dw1KUZIyfe.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/InzpWuNroi1FOJV.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/4SjHbq2IUA6snrY.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/21D4SqY6zyGdFcx.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/eWut9wNAgiP7HF2.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/487LuPVgajhw1ZT.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/28/M2FScUpN9PTORaK.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/29/3wKx1Dv6IyWVnih.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/29/8w1suehtziyg96d.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/xeIkw7uiHPDCpt5.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/eadA9SzCD7L2s1w.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/RFJNwxuYWj1lXCk.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/8zxDElYgbQh93rB.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/djt4QxevTGFEH6Y.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/8oSpivlUrOJIkus.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/nzGWRyAil3EOJjI.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/7NB6z4LFsG18KOk.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/m2oOEHdsfGY4zDg.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/C7kfrJwMz621NVn.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/SxEmyFcMv8Yk3ND.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/MHDPeAWwvJoB4rl.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/HxX9k1Jq3sDpFGa.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/pjZzxEGBh5cqkyV.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/8HKh7IpB1wic3L2.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/9GY31por7ASPFqv.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/Og7uYbAfKi1h3LQ.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/SjV5Fdg3brsHzJn.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/CeISxMkapn4Hhl6.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/2nVL16ASGivr8zT.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/tIkjEr9ZcyY38QO.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/FyBPLbRxJvMnlgI.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/lhwoF9IR2dfXgAD.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/AcRHTkvPQKpOM3t.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/k2a6Fhlx9uSfjpm.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/SrOCslgzB7NAy4W.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/RvYTw3HWIjZKybd.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/RMbmAlp7TNkB8E2.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/248Os5SJzaiFZY6.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/BuLYkwtIU2Mpb5D.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/Bx9wCke52oYDKS3.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/Iq39EXs6gB5dfwv.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/foWjiXe2bKBtmIg.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/JFiOMudCRyH4Xph.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/lcNqXrGOhodETzp.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/GSjprRFBNnK2asz.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/XNQPLtgqVsj28GO.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/MBZbqr5jDXVtU8c.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/nAJplMBeu7QdVoR.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/W2wuTsgbmlHfYc3.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/ALqExkzwF3vgRXe.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/yamIjFi3TEZ2g4C.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/oqCZ3c2EeDaw6jv.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/eiHRGphY8XTngw7.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/pUMchN7sgL3tBzQ.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/qn8ukopLbIrwU52.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/eDfPRcr5iV8GLYF.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/wsvZqeQC2i4u8Xn.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/lYoEGnuHIBsZON7.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/gr5t9Vio7axydJI.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/9niega2ykOZGbWD.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/7YO4IzZvSokLp6a.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/E52aNkuZ3nSjs8D.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/iTdfkALw7H1IUBQ.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/MefLypt1dBQTXrn.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/10/xZEWf1ps53UAivX.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/ZRzKeaxDY7jrETy.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/TdXiGZ9SjqNEHbB.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/rFg8A5cQTqYZDwm.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/uEQ2ziembC6rK1f.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/ytxNWhp2v9kETnd.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/g2jriIcMvlQFy3u.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/LpI6nqa9MVe7rSx.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/gBXiV8461xQrWnO.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/PuOlxYv2zKpAUsc.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/SXqs2gzke8EFntb.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/av9DgPc7zUMSOwe.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/jFAqLOyfdDvzgaQ.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/HqUkSThN1y32VG5.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/uOi2xTI7LXReCy3.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/FlSGEpHhudUcbnI.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/JLM952IEvDakpxn.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/m6LKxuVYIq5S42N.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/jZwqa7gCHvKWRLl.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/yjC29HSIvlEY1DN.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/a8hzlGip9jkOdNs.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/1RBCv2xcw69PI7Y.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/Qsy6OclGdIohtSw.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/n4MoGpNWaLykfmH.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/7Oh5qCadAQocPEL.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/oLGXY1Qvu5STqlr.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/IxVJDO9zwj8KTsv.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/yUZAnhMH7jDBixT.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/cwFA5rCouWs3Ixh.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/NKOiUGMXklEzqHT.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/1Yd2bJ3vx7zNm9o.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/TWBR2m6CUfb1nXL.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/pEjUs1GhWbnadw9.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/oLZHSVmbq9MrT1A.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/BV6jl3DWQJbzfrT.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/91FRbHNWqO2QoEL.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/mzIlSj8pJPT2BU4.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/TpbwYiLQzkaxCoV.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/NiGH3yIQn2grloY.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/r4RuXjc9WV6EqOD.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/49wLGvtAjMHNUCS.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/zYaEkTcgeXSprml.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/Hctair5ADTjlIEY.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/BrVJFOUXeTGqK3l.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/16/J9TihAc61mlSUzs.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/8rCQazLjOdNS2vu.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/gnuAezKp2vTFf3o.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/NnYkJQ6vrc3tdfb.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/9HS2LQieg8kZEtw.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/jZx4L3Tuags26RQ.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/FqlCphimyZKUVN9.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/mbwdc47U86FrHWk.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/BFtRwQEb1oOI9Si.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/H59baUEce3vpZdA.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/YdxzUHbWlrQ9agS.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/c1gvXKFnphqj3Pf.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/2etZ8jlQKfYHhIO.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/KqhoNVabPYkfwL7.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/JjkNlQ2oAz6WcV3.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/ba3fGMwA9Dq8m1y.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/iqRIsz19U5v4aVA.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/XHMiSKmecYb9wat.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/8GtAq4QRXJ67Dxe.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/2nVQTjD85lcCqRx.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/6Ddp4FxoMCTzEhL.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/mEuTFvCQlWIYGsz.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/VseRxXDLKmTM72Y.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/dZ85hQOLzMsnXr3.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/iUMXFesmb2WxQZE.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/DujaCnx7h3lQ8ps.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/MvQ7fpIi8Sug1Zz.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/CRy81o9Nuiagw6b.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/YqaeXy7cN13dTbm.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/KUfDmZ4nlLJir6W.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/qDCNSUFaZ7xsu6W.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/cb4zD5K6EavdWJm.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/WbJjcT7EX4BAPhd.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/RyVwhTFb9S1WYpu.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/6ftipVMK9EQWre5.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/XFrLPAe67qitEbV.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/vOlI3GzY6FwJms4.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/LRbvW1wfOHVtrCY.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/U7dYZuscDfKCP32.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/cqvxMlLwJiujkU8.png">
<meta property="og:image" content="d:/Typora/TyporaPictureBed/image-20220812112844387.png">
<meta property="og:image" content="d:/Typora/TyporaPictureBed/image-20220812112741940.png">
<meta property="og:image" content="d:/Typora/TyporaPictureBed/image-20220812120759073.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/o9PeLCxTbDkUXWt.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/CLlEKH9e12ixkcT.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/OXD82HqSGlJPtUC.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/RCnZKq89ixEBfAG.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/3enj7HNX4fBCIuE.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/52eNlbAV1wkxFja.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/17/s5LPMCAZwc4JDyt.png">
<meta property="article:published_time" content="2022-04-15T08:05:12.000Z">
<meta property="article:modified_time" content="2022-08-13T07:49:49.143Z">
<meta property="article:author" content="f1ashades">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/06/28/jHRLZX3azpcfnsJ.png">

<link rel="canonical" href="http://example.com/2022/04/15/1redis%20-%20%E5%89%AF%E6%9C%AC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis相关 | f1ashades' blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">f1ashades' blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/15/1redis%20-%20%E5%89%AF%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mine.jpg">
      <meta itemprop="name" content="f1ashades">
      <meta itemprop="description" content="once again I am a child">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="f1ashades' blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis相关
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-15 16:05:12" itemprop="dateCreated datePublished" datetime="2022-04-15T16:05:12+08:00">2022-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 15:49:49" itemprop="dateModified" datetime="2022-08-13T15:49:49+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>96k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:41</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>基本指令使用：基本数据类型和命令、SpringData封装</p>
<p>redis缓存：缓存更新、缓存穿透、缓存雪崩、缓存击穿</p>
<p>分布式缓存：redis持久化、redis主从、redis哨兵sentinel、redis分片集群</p>
<p>redis实践：键值设计（BigKey）、批处理（pipeline）、服务端优化（持久化、慢查询、内存划分、集群选择）</p>
<p>redis原理：</p>
<p>​	redis底层数据结构：SDS、intSet、ZipList、QuickList、SkipList、Dict、RedisObject</p>
<p>​	redis基本数据类型：String、List、Set、ZSet、Hash</p>
<p>​	redis网络模型：五种IO、redis—IO多路复用+事件派发</p>
<p>​	redis通信协议：RESP</p>
<p>​	redis过期策略：懒惰删除、周期删除（slow、fast）</p>
<p>​	内存淘汰策略：8种淘汰策略、基本流程</p>
<span id="more"></span>

<h1 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h1><h2 id="1-数据类型和命令"><a href="#1-数据类型和命令" class="headerlink" title="1.数据类型和命令"></a>1.数据类型和命令</h2><h3 id="1）通用命令"><a href="#1）通用命令" class="headerlink" title="1）通用命令"></a>1）通用命令</h3><blockquote>
<p><strong>通用指令是部分数据类型的，都可以使用的指令，常见的有如下表格所示</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">KEYS</td>
<td align="center">查看符合模板的所有key，不建议在生产环境设备上使用</td>
</tr>
<tr>
<td align="center">DEL</td>
<td align="center">删除一个指定的key</td>
</tr>
<tr>
<td align="center">EXISTS</td>
<td align="center">判断key是否存在</td>
</tr>
<tr>
<td align="center">EXPIRE</td>
<td align="center">给一个key设置有效期，有效期到期时该key会被自动删除</td>
</tr>
<tr>
<td align="center">TTL</td>
<td align="center">查看一个KEY的剩余有效期</td>
</tr>
</tbody></table>
<p><strong>可以通过<code>help [command] </code>可以查看一个命令的具体用法！</strong></p>
<h3 id="2）String类型"><a href="#2）String类型" class="headerlink" title="2）String类型"></a>2）String类型</h3><h4 id="①基本使用"><a href="#①基本使用" class="headerlink" title="①基本使用"></a>①基本使用</h4><blockquote>
<p><strong>String类型，也就是字符串类型，是Redis中最简单的存储类型。</strong></p>
</blockquote>
<p><img src="https://s2.loli.net/2022/06/28/jHRLZX3azpcfnsJ.png" alt="image-20220627141435150"></p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li><code>string</code>：普通字符串</li>
<li><code>int</code>：整数类型，可以做自增、自减操作</li>
<li><code>float</code>：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过<strong>512m</strong>.</p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">msg</td>
<td align="center">hello world</td>
</tr>
<tr>
<td align="center">num</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">score</td>
<td align="center">92.5</td>
</tr>
</tbody></table>
<ul>
<li>当value是数字，redis会将其转换成二进制的方式去存储，这样一个字节（8bit）就能表示很大的数字‘</li>
<li>当value是字符串，redis只能将其转换成字节码来进行存储</li>
</ul>
<blockquote>
<p><strong>String的常见命令有如下表格所示</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SET</td>
<td align="center">添加或者修改已经存在的一个String类型的键值对</td>
</tr>
<tr>
<td align="center">GET</td>
<td align="center">根据key获取String类型的value</td>
</tr>
<tr>
<td align="center">MSET</td>
<td align="center">批量添加多个String类型的键值对</td>
</tr>
<tr>
<td align="center">MGET</td>
<td align="center">根据多个key获取多个String类型的value</td>
</tr>
<tr>
<td align="center">INCR</td>
<td align="center">让一个整型的key自增1</td>
</tr>
<tr>
<td align="center">INCRBY</td>
<td align="center">让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2，（负数就代表自减&#x3D;DECR命令）</td>
</tr>
<tr>
<td align="center">INCRBYFLOAT</td>
<td align="center">让一个浮点类型的数字自增并指定步长</td>
</tr>
<tr>
<td align="center">SETNX</td>
<td align="center">添加一个String类型的键值对，前提是这个key不存在，否则不执行，类似set k v -nx</td>
</tr>
<tr>
<td align="center"><strong>SETEX</strong></td>
<td align="center">添加一个String类型的键值对，并且指定有效期，类似set k v -ex 5</td>
</tr>
</tbody></table>
<h4 id="②key的层级命名"><a href="#②key的层级命名" class="headerlink" title="②key的层级命名"></a>②key的层级命名</h4><p>Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>

<p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p>
<p>例如我们的项目名称叫 <code>fla</code>，有<code>user</code>和<code>product</code>两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><strong>user</strong>相关的key：<code>fla:user:1</code></li>
<li><strong>product</strong>相关的key：<code>fla:product:1</code></li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">heima:user:1</td>
<td align="center">{“id”:1, “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td align="center">heima:product:1</td>
<td align="center">{“id”:1, “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody></table>
<h3 id="3）Hash类型"><a href="#3）Hash类型" class="headerlink" title="3）Hash类型"></a>3）Hash类型</h3><blockquote>
<p><strong>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的<code>HashMap</code>结构。</strong></p>
</blockquote>
<p><strong>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</strong></p>
<p><img src="https://s2.loli.net/2022/06/27/inZlu9SYGbxKX3j.png" alt="image-20220627141350237"></p>
<blockquote>
<p>Hash的常见命令有：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HSET key field value</td>
<td align="center">添加或者修改hash类型key的field的值</td>
</tr>
<tr>
<td align="center">HGET key field</td>
<td align="center">获取一个hash类型key的field的值</td>
</tr>
<tr>
<td align="center">HMSET</td>
<td align="center">hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td>
</tr>
<tr>
<td align="center">HMGET</td>
<td align="center">批量获取多个hash类型key的field的值</td>
</tr>
<tr>
<td align="center">HGETALL</td>
<td align="center">获取一个hash类型的key中的所有的field和value</td>
</tr>
<tr>
<td align="center">HKEYS</td>
<td align="center">获取一个hash类型的key中的所有的field</td>
</tr>
<tr>
<td align="center">HVALS</td>
<td align="center">获取一个hash类型的key中的所有的value</td>
</tr>
<tr>
<td align="center">HINCRBY</td>
<td align="center">让一个hash类型key的字段值自增并指定步长</td>
</tr>
<tr>
<td align="center">HSETNX</td>
<td align="center">添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td>
</tr>
</tbody></table>
<h3 id="4）List类型"><a href="#4）List类型" class="headerlink" title="4）List类型"></a>4）List类型</h3><blockquote>
<p><strong>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</strong></p>
</blockquote>
<p><img src="https://s2.loli.net/2022/06/27/FleVtvqiM2ZygxO.png" alt="image-20220627143835340"></p>
<p><strong>特征也与<code>LinkedList</code>类似：</strong></p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等.</p>
<blockquote>
<p><strong>List的常见命令有</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LPUSH key  element …</td>
<td align="center">向列表左侧插入一个或多个元素</td>
</tr>
<tr>
<td align="center">LPOP key</td>
<td align="center">移除并返回列表左侧的第一个元素，没有则返回nil</td>
</tr>
<tr>
<td align="center">RPUSH key  element …</td>
<td align="center">向列表右侧插入一个或多个元素</td>
</tr>
<tr>
<td align="center">RPOP key</td>
<td align="center">移除并返回列表右侧的第一个元素</td>
</tr>
<tr>
<td align="center">LRANGE key star end</td>
<td align="center">返回一段角标范围内的所有元素</td>
</tr>
<tr>
<td align="center">BLPOP和BRPOP</td>
<td align="center">与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td>
</tr>
</tbody></table>
<ul>
<li>BLPOP和BRPOP在没有元素的时候会阻塞，直到有元素或者等待时间到了为止</li>
</ul>
<blockquote>
<p><strong>思考问题</strong></p>
</blockquote>
<ul>
<li><p><strong>如何利用List结构模拟一个栈?</strong></p>
<ul>
<li>先进后出，入口和出口在同一边</li>
</ul>
</li>
<li><p><strong>如何利用List结构模拟一个队列?</strong></p>
<ul>
<li>先进先出，入口和出口在不同边</li>
</ul>
</li>
<li><p><strong>如何利用List结构模拟一个阻塞队列?</strong></p>
<ul>
<li>入口和出口在不同边</li>
<li>出队时采用BLPOP或BRPOP</li>
</ul>
</li>
</ul>
<h3 id="5）Set类型"><a href="#5）Set类型" class="headerlink" title="5）Set类型"></a>5）Set类型</h3><blockquote>
<p><strong>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征</strong></p>
</blockquote>
<ul>
<li><p>无序</p>
<ul>
<li>每一个元素通过hash算法分配到指定位置，所以不保证顺序</li>
</ul>
</li>
<li><p>元素不可重复</p>
</li>
<li><p>查找快</p>
</li>
<li><p>支持交集、并集、差集等功能</p>
</li>
</ul>
<blockquote>
<p><strong>Set的常见命令有</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SADD key member …</td>
<td align="center">向set中添加一个或多个元素</td>
</tr>
<tr>
<td align="center">SREM key member …</td>
<td align="center">移除set中的指定元素</td>
</tr>
<tr>
<td align="center">SCARD key</td>
<td align="center">返回set中元素的个数</td>
</tr>
<tr>
<td align="center">SISMEMBER key member</td>
<td align="center">判断一个元素是否存在于set中</td>
</tr>
<tr>
<td align="center">SMEMBERS key</td>
<td align="center">获取set中的所有元素</td>
</tr>
<tr>
<td align="center">SINTER key1 key2 …</td>
<td align="center">求key1与key2的交集</td>
</tr>
<tr>
<td align="center">SDIFF key1 key2 …</td>
<td align="center">求key1与key2的差集</td>
</tr>
<tr>
<td align="center">SUNION key1 key2 ..</td>
<td align="center">求key1和key2的并集</td>
</tr>
</tbody></table>
<ul>
<li>注意：SDIFF key1 key2 求出来的结果是key1中有，但是key2没有的</li>
</ul>
 <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd yk 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd yd 1 2 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SDIFF yk yd</span><br><span class="line">1) &quot;3&quot; //注意结果是yk中有的，yd中没有的</span><br></pre></td></tr></table></figure>

<p>​       </p>
<h3 id="6）SortedSet类型"><a href="#6）SortedSet类型" class="headerlink" title="6）SortedSet类型"></a>6）SortedSet类型</h3><blockquote>
<p><strong>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</strong></p>
</blockquote>
<p><strong>SortedSet具备下列特性：</strong></p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<blockquote>
<p><strong>SortedSet的常见命令有</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZADD key score member</td>
<td align="center">添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td>
</tr>
<tr>
<td align="center">ZREM key member</td>
<td align="center">删除sorted set中的一个指定元素</td>
</tr>
<tr>
<td align="center">ZSCORE key member</td>
<td align="center">获取sorted set中的指定元素的score值</td>
</tr>
<tr>
<td align="center">ZRANK key member</td>
<td align="center">获取sorted set 中的指定元素的排名（按score升序排）</td>
</tr>
<tr>
<td align="center">ZREVRANK key member</td>
<td align="center">和ZRANK类似，但这是按score降序排后的排名</td>
</tr>
<tr>
<td align="center">ZCARD key</td>
<td align="center">获取sorted set中的元素个数</td>
</tr>
<tr>
<td align="center">ZCOUNT key min max</td>
<td align="center">统计score值在给定范围内的所有元素的个数</td>
</tr>
<tr>
<td align="center">ZINCRBY key increment member</td>
<td align="center">让sorted set中的指定元素自增，步长为指定的increment值</td>
</tr>
<tr>
<td align="center">ZRANGE key min max</td>
<td align="center">按照score升序排序后，获取指定排名范围内的元素，传入的是排名</td>
</tr>
<tr>
<td align="center">ZREVRANGE key min max</td>
<td align="center">按照score降序排序后，获取指定排名范围内的元素，传入的是排名</td>
</tr>
<tr>
<td align="center">ZRANGEBYSCORE key min max</td>
<td align="center">按照score排序后，获取指定score范围内的元素</td>
</tr>
<tr>
<td align="center">ZDIFF、ZINTER、ZUNION</td>
<td align="center">求差集、交集、并集</td>
</tr>
</tbody></table>
<ul>
<li>默认的排名方式都是按score升序，加上REV代表是按score降序排</li>
<li>rank查某一member的排名，count查score在某一范围的数量，range查某一排名中的具体members</li>
</ul>
<h3 id="7）bitMap"><a href="#7）bitMap" class="headerlink" title="7）bitMap"></a>7）bitMap</h3><img src="https://s2.loli.net/2022/07/16/hAwFlYZKJf6v9j1.png" alt="image-20220715130408225" style="zoom:80%;" />

<p>Redis中是利用String类型数据结构实现BitMap，因此最大上限是512MB，转换为bit则是 2^32个bit位。</p>
<p>BitMap的操作命令有：</p>
<ul>
<li><p>SETBIT：向指定位置（offset）存入一个0或1</p>
</li>
<li><p>GETBIT ：获取指定位置（offset）的bit值</p>
</li>
<li><p>BITCOUNT ：统计BitMap中值为1的bit位的数量</p>
</li>
<li><p>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</p>
<ul>
<li>BITFIELD sign:5:202203 GET u14 0<ul>
<li>u代表是无符号位</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/section/1374165">https://cloud.tencent.com/developer/section/1374165</a></li>
</ul>
</li>
</ul>
</li>
<li><p>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</p>
</li>
<li><p>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</p>
</li>
<li><p>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</p>
</li>
</ul>
<p>如果我们使用java客户端接收，接收到的是这个bitMap按照askII转换过的一个字符串，而不是这个</p>
<h3 id="8）Geo"><a href="#8）Geo" class="headerlink" title="8）Geo"></a>8）Geo</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li>
</ul>
<h2 id="2-Spring-Data-封装"><a href="#2-Spring-Data-封装" class="headerlink" title="2.Spring Data 封装"></a>2.Spring Data 封装</h2><p>​	redis在不同的客户端有不同的操作指令，jedis的指令和命令行指令相同，但是lettuce中就对于不同操作自己定义了一套指令。spring对redis客户端的实现做了整合，提供了一套完整的api来提供一致的接口，统一了不同客户端的操作方式。</p>
<h3 id="1）准备工作"><a href="#1）准备工作" class="headerlink" title="1）准备工作"></a>1）准备工作</h3><p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--jackson转换--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redis的starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义redisTemplate中用到jason的序列化需要导入jason依赖</p>
</li>
<li><p>如果不配置commons-pool2，连接池是不会生效的</p>
</li>
</ul>
<p>yml配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#连接地址</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234</span> <span class="comment">#连接密码</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment">#最大空闲数</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#最小空闲数</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure>



<h3 id="2）RedisTemplate"><a href="#2）RedisTemplate" class="headerlink" title="2）RedisTemplate"></a>2）RedisTemplate</h3><h4 id="①默认序列化"><a href="#①默认序列化" class="headerlink" title="①默认序列化"></a>①默认序列化</h4><p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ValueOperations</span> <span class="variable">ops</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">        ops.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;moxioxi&quot;</span>);</span><br><span class="line"><span class="comment">//        ops.set(&quot;stu1&quot;,new Stu(&quot;yk&quot;,31)); 如果我们执行这一句话会直接报错，因为没有针对user进行序列化</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://s2.loli.net/2022/06/27/4XQ1Dia7W9u6oGK.png" alt="image-20220627165634412"></p>
<p>原因：</p>
<ul>
<li>当我们查看源码可以看到</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplate</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">RedisAccessor</span> <span class="keyword">implements</span> <span class="title class_">RedisOperations</span>&lt;K, V&gt;, BeanClassLoaderAware &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enableTransactionSupport</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">exposeConnection</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enableDefaultSerializer</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisSerializer</span> <span class="variable">keySerializer</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//1.</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisSerializer</span> <span class="variable">valueSerializer</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//2.</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisSerializer</span> <span class="variable">hashKeySerializer</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//3.</span></span><br><span class="line">    <span class="meta">@Nullable</span>.</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisSerializer</span> <span class="variable">hashValueSerializer</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//4.</span></span><br></pre></td></tr></table></figure>

<p>​	实际上RedisTemplate是具有泛型的，并且在内部定义了4种序列化的格式，分别针对key，value，hashKey，hashValue，当我们没有相应的serializer的时候，默认的就是jdk的序列化方法。redisTemplate首先会根据设置的序列化器将数据序列化，然后将序列化的值存入redis中。</p>
<p>​	为了解决这个问题我们有两种方式</p>
<ul>
<li><p>配置RedisTemplate，在RedisTemplate中提供serializer</p>
</li>
<li><p>手动序列化</p>
</li>
</ul>
<p>​	</p>
<h4 id="②配置RedisTemplate"><a href="#②配置RedisTemplate" class="headerlink" title="②配置RedisTemplate"></a>②配置RedisTemplate</h4><p>注意我们这里由jason的处理，一定要有jason的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jackson转换--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">ValueOperations</span> <span class="variable">ops</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">	ops.set(<span class="string">&quot;stu1&quot;</span>,<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;yk&quot;</span>,<span class="number">31</span>));</span><br><span class="line">       Stu stu1= (Stu)ops.get(<span class="string">&quot;stu1&quot;</span>);</span><br><span class="line">       System.out.println(stu1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>RedisTemplate配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">redisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建Template</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2.设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 3.设置序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 4.key和 hashKey采用 string序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 5.value和 hashValue采用 JSON序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>boot自动装载了一个RedisTemplate的bean（id是redisTemplate），但是其中所有的serializer都是jdk的serializer，我们需要自己重写一个</li>
<li>一个基本思路：key都是String格式，value都是json格式</li>
<li>结果</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/27/sLm2fVyrcZlGQqF.png" alt="image-20220627171612545"></p>
<p>可以看到key是String，value也是jason格式，并且通过打印结果我们看到get的String可以直接反序列化</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">控制台:</span><br><span class="line">	Stu(name=yk, age=31)</span><br></pre></td></tr></table></figure>

<ul>
<li>原因很简单，当我们在RedisTemplate自定义了json的serializer后，它会帮我们加上序列化的全路径，这样就可以直接反序列化</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.fla.domain.pojo.Stu&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yk&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">31</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>但这样为我们的jason加上了额外的数据，增加了额外负担，因此我们应该手动进行序列化和反序列化、</li>
</ul>
<h4 id="③StringRedisTemplate（推荐）"><a href="#③StringRedisTemplate（推荐）" class="headerlink" title="③StringRedisTemplate（推荐）"></a>③StringRedisTemplate（推荐）</h4><p>​	StringRedisTemplate其实就是泛型都是String，key和value都是String，然后手动序列化和反序列化</p>
<p><strong>测试类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 准备对象</span></span><br><span class="line">    <span class="type">Stu</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;yc&quot;</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(stu);</span><br><span class="line">    <span class="comment">// 写入一条数据到redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;stu2&quot;</span>,json);</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">stu2</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;stu2&quot;</span>);</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    System.out.println(mapper.readValue(stu2, Stu.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在存入之前手动序列化数据</p>
</li>
<li><p>在接收到数据后手动反序列化数据</p>
</li>
<li><p>这里用的序列化工具是ObjectMapper，也可以使用其它的工具如fastJason</p>
</li>
<li><p>这是更推荐的方式，因为不会在redis中增加额外的数据</p>
</li>
</ul>
<h1 id="二、实际使用"><a href="#二、实际使用" class="headerlink" title="二、实际使用"></a>二、实际使用</h1><h2 id="1-Redis实现session共享"><a href="#1-Redis实现session共享" class="headerlink" title="1.Redis实现session共享"></a>1.Redis实现session共享</h2><h3 id="1）原始session共享的问题"><a href="#1）原始session共享的问题" class="headerlink" title="1）原始session共享的问题"></a>1）原始session共享的问题</h3><p><img src="http://s2.loli.net/2022/06/28/rZIEYCKsQzAbMFH.png" alt="image-20220628103912612">	通过短信登录的案例来理解，我们在进行短信登录时首先会在发送验证码并进行校验，在校验成功后会根据手机号在数据库中查询是否有对应用户，若没有则进行注册。最后将该用户的部分信息(主要是用户名等非敏感信息，密码等敏感信息不能存，可以专门封装成一个UserDTO)存入session中。</p>
<p>​	这样我们配置一个拦截器，拦截有需要验证登录状态的请求，从session中取出这个userDTO，并通过ThreadLocal的方式绑定在该线程（这么做是为了后序的controller中能拿到这个userDTO）。</p>
<p><strong>这样做会有很多问题：</strong></p>
<p><img src="https://s2.loli.net/2022/06/29/G1SI9JbuXOK3j86.png" alt="image-20220628122047380"></p>
<ul>
<li>我们一次会话中的请求可能被负载到不同的tomcat中，多台tomcat之间不能直接共享session数据，需要进行session备份。</li>
<li>这样并不是一个好的解决办法，因为多台tomcat备份同样的数据，造成了内存空间的浪费</li>
<li>并且拷贝是需要时间的，若在这段时间有请求，则会发生数据延迟的现象</li>
<li>我们需要一个替代品<ul>
<li>数据共享，多台tomcat都能访问</li>
<li>内存存储，需要较好的性能</li>
<li>key-value格式，类似session</li>
</ul>
</li>
</ul>
<p>通过以上信息，redis是一个完美的解决方案</p>
<h3 id="2）redis解决"><a href="#2）redis解决" class="headerlink" title="2）redis解决"></a>2）redis解决</h3><h4 id="①验证码存redis"><a href="#①验证码存redis" class="headerlink" title="①验证码存redis"></a>①验证码存redis</h4><p><img src="https://s2.loli.net/2022/06/28/9Fwdyn8fQGTOmNP.png" alt="image-20220628123827392"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    SMSUtils.send(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将发送的验证码存入redis中</li>
<li>注意redis中存入的key：前缀（login:code:）+phoneNum</li>
</ul>
<h4 id="②用户状态存入redis"><a href="#②用户状态存入redis" class="headerlink" title="②用户状态存入redis"></a>②用户状态存入redis</h4><p><img src="https://s2.loli.net/2022/06/28/35ldgXYVOFkvowD.png" alt="image-20220628124104952"></p>
<p><strong>部分UserService中的log代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line"><span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line"><span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">        CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line"><span class="comment">// 7.3.存储</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line"><span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.返回token</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(token);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将随机生成的UUID作为redis的key的一部分，redis的key&#x3D;前缀token（login:token:）+ UUID</p>
</li>
<li><p>将前缀的token作为数据返回回去</p>
</li>
<li><p>存入的时候value是HashMap，为了避免使用put多次与redis交互，这里使用putAll一次性存完</p>
<ul>
<li>注意这里在userDTO中的id是long值，stringRedisTemplate要求key和value都要是String值，所以这里需要处理一下，否则报错</li>
</ul>
</li>
<li><p>注意和session一样，我们需要添加有效期</p>
<ul>
<li>但我我们还需要做到用户若一直在请求那么就要一直更新这个有效期，这个可以用拦截器实现</li>
</ul>
</li>
</ul>
<h4 id="③拦截器校验登录状态"><a href="#③拦截器校验登录状态" class="headerlink" title="③拦截器校验登录状态"></a>③拦截器校验登录状态</h4><p><img src="https://s2.loli.net/2022/06/28/o9XTwQdrHa45LUm.png" alt="image-20220628125622967"></p>
<p><strong>拦截器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">//不存在，拦截，返回401状态码response.setStatus (401);</span></span><br><span class="line">            <span class="comment">// return false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object,Object &gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3. 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//4.不存在，拦截，返回401状态码response.setstatus(401);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的Hash数据转为userDTO对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanthMap(userMap,<span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：拦截器中不能autowired需要的stringRedisTemplate，因为我们在springMvcConfig中配置的拦截器是直接new()出来的，并没有交给spring管理，自然也不能获得spring容器中的其它对象，所以在这里我们通过构造方法的方式获得了，详细结合下方sringMvcConfig配置看</li>
<li>根据UUID在redis中查询到了对应的userDTO后需要绑定在该线程的threadLocal中，并更新token有效期</li>
</ul>
<p><strong>springMvcConfig：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(stringRedisTemplate)) <span class="comment">//构造器注入</span></span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)). 		                     </span><br><span class="line">            addPathPatterns(<span class="string">&quot;/**&quot;</span>).</span><br><span class="line">            order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>拦截器需要stringRedisTemplate，但是拦截器并没有交给spring管理，无法autowired，所以首先在配置中获取，然后再通过构造方法注入（这是mvc配置，不是拦截器，所以可以@AutoWired或@Resource）</li>
</ul>
<h4 id="④一个小问题"><a href="#④一个小问题" class="headerlink" title="④一个小问题"></a>④一个小问题</h4><p>​		因为我们目前设置的拦截器仅仅拦截了部分必须要登录用户状态（如主页）的操作，但我们在访问一些不需要登录信息的资源的时候（如排行榜）时我们也应该更新token的有效期，所以我们可以再设置一个拦截器完成该操作</p>
<p><strong>更新token有效期的拦截器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这里做了获取用户信息并存入ThreadLocal中，并更新有效期</li>
<li>如果redis没有用户信息，那么会直接到下一个拦截器，不会存入ThreadLocal并更新token有效期</li>
</ul>
<p><strong>需要登录状态信息的模块的拦截器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里只需要判断ThreadLocal中是否有用户</li>
</ul>
<p><strong>SpringMvcConfig：</strong></p>
<p>拦截器顺序的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).</span><br><span class="line">                addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个拦截器中都有一个默认order&#x3D;0，如果没有手动修改，默认的顺序就是拦截器的配置顺序</li>
<li>可以手动修该order来配置拦截器顺序（从0开始，0优先级最高）</li>
</ul>
<h2 id="2-Redis缓存"><a href="#2-Redis缓存" class="headerlink" title="2.Redis缓存"></a>2.Redis缓存</h2><h3 id="1）基本概述"><a href="#1）基本概述" class="headerlink" title="1）基本概述"></a>1）基本概述</h3><p><img src="https://s2.loli.net/2022/06/28/nvKem3OQbojMlF2.png" alt="image-20220628152500015"></p>
<p>redis作为一种高读写速度的数据库，非常适合做缓存</p>
<p><img src="https://s2.loli.net/2022/06/28/IVcB1T4gWfowJDp.png" alt="image-20220628153051997"></p>
<ul>
<li><p>基本流程</p>
<ul>
<li>首先查询redis，如果命中直接返回</li>
<li>未命中查询数据库，返回数据的同时还要将数据写入redis</li>
</ul>
</li>
<li><p>缓存的好处：</p>
<ul>
<li><p>降低后端负载</p>
</li>
<li><p>提高读写效率，降低响应时间</p>
</li>
</ul>
</li>
<li><p>缓存的成本</p>
<ul>
<li>数据一致性成本：保证缓存中数据和实际数据一致性</li>
<li>增加维护成本</li>
<li>运维成本</li>
</ul>
</li>
</ul>
<p>​	</p>
<h3 id="2）添加缓存"><a href="#2）添加缓存" class="headerlink" title="2）添加缓存"></a>2）添加缓存</h3><p><img src="https://s2.loli.net/2022/06/28/p8Tez24dPqnFQtx.png" alt="image-20220628155301811"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById1</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;cache : shop: &quot;</span> + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);<span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">    <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson,Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));</span><br><span class="line">    <span class="comment">//7.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先查缓存，存在直接反序列化返回</li>
<li>没有则查数据库，不存在直接返回错误；存在序列化写入缓存并返回该shop</li>
</ul>
<h3 id="3）缓存更新"><a href="#3）缓存更新" class="headerlink" title="3）缓存更新"></a>3）缓存更新</h3><h4 id="①缓存更新策略"><a href="#①缓存更新策略" class="headerlink" title="①缓存更新策略"></a>①缓存更新策略</h4><p><img src="https://s2.loli.net/2022/06/28/9fJib5ONgMIeG1F.png"></p>
<ul>
<li><p>内存淘汰：redis本身的淘汰机制，在内存不足时自动淘汰</p>
</li>
<li><p>无法控制，且维护一致性很差</p>
</li>
<li><p>超时剔除：给缓存在redis的数据添加有效期，到期自动删除。删除后下次查询更新缓存</p>
<ul>
<li>控制性一般</li>
</ul>
</li>
<li><p>主动更新：编写逻辑代码，修改数据库的同时更新缓存</p>
</li>
</ul>
<p>综上，主动更新策略是最有效的，我们主要选择<strong>主动更新</strong>，<strong>超时剔除</strong>作为辅助</p>
<h4 id="②主动更新方案"><a href="#②主动更新方案" class="headerlink" title="②主动更新方案"></a>②主动更新方案</h4><p><img src="https://s2.loli.net/2022/06/28/sbCwyoIUkniR3aK.png" alt="image-20220628165501762"></p>
<ul>
<li>Cache Aside Pattern</li>
<li>人为编码，在更新数据库同时更新缓存</li>
<li>Read&#x2F;Write Through Patther<ul>
<li>维护一个服务，<strong>我们在操作数据的时候并不知道是缓存数据还是数据库数据</strong>，由这个服务去维护一致性</li>
</ul>
</li>
<li>Write Behind Caching Pattern<ul>
<li>我们只操作缓存，由其它线程异步将缓存数据持久化到数据库</li>
</ul>
</li>
</ul>
<p>综上，后两者都有一定难度，对于我们来说选择自己编码的方式</p>
<h4 id="③实施细节"><a href="#③实施细节" class="headerlink" title="③实施细节"></a>③实施细节</h4><p>操作缓存和数据库时有三个问题需要考虑：</p>
<p>1）删除缓存还是更新缓存？</p>
<ul>
<li><p>更新缓存：每次更新数据库都更新缓存，无效写操作较多，查询100次就会更新100次，但其实最后一次才是有效的</p>
</li>
<li><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</p>
</li>
</ul>
<p>2）如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li><p>单体系统，将缓存与数据库操作放在一个事务</p>
</li>
<li><p>分布式系统，利用TCC等分布式事务方案</p>
</li>
</ul>
<p>3）先操作缓存还是先操作数据库</p>
<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/30/XV5Y4dw1KUZIyfe.png" alt="image-20220629182238619"></p>
<ul>
<li>先删除缓存，再操作数据库<ul>
<li>线程1先删除缓存A&#x3D;10，线程2此时查询缓存未命中，查询数据库A&#x3D;10并写入缓存A&#x3D;10，线程1更新数据库A&#x3D;20</li>
</ul>
</li>
<li>先操作数据库，再删除缓存<ul>
<li>缓存由于一些问题没有了，线程1查询缓存未命中查询数据库A&#x3D;10，线程2此时更新数据库A&#x3D;20（缓存已经没了），删除缓存，并写入缓存，</li>
</ul>
</li>
<li>两种方式都有问题，第一种线程2查询数据库和写缓存操作时间较少，很容易完成；但第二种线程2要更新数据库并删除缓存，这要的时间是较长的，不容易完成，所以选择第二种<ul>
<li>并且还可以设置ttl时间来辅助</li>
</ul>
</li>
</ul>
<p>综上，选择先操作数据库再删除缓存</p>
<h4 id="④example"><a href="#④example" class="headerlink" title="④example"></a>④example</h4><p>ShopService中的update操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id不能为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">// 2.删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加入了事务保证原子性</li>
</ul>
<h3 id="4）缓存穿透"><a href="#4）缓存穿透" class="headerlink" title="4）缓存穿透"></a>4）缓存穿透</h3><h4 id="①基本概念"><a href="#①基本概念" class="headerlink" title="①基本概念"></a>①基本概念</h4><p><img src="https://s2.loli.net/2022/06/28/InzpWuNroi1FOJV.png" alt="image-20220628174002078"></p>
<ul>
<li><p>缓存穿透指的是请求的数据在缓存和数据库中都不存在，这样缓存永远都不会命中，若有大量这样的请求会加剧数据库负担</p>
</li>
<li><p>主动解决</p>
<ul>
<li>热点key限流</li>
<li>权限管理</li>
<li>设置复杂无规律id，让别人没办法猜</li>
<li>做好数据基础格式校验<ul>
<li>主动屏蔽一些不可能的id如：0,-1等</li>
</ul>
</li>
</ul>
</li>
<li><p>被动解决</p>
<ul>
<li>缓存空值<ul>
<li>在请求数据库没有数据后，缓存空值并设置ttl</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>布隆过滤是一种算法，会根据hash函数映射出是否存在对应数据，如果不存在直接不会请求缓存和数据库</li>
<li>可能误判<ul>
<li>布隆说没有，一定没有</li>
<li>布隆说有，不一定有</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="②缓存空值实现"><a href="#②缓存空值实现" class="headerlink" title="②缓存空值实现"></a>②缓存空值实现</h4><p><img src="https://s2.loli.net/2022/06/28/4SjHbq2IUA6snrY.png" alt="image-20220628174612591"></p>
<p><strong>shopService根据id查询店铺方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span> <span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在，blank：&quot;&quot;,null,&quot;   &quot; 都算</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断命中的是否是空值，如果不是null那就是&quot;&quot;空值</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//返回一个错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺信息不存在!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 6.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将空值写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.存在，写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询缓存若是<code>&quot;&quot;</code>空值直接返回</li>
<li>查询数据库没数据写<code>&quot;&quot;</code>到缓存</li>
</ul>
<h4 id="③布隆过滤"><a href="#③布隆过滤" class="headerlink" title="③布隆过滤"></a>③布隆过滤</h4><h3 id="5）缓存雪崩"><a href="#5）缓存雪崩" class="headerlink" title="5）缓存雪崩"></a>5）缓存雪崩</h3><p><img src="https://s2.loli.net/2022/06/28/21D4SqY6zyGdFcx.png" alt="image-20220628180622396"></p>
<p>缓存雪崩由两个原因造成：</p>
<ul>
<li>ttl同时失效，一瞬间大量缓存消失</li>
<li>redis宕机</li>
</ul>
<p>这样会造成大量请求到达数据库，加剧数据库压力</p>
<p>解决办法：</p>
<ul>
<li><p>给不同的Key的TTL添加随机值</p>
<ul>
<li>可以通过在TTL后面加random值来实现</li>
</ul>
</li>
<li><p>利用Redis集群提高服务的可用性</p>
<ul>
<li>搭建redis集群，多台redis服务器，其中一台宕机，其余还可以工作</li>
<li><code>主机</code>宕机，哨兵机制会从<code>从机</code>中选择一个继续工作</li>
</ul>
</li>
<li><p>给缓存业务添加降级限流策略</p>
<ul>
<li>微服务知识：如果流量过大，快速失败，减轻负担</li>
</ul>
</li>
<li><p>给业务添加多级缓存</p>
<ul>
<li>多级缓存：nginx缓存-&gt;redis缓存 这样就是两级缓存</li>
<li>redis这一级宕机了，还有其它级缓存</li>
</ul>
</li>
</ul>
<h3 id="6）缓存击穿"><a href="#6）缓存击穿" class="headerlink" title="6）缓存击穿"></a>6）缓存击穿</h3><p><img src="https://s2.loli.net/2022/06/28/eWut9wNAgiP7HF2.png" alt="image-20220628183502135"></p>
<p>​	缓存雪崩是大量key失效，缓存击穿是个别key失效（TTL到期），这些key是<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的<strong>热点key</strong>，这样会造成大量请求冲击在数据库上。</p>
<p>如上图：</p>
<ul>
<li>线程1查询未命中，说明该热点key已经失效，那么需要查询数据库重新构建缓存</li>
<li>其它线程会重复线程1的操作，大量请求访问数据库，加剧数据库压力并且<strong>重复了重建缓存的操作</strong>，一直到线程1结束重建并写入缓存为止（红线），其它线程都会重复这些操作</li>
</ul>
<p><strong>解决办法：</strong></p>
<p><img src="https://s2.loli.net/2022/06/28/487LuPVgajhw1ZT.png" alt="image-20220628184108759"></p>
<ul>
<li><p>互斥锁：</p>
<ul>
<li>线程1缓存未命中后会获取<strong>互斥锁</strong>，然后开始重建缓存操作直到写入缓存，释放锁</li>
<li>线程2在未命中后也会尝试获取<strong>互斥锁</strong>，因为<strong>互斥锁</strong>已被线程1获取，这时候线程2就会<strong>重复：休眠等待，查询缓存，未命中尝试获取互斥锁</strong>这个操作，直到线程1写入缓存释放了锁，这时候线程2缓存命中</li>
<li>特点：<ul>
<li>没有额外的内存消耗（不用存逻辑过期）</li>
<li>若重建缓存时间较长，这段时间其它线程都会被阻塞</li>
<li>牺牲了服务性，维护了数据一致性</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑过期</p>
<ul>
<li>缓存穿透其实就是热点key的ttl失效问题，那我们就不为它设置ttl，而是设置一个逻辑过期时间<ul>
<li>热点key的value额外会存储一个<strong>逻辑过期时间</strong>，<strong>逻辑过期时间过期说明该数据是旧数据，需要更新</strong></li>
<li><img src="https://s2.loli.net/2022/06/28/M2FScUpN9PTORaK.png" alt="image-20220628184709523"></li>
</ul>
</li>
<li>线程1发现逻辑过期时间过期，会尝试获取互斥锁<ul>
<li>获取到互斥锁后线程1不会自己来重建，而是开启一个新线程2来执行重建操作</li>
<li>线程2执行重建操作，在写入缓存后会释放锁</li>
</ul>
</li>
<li>线程3查询缓存发现逻辑过期时间过期，尝试获取互斥锁，发现互斥锁已经被获取了，这时候线程3<strong>不会重复：休眠等待，查询缓存，未命中尝试获取互斥锁</strong>这个操作，而是直接返回缓存中旧的数据（逻辑过期的数据）。</li>
<li>特点：<ul>
<li>因为存了逻辑过期时间，有了额外的内存消耗</li>
<li>服务性较好（返回旧数据），但存在数据一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="①互斥锁"><a href="#①互斥锁" class="headerlink" title="①互斥锁"></a>①互斥锁</h4><p>利用redis.se1tnx来实现互斥锁：</p>
<ul>
<li>因为只有第一个setnx的线程能够成功返回1，这就相当于获得了锁</li>
<li>后来的线程再setnx返回的就是0，这就相当于没获得锁</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/29/3wKx1Dv6IyWVnih.png" alt="image-20220629111733165"></p>
<p><strong>锁操作的方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到锁操作其实很简单：</p>
<ul>
<li>上锁操作就是为传入的key值setnx<ul>
<li>如果返回是true（这里spring data进行了封装，redis中是返回1），说明是第一个，相当于获得了锁</li>
<li>如果返回是false（这里spring data进行了封装，redis中是返回2），说明已经有人获取锁了</li>
</ul>
</li>
<li>解锁操作就是将传入的key值delete，这样下一次setnx就能成功了</li>
</ul>
<p><strong>互斥锁实现方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在，blank：&quot;&quot;,null,&quot;   &quot;都算</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值，如果不是null那就是&quot;&quot;空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当从redis中获得的是null，说明没有该key了，此时需要重建缓存：boolean isLock &#x3D; tryLock(lockKey);</p>
<ul>
<li>false：说明已经有人获取过互斥锁了，重复 <strong>休眠一段时间+重查缓存+获取锁的</strong> 过程，这里是通过递归的方式进行的重复的</li>
</ul>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line"><span class="keyword">if</span> (!isLock)  &#123;</span><br><span class="line">    <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>true：说明是第一个线程，成功获取互斥锁，下一步就是该线程重建缓存</p>
<ul>
<li>上面的代码在数据库没查到的时候存入的””（存空值，防止缓存穿透）</li>
</ul>
</li>
</ul>
<h4 id="②逻辑过期"><a href="#②逻辑过期" class="headerlink" title="②逻辑过期"></a>②逻辑过期</h4><p><img src="https://s2.loli.net/2022/06/29/8w1suehtziyg96d.png" alt="image-20220629115017511"></p>
<p><strong>存入redis添加逻辑过期：</strong></p>
<p><strong>逻辑过期实现方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">querywithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">        <span class="comment">//因为redis中的data是Object，从redis查到后需要先强转(JSONObject)，然后再传入对应的.class反序列化</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信总</span></span><br><span class="line">            <span class="keyword">return</span> shop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    	<span class="comment">//6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span>LOCK_SHOP_KEY + id ;<span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey) ;</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">//这里其实应该再次检查现在的数据是否过期</span></span><br><span class="line">            <span class="comment">// 6.3.成功，从线程池中获取并开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//调用下面的方法，重建缓存</span></span><br><span class="line">                    saveShop2Redis(id,expireSeconds,<span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    <span class="built_in">this</span>.unlock(lockKey) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expireSeconds)</span> &#123;</span><br><span class="line">        <span class="comment">//1.从数据库中查询店铺数据</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//2.封装逻辑过期时间</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">     	<span class="comment">//data就是存入redis的数据</span></span><br><span class="line">        redisData.setData(shop);</span><br><span class="line">     	<span class="comment">//加上逻辑过期时间</span></span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">        <span class="comment">//3.写入Redis，手动序列化</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程1查询缓存发现过期，获取互斥锁成功，从线程池中获取一个线程并开启，实现重建缓存，线程1返回的也是旧数据（过期）<ul>
<li>当获取锁成功后应该再次检查一下，目前的redis中的数据是否过期<ul>
<li>因为可能出现刚构建完缓存释放锁，线程3这时候刚好查询完缓存发现过期并获取锁的情况</li>
<li>这时候cache中的数据已经重建了，但是线程2还是会执行线程重建操作</li>
</ul>
</li>
</ul>
</li>
<li>线程2查询缓存发现过期，获取互斥锁失败，直接返回旧的数据</li>
</ul>
<h3 id="7）封装缓存工具"><a href="#7）封装缓存工具" class="headerlink" title="7）封装缓存工具"></a>7）封装缓存工具</h3><p>用到的工具类pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>cacheClient工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存控制“”过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">CACHE_NULL_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//互斥锁的key的prefix</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_Mutex_KEY</span> <span class="operator">=</span> <span class="string">&quot;lockMutex:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis，通过构造函数传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义线程池，逻辑过期处理缓存击穿使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数传入redis的操作对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往redis存值，存储结构是key-value，并设置真实过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 需要存入redis的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要存入redis的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 设置过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit  时间单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithRealExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往redis存值，存储结构是key-value，并设置逻辑过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 需要存入redis的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要存入redis的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  设置逻辑过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit  时间单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 将存入的数据进行封装，添加上逻辑过期时间: redisData=原本的数据 + 逻辑过期时间</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 手动序列话redisData并存入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取互斥锁，锁就是redis中某特定key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 互斥锁key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功，true:成功，false:失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">//通过setnx来为特定id设置，只有第1个能成功，返回1，spring data封装成了true</span></span><br><span class="line">        <span class="comment">//第2,3,4....来设置会失败，返回0，spring data封装成了false</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放互斥锁，其实就是删除对应key数据，这样下一个新线程来修改就能setnx成功获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 互斥锁key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存&quot;&quot;空值——解决缓存穿透问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPrefix 缓存redis数据的前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 要查询的ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type Result.class，用于反序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbFallback 函数式编程，在缓存查询失败后，根据id查询DB的方法:参数泛型是ID，返回值泛型是Result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Result&gt; 返回值的泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt;  要查询的ID的泛型：因为可能是int型id，也有可能是String型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null：数据库和缓存中没有数据，错误查询 result：返回查询到的具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;Result,ID&gt; Result <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;Result&gt; type, Function&lt;ID, Result&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.拼接缓存的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 2.根据拼接的key从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 3.判断是否存在，blank包括：null，“”，“  ” 这三种情况</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.1缓存命中且有真实数据，根据传入的Result.class反序列化，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.2判断命中的是否是空值：不是null，说明是&quot;&quot;,&quot; &quot;这样的空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回空值说明没有数据，返回null（错误信息）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库：函数式编程，传入了一段逻辑函数</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis并设置空值的过期时间</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.存在，写入redis并设置真实过期时间</span></span><br><span class="line">        <span class="built_in">this</span>.setWithRealExpire(key, result, time, unit);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加逻辑过期时间——解决缓存击穿问题（热点key）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPrefix 缓存redis数据的前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 要查询的ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultType Result.class，用于反序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbFallback 函数式编程，在缓存查询失败后，根据id查询DB的方法:参数泛型是ID，返回值泛型是Result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 逻辑过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Result&gt; 返回值的泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt;  要查询的ID的泛型：因为可能是int型id，也有可能是String型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null：数据库和缓存中没有数据，错误查询 result：返回查询到的具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;Result, ID&gt; Result <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;Result&gt; resultType, Function&lt;ID, Result&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.拼接缓存的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 2.根据拼接的key从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 3.判断是否存在，blank包括：null，“”，“  ” 这三种情况</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">//3.1没有相关数据，直接返回不查数据库</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.2命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="comment">//因为RedisData中封装的data是Object,从redis中查询出的是data是JSONObject，需要先强转</span></span><br><span class="line">        <span class="comment">//强转成JSONObject后再根据传入的Result.class反序列化</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), resultType);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 4.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 5.缓存重建</span></span><br><span class="line">        <span class="comment">// 5.1.根据拼接的id获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_Mutex_KEY +keyPrefix+ id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 5.2.判断是否获取锁成功，因为可能这时候已经有现成重建完毕并返回锁了，cache已经是最新数据了</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//5.3这里还要重查一下redis中数据是否过期</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonCheck</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">                <span class="comment">//3.1没有相关数据，直接返回不查数据库</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.2命中，需要先把json反序列化为对象</span></span><br><span class="line">            <span class="comment">//因为RedisData中封装的data是Object,从redis中查询出的是data是JSONObject，需要先强转</span></span><br><span class="line">            <span class="comment">//强转成JSONObject后再根据传入的Result.class反序列化</span></span><br><span class="line">            <span class="type">RedisData</span> <span class="variable">redisDataCheck</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">resultCheck</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), resultType);</span><br><span class="line">            <span class="type">LocalDateTime</span> <span class="variable">expireTimeCheck</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.判断是否过期</span></span><br><span class="line">            <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">                <span class="comment">// 4.1.未过期，直接返回店铺信息</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5.4.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">Result</span> <span class="variable">newResult</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存,并设置逻辑过期时间</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newResult, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 无论重建成功或失败都释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.无论获取成功还是失败，都返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加逻辑过期时间——解决缓存击穿问题（热点key）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPrefix 缓存redis数据的前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 要查询的ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultType Result.class，用于反序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbFallback 函数式编程，在缓存查询失败后，根据id查询DB的方法:参数泛型是ID，返回值泛型是Result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 真实过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Result&gt; 返回值的泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt;  要查询的ID的泛型：因为可能是int型id，也有可能是String型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null：数据库和缓存中没有数据，错误查询 result：返回查询到的具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;Result, ID&gt; Result <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;Result&gt; resultType, Function&lt;ID, Result&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.拼接缓存的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 2.根据拼接的key从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 3.判断是否存在，blank包括：null，“”，“  ” 这三种情况</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.1缓存命中且有真实数据，根据传入的Result.class反序列化，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, resultType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.2判断命中的是否是空值：不是null，说明是&quot;&quot;,&quot; &quot;这样的空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回空值说明没有数据，返回null（错误信息）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_Mutex_KEY + keyPrefix + id;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试，递归方式重复</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, resultType, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            result = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.setWithRealExpire(key, result, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.重建过后返回新数据</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、分布式缓存"><a href="#三、分布式缓存" class="headerlink" title="三、分布式缓存"></a>三、分布式缓存</h1><h2 id="1-Redis持久化"><a href="#1-Redis持久化" class="headerlink" title="1.Redis持久化"></a>1.Redis持久化</h2><h3 id="1）RDB"><a href="#1）RDB" class="headerlink" title="1）RDB"></a>1）RDB</h3><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<h4 id="①执行时机"><a href="#①执行时机" class="headerlink" title="①执行时机"></a>①执行时机</h4><p>RDB持久化在四种情况下会执行：</p>
<ul>
<li>执行save命令</li>
<li>执行bgsave命令</li>
<li>Redis停机时</li>
<li>触发RDB条件时</li>
</ul>
<p><strong>1）save命令</strong></p>
<p>执行下面的命令，可以立即执行一次RDB：</p>
<img src="https://s2.loli.net/2022/07/16/xeIkw7uiHPDCpt5.png" alt="image-20220712231335058" style="zoom:80%;" />

<p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p>
<p><strong>2）bgsave命令</strong></p>
<p>下面的命令可以异步执行RDB：</p>
<p><img src="https://s2.loli.net/2022/07/16/eadA9SzCD7L2s1w.png" alt="image-20220712231411077"></p>
<p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p>
<p><strong>3）停机时</strong></p>
<ul>
<li>Redis停机时会执行一次save命令，实现RDB持久化<ul>
<li>因为决定要停机了，那么主线程被阻塞了也没关系</li>
</ul>
</li>
</ul>
<p><strong>4）触发RDB条件</strong></p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意满足条件以后，是执行bgsave</li>
</ul>
<p>RDB的其它配置也可以在redis.conf文件中设置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure>



<h4 id="②RDB原理"><a href="#②RDB原理" class="headerlink" title="②RDB原理"></a>②RDB原理</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/RFJNwxuYWj1lXCk.png" alt="image-20220712231744062" style="zoom:80%;" />

<ul>
<li>主进程的页表记录进程中的一页与内存中页框的对应关系，也就是具体的数据的位置</li>
<li>fork就是子进程直接复制了该页表，然后可以通过页表直接找到内存中数据的对应位置</li>
<li>fork采用的是copy-on-write技术<ul>
<li>fork会将共享内存设置为<strong>read-only</strong>只读模式，这就意味着所有线程都只能读不能写</li>
<li>当主线程接收到了写的请求，那么它会将要写的数据进行复制，对复制的数据做修改</li>
<li>而当主线程接收到了读请求，也会读取这个复制的数据</li>
<li>考虑一个极端情况，如果子进程进行RDB的时间过长，这段时间有大量的写请求<ul>
<li>那么所有数据都会进行复制，这样redis就会占用2倍内存，原来是4g，现在就是8g了</li>
<li>因此服务器需要预留一些内存，32g不能都交给redis，否则RDB的时候就可能发生内存溢出</li>
</ul>
</li>
</ul>
</li>
<li>RDB结束后会替换掉旧的RDB文件</li>
</ul>
<h4 id="③RDB间隔"><a href="#③RDB间隔" class="headerlink" title="③RDB间隔"></a>③RDB间隔</h4><ul>
<li>不能过长，否则出现宕机，丢失的数据就太多了</li>
<li>不能太短，比如1s，1次修改就进行RDB，这样重写RDB的时间都不够</li>
</ul>
<h4 id="④缺点"><a href="#④缺点" class="headerlink" title="④缺点"></a>④缺点</h4><ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险<ul>
<li>期间宕机了，会丢失大量数据</li>
</ul>
</li>
<li>fork子进程、压缩、写出RDB文件都比较耗时</li>
</ul>
<h3 id="2）AOF"><a href="#2）AOF" class="headerlink" title="2）AOF"></a>2）AOF</h3><h4 id="①AOF原理"><a href="#①AOF原理" class="headerlink" title="①AOF原理"></a>①AOF原理</h4><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<img src="https://s2.loli.net/2022/07/16/8zxDElYgbQh93rB.png" alt="image-20220712232932971" style="zoom:80%;" />



<h4 id="②AOF配置"><a href="#②AOF配置" class="headerlink" title="②AOF配置"></a>②AOF配置</h4><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure>



<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒通过另外的线程将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>



<p><strong>三种策略对比：</strong></p>
<p><img src="https://s2.loli.net/2022/07/16/djt4QxevTGFEH6Y.png" alt="image-20220712233010485"></p>
<h4 id="③AOF文件重写"><a href="#③AOF文件重写" class="headerlink" title="③AOF文件重写"></a>③AOF文件重写</h4><p>​		因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能（后台另开一个线程），用最少的命令达到相同效果。</p>
<p>​	<img src="https://s2.loli.net/2022/07/16/8oSpivlUrOJIkus.png" alt="image-20220712233228395"></p>
<p>​		</p>
<p>​		如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p>
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p>
<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写，默认也就是说增长1倍的时候重写AOF</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure>



<h3 id="3）RDB与AOF对比"><a href="#3）RDB与AOF对比" class="headerlink" title="3）RDB与AOF对比"></a>3）RDB与AOF对比</h3><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p>
<p><img src="https://s2.loli.net/2022/07/16/nzGWRyAil3EOJjI.png" alt="image-20220712233357438"></p>
<p><strong>RDB：</strong></p>
<ul>
<li>只存数据，并且支持压缩，所以文件大小较小</li>
<li>只存数据，所以开机恢复速度很快</li>
<li>要进行fork操作，另开子线程，要浪费CPU和内存</li>
<li>两次备份间隔数据容易丢失，数据完整性不如AOF</li>
<li>RDB优先级低于AOF</li>
</ul>
<p><strong>AOF：</strong></p>
<ul>
<li>存储的是指令，文件大小较大</li>
<li>存储的是指令，开机恢复的耗时更长</li>
<li>主要是IO操作，但是重写要另开线程执行，也会消耗CPU和内存</li>
<li>数据完整性取决于刷盘策略，完整性较RDB更高</li>
</ul>
<h2 id="2-Redis主从"><a href="#2-Redis主从" class="headerlink" title="2.Redis主从"></a>2.Redis主从</h2><h3 id="1）基本概念"><a href="#1）基本概念" class="headerlink" title="1）基本概念"></a>1）基本概念</h3><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离：</p>
<ul>
<li>Redis大部分都是读多写少，所以主从可以做以下分工<ul>
<li>主节点负责写请求</li>
<li>从节点负责读请求</li>
</ul>
</li>
<li>从节点通过 slaveof [ip] [port] 来连接主节点</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/7NB6z4LFsG18KOk.png" alt="image-20220713120816749" style="zoom:80%;" />

<h3 id="2）全量同步"><a href="#2）全量同步" class="headerlink" title="2）全量同步"></a>2）全量同步</h3><h4 id="①基本原理"><a href="#①基本原理" class="headerlink" title="①基本原理"></a>①基本原理</h4><ul>
<li><p>主从同步涉及以下两个概念：</p>
<ul>
<li><p><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</p>
</li>
<li><p><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p>
</li>
</ul>
</li>
<li><p>slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p>
</li>
</ul>
<p>​		</p>
<p>​		因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。<strong>master判断发现slave发送来的replid与自己的不一致</strong>，说明这是一个全新的slave，就知道要做全量同步了。</p>
<p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p>
<p>​		因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p>
<img src="https://s2.loli.net/2022/07/16/m2oOEHdsfGY4zDg.png" alt="image-20220713120926675" style="zoom:80%;" />



<h4 id="②完整流程"><a href="#②完整流程" class="headerlink" title="②完整流程"></a>②完整流程</h4><p>第一阶段：</p>
<ul>
<li>从节点执行replicof命令向主节点发送自己的repl_id和offset尝试<strong>增量同步</strong><ul>
<li>主节点发现发送来的repl_id和自己的不一样，说明该从节点是第一次做同步，所以不能做增量同步，要做全量同步</li>
</ul>
</li>
<li>主节点向从节点发送自己的repl_id和offset，从节点保存版本信息</li>
</ul>
<p>第二阶段：</p>
<ul>
<li>主节点执行bgsave，开启单独的线程来生成RDB，并发送给从节点<ul>
<li>在主节点RDB的过程中，还会接收写请求，这部分数据以<strong>指令的形式</strong>存在repl_baklog缓存区中（类似AOF记录命令）</li>
</ul>
</li>
<li>从节点接收主节点的RDB，清空本地数据，加载RDB数据<ul>
<li>因为还有rep_baklog的数据，所以目前同步的只是大部分数据</li>
</ul>
</li>
</ul>
<p>第三阶段：</p>
<ul>
<li>主节点向从节点发送rep_baklog，从节点执行rep_baklog的命令，完成同步</li>
</ul>
<h3 id="3）增量同步"><a href="#3）增量同步" class="headerlink" title="3）增量同步"></a>3）增量同步</h3><h4 id="①完整流程"><a href="#①完整流程" class="headerlink" title="①完整流程"></a>①完整流程</h4><p>​		全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>，就是只更新slave与master存在差异的部分数据。如图：</p>
<img src="https://s2.loli.net/2022/07/16/C7kfrJwMz621NVn.png" alt="image-20220713122048319" style="zoom:80%;" />

<p>第一阶段：</p>
<ul>
<li>slave发送repl_id和offset请求增量同步<ul>
<li>master发现repl_id相同，说明不是第一次同步，那么继续</li>
</ul>
</li>
</ul>
<p>第二阶段：</p>
<ul>
<li>master根据slave发送来的offset，发送在rep_baklog中offset后面的命令<ul>
<li>slave执行命令</li>
</ul>
</li>
</ul>
<h4 id="②repl-backlog原理"><a href="#②repl-backlog原理" class="headerlink" title="②repl_backlog原理"></a>②repl_backlog原理</h4><p>master怎么知道slave与自己的数据差异在哪里呢?</p>
<p>这就要说到全量同步时的repl_baklog文件了。</p>
<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖，类似一个环形链表。</p>
<p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p>
<p><img src="https://s2.loli.net/2022/07/16/SxEmyFcMv8Yk3ND.png" alt="image-20220713122250059"></p>
<p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p>
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>
<p><img src="https://s2.loli.net/2022/07/16/MHDPeAWwvJoB4rl.png" alt="image-20220713122821929"></p>
<p>直到数组被填满：</p>
<p><img src="https://s2.loli.net/2022/07/16/HxX9k1Jq3sDpFGa.png" alt="image-20220713122357895"></p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p>
<p><strong>但还有特殊情况：</strong></p>
<p>如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： </p>
<p><img src="https://s2.loli.net/2022/07/16/pjZzxEGBh5cqkyV.png" alt="image-20220713122409765"></p>
<p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p>
<p><img src="https://s2.loli.net/2022/07/16/8HKh7IpB1wic3L2.png" alt="image-20220713122432828"></p>
<p>​	这种情况就是master已经超过slave的offset已经一圈以上了</p>
<p>​	棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p>
<p><img src="https://s2.loli.net/2022/07/16/9GY31por7ASPFqv.png" alt="image-20220713122447937"></p>
<h3 id="4）主从同步优化"><a href="#4）主从同步优化" class="headerlink" title="4）主从同步优化"></a>4）主从同步优化</h3><p>主从从架构图：</p>
<p><img src="https://s2.loli.net/2022/07/16/Og7uYbAfKi1h3LQ.png" alt="image-20220713123041408"></p>
<p>主从同步可以保证主从数据的一致性，非常重要。</p>
<p>可以从以下几个方面来优化Redis主从就集群：</p>
<ul>
<li><p>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</p>
<ul>
<li>省去将RDB写入磁盘过程，直接通过网络进行传输给从节点</li>
<li>可能导致网络拥塞，在网络带宽大、网络情况好的情况下使用，默认是关闭的</li>
</ul>
</li>
<li><p>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</p>
<ul>
<li>8g内存不要让redis占用全部，使Redis整体的数据不要太大，减少RDB大小</li>
</ul>
</li>
<li><p>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</p>
<ul>
<li>这样能够减小master超过slave的offset一圈的情况</li>
</ul>
</li>
<li><p>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</p>
<ul>
<li>主节点给2个slave做同步了后，2个slave再继续给另外的slave同步</li>
</ul>
</li>
</ul>
<h2 id="3-Redis哨兵"><a href="#3-Redis哨兵" class="headerlink" title="3.Redis哨兵"></a>3.Redis哨兵</h2><h3 id="1）集群结构和作用"><a href="#1）集群结构和作用" class="headerlink" title="1）集群结构和作用"></a>1）集群结构和作用</h3><img src="https://s2.loli.net/2022/07/16/SjV5Fdg3brsHzJn.png" alt="image-20220713130843504" style="zoom:80%;" />

<p>哨兵的作用如下：</p>
<ul>
<li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li>
<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li>
<li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<h4 id="①集群监控原理"><a href="#①集群监控原理" class="headerlink" title="①集群监控原理"></a>①集群监控原理</h4><p>Sentinel基于<strong>心跳机制</strong>监测服务状态，<strong>每隔1秒向集群的每个实例发送ping命令</strong>：</p>
<ul>
<li><p><strong>主观下线</strong>：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p>
</li>
<li><p><strong>客观下线</strong>：若超过指定数量（<strong>quorum</strong>）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p>
</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/CeISxMkapn4Hhl6.png" alt="image-20220713131111207" style="zoom:80%;" />



<h4 id="②集群故障恢复原理"><a href="#②集群故障恢复原理" class="headerlink" title="②集群故障恢复原理"></a>②集群故障恢复原理</h4><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p>
<ul>
<li><p>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</p>
<ul>
<li>slave和master长时间断开，那么数据也不是新的，且slave也可能宕机了</li>
</ul>
</li>
<li><p>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</p>
<ul>
<li>默认值都是1，也就是priority是相同的，这个可以配置</li>
</ul>
</li>
<li><p>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</p>
<ul>
<li>选择出一个与master节点差距最小的节点作为新节点</li>
</ul>
</li>
<li><p>最后是判断slave节点的运行id大小，越小优先级越高。</p>
<ul>
<li>run_id就是slave启动的时的id，到这一步其实就是随便选一个了</li>
</ul>
</li>
</ul>
<p>当选出一个新的master后，该如何实现切换呢？</p>
<p>注意：sentinel之间也会选一个老大，让这个老大去执行<strong>通知</strong>和<strong>切换主节点</strong>的操作，就是最先发现问题的sentinel</p>
<p>流程如下：</p>
<ul>
<li>sentinel给备选的slave1节点发送<code>slaveof no one</code>命令，让该节点成为master（加入该节点是7002）</li>
<li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点（7001）</li>
<li><img src="https://s2.loli.net/2022/07/16/2nVL16ASGivr8zT.png" alt="image-20220713131151364" style="zoom: 67%;" /></li>
</ul>
<h4 id="③小结"><a href="#③小结" class="headerlink" title="③小结"></a>③小结</h4><p>Sentinel的三个作用是什么？</p>
<ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<p>Sentinel如何判断一个redis实例是否健康？</p>
<ul>
<li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li>
<li>如果大多数sentinel都认为实例主观下线，则判定服务下线（一般是超过半数）</li>
</ul>
<p>故障转移步骤有哪些？</p>
<ul>
<li>首先选定一个slave作为新的master，执行slaveof no one</li>
<li>然后让所有节点都执行slaveof 新master</li>
<li>修改故障节点配置，添加slaveof 新master</li>
</ul>
<h3 id="2）RedisTemplate配置"><a href="#2）RedisTemplate配置" class="headerlink" title="2）RedisTemplate配置"></a>2）RedisTemplate配置</h3><h4 id="①引入依赖"><a href="#①引入依赖" class="headerlink" title="①引入依赖"></a>①引入依赖</h4><p>在项目的pom文件中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="②配置Redis地址"><a href="#②配置Redis地址" class="headerlink" title="②配置Redis地址"></a>②配置Redis地址</h4><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span> <span class="comment">#这是给master取名字</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27003</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其实就是将所有的sentinel节点都配置上</li>
<li>java客户端其实是不知道具体的redis节点在哪儿，而是通过sentinel来获得的</li>
</ul>
<h4 id="③配置读写分离"><a href="#③配置读写分离" class="headerlink" title="③配置读写分离"></a>③配置读写分离</h4><p>在项目的启动类中，添加一个新的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li>
<li>REPLICA：从slave（replica）节点读取</li>
<li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master<ul>
<li>这是最推荐的</li>
</ul>
</li>
</ul>
<h2 id="4-Redis分片集群"><a href="#4-Redis分片集群" class="headerlink" title="4.Redis分片集群"></a>4.Redis分片集群</h2><h3 id="1）搭建分片集群"><a href="#1）搭建分片集群" class="headerlink" title="1）搭建分片集群"></a>1）搭建分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li><p>海量数据存储问题</p>
</li>
<li><p>高并发写的问题</p>
</li>
</ul>
<p>使用分片集群可以解决上述问题，如图:</p>
<p><img src="https://s2.loli.net/2022/07/16/tIkjEr9ZcyY38QO.png" alt="image-20220713153014386" style="zoom: 80%;" />‘</p>
<p>分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据<ul>
<li>也就是说m1掌控0-50个slots的资源，m2掌控51-100个slots的资源</li>
</ul>
</li>
<li>每个master都可以有多个slave节点<ul>
<li>m1接收50个slots的资源，slaves就负责这50个slots的读操作</li>
</ul>
</li>
<li>master之间通过ping监测彼此健康状态<ul>
<li>这也就是实现了sentienl的机制</li>
</ul>
</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点<ul>
<li>访问到每个结点，每个结点都会根据这个key的有效值来计算，重新去找应该有的节点</li>
</ul>
</li>
</ul>
<h3 id="2）散列插槽"><a href="#2）散列插槽" class="headerlink" title="2）散列插槽"></a>2）散列插槽</h3><h4 id="①基本概念-1"><a href="#①基本概念-1" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p>
<p><img src="https://s2.loli.net/2022/07/16/FyBPLbRxJvMnlgI.png" alt="image-20220713153908890"></p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li>
<li>key中不包含“{}”，整个key都是有效部分</li>
</ul>
<h4 id="②example"><a href="#②example" class="headerlink" title="②example"></a>②example</h4><p>​		key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p>
<p><img src="https://s2.loli.net/2022/07/16/lhwoF9IR2dfXgAD.png" alt="image-20220713154101526"></p>
<p>​		如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到7003节点。</p>
<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p>
<h4 id="③小结-1"><a href="#③小结-1" class="headerlink" title="③小结"></a>③小结</h4><ul>
<li><p>Redis如何判断某个key应该在哪个实例？</p>
<ul>
<li><p>将16384个插槽分配到不同的实例</p>
</li>
<li><p>根据key的有效部分计算哈希值，对16384取余</p>
</li>
<li><p>余数作为插槽，寻找插槽所在实例即可</p>
</li>
</ul>
</li>
<li><p>如何将同一类数据固定的保存在同一个Redis实例？</p>
<ul>
<li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li>
</ul>
</li>
<li><p>为什么key不和主节点绑定而是要和slots绑定</p>
<ul>
<li>redis可能出现主节点宕机，集群伸缩时删除节点的情况，这时候如果key和节点绑定，那么上面的数据就丢失了</li>
<li>如果和slots绑定，我们就可以将这些slots转移到新的节点上<ul>
<li>数据跟着slots走，我们可以很容易地进行数据转移，找到对应数据的位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3）集群伸缩"><a href="#3）集群伸缩" class="headerlink" title="3）集群伸缩"></a>3）集群伸缩</h3><h4 id="①相关命令"><a href="#①相关命令" class="headerlink" title="①相关命令"></a>①相关命令</h4><ul>
<li>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：<ul>
<li>注意一定要–cluster，这样才是集群操作</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/16/AcRHTkvPQKpOM3t.png" alt="image-20220713155123248"></p>
<p>比如，添加节点的命令：</p>
<p><img src="https://s2.loli.net/2022/07/16/k2a6Fhlx9uSfjpm.png" alt="image-20220713155134583"></p>
<h4 id="②需求分析"><a href="#②需求分析" class="headerlink" title="②需求分析"></a>②需求分析</h4><p>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</p>
<ul>
<li>启动一个新的redis实例，端口为7004</li>
<li>添加7004到之前的集群，并作为一个master节点</li>
<li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li>
</ul>
<p>这里需要两个新的功能：</p>
<ul>
<li>添加一个节点到集群中</li>
<li>将部分插槽分配到新插槽<ul>
<li>将num这个key对应的slots分配到7004实例</li>
</ul>
</li>
</ul>
<h4 id="③创建新的redis实例"><a href="#③创建新的redis实例" class="headerlink" title="③创建新的redis实例"></a>③创建新的redis实例</h4><p>创建一个文件夹：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 7004</span><br></pre></td></tr></table></figure>

<p>拷贝配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf /7004</span><br></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed /s/6379/7004/g 7004/redis.conf</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 7004/redis.conf</span><br></pre></td></tr></table></figure>



<h4 id="④添加新节点到redis"><a href="#④添加新节点到redis" class="headerlink" title="④添加新节点到redis"></a>④添加新节点到redis</h4><p>添加节点的语法如下：</p>
<p><img src="https://s2.loli.net/2022/07/16/SrOCslgzB7NAy4W.png" alt="image-20220713155328211"></p>
<p>执行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001</span><br></pre></td></tr></table></figure>

<ul>
<li>注意要加上–cluster</li>
</ul>
<p>通过命令查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>



<p>如图，7004加入了集群，并且默认是一个master节点：</p>
<p><img src="https://s2.loli.net/2022/07/16/RvYTw3HWIjZKybd.png" alt="image-20220713155503355"></p>
<ul>
<li>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</li>
<li>slots还是分配在7001,7002,7003三个节点上，我们需要重新分配key&#x3D;num对应的slots到7004</li>
</ul>
<h4 id="⑤转移插槽"><a href="#⑤转移插槽" class="headerlink" title="⑤转移插槽"></a>⑤转移插槽</h4><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p>
<p><img src="https://s2.loli.net/2022/07/16/RMbmAlp7TNkB8E2.png" alt="image-20220713155635201"></p>
<p>如上图所示，num的插槽为2765.</p>
<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：<img src="https://s2.loli.net/2022/07/16/248Os5SJzaiFZY6.png" alt="image-20220713155655716" style="zoom: 50%;" /></p>
<p>具体流程如下：</p>
<p>建立连接：</p>
<p><img src="https://s2.loli.net/2022/07/16/BuLYkwtIU2Mpb5D.png" alt="image-20220713155724756"></p>
<ul>
<li>随便连接一个主节点，因为集群操作，操作哪一个都是一样的</li>
</ul>
<p>得到下面的反馈：</p>
<img src="https://s2.loli.net/2022/07/16/Bx9wCke52oYDKS3.png" alt="image-20220713155812485" style="zoom:67%;" />

<ul>
<li>询问要移动多少个slots</li>
</ul>
<p>因为key&#x3D;num对应的是2700左右，我们计划是移动7001的前3000个：</p>
<p>新的问题来了：</p>
<img src="https://s2.loli.net/2022/07/16/Iq39EXs6gB5dfwv.png" alt="image-20220713155839442" style="zoom:67%;" />

<p>那个node来接收这些插槽？？</p>
<p>显然是7004，7004节点的id可以如图：</p>
<img src="https://s2.loli.net/2022/07/16/foWjiXe2bKBtmIg.png" alt="image-20220713155942624" style="zoom:80%;" />

<p>复制这个id，然后拷贝到刚才的控制台后：</p>
<img src="https://s2.loli.net/2022/07/16/JFiOMudCRyH4Xph.png" alt="image-20220713160032238" style="zoom: 67%;" />

<p>这里询问，你的插槽是从哪里移动过来的？</p>
<ul>
<li>all：代表全部，也就是三个节点各转移一部分</li>
<li>具体的id：目标节点的id</li>
<li>done：没有了</li>
</ul>
<p>这里我们要从7001获取，因此填写7001的id：</p>
<img src="https://s2.loli.net/2022/07/16/lcNqXrGOhodETzp.png" alt="image-20220713160118715" style="zoom: 67%;" />

<p>填完后，点击done，这样插槽转移就准备好了：</p>
<img src="https://s2.loli.net/2022/07/16/GSjprRFBNnK2asz.png" alt="image-20220713160137299" style="zoom:80%;" />

<p>确认要转移吗？输入yes：</p>
<p>然后，通过命令查看结果：</p>
<p><img src="https://s2.loli.net/2022/07/16/XNQPLtgqVsj28GO.png" alt="image-20220713160155607"></p>
<p>可以看到： </p>
<p><img src="https://s2.loli.net/2022/07/16/MBZbqr5jDXVtU8c.png" alt="image-20220713160214721"></p>
<p>完成了需求</p>
<h3 id="4）故障转移"><a href="#4）故障转移" class="headerlink" title="4）故障转移"></a>4）故障转移</h3><h4 id="①自动故障转移"><a href="#①自动故障转移" class="headerlink" title="①自动故障转移"></a>①自动故障转移</h4><p>当集群中有一个master宕机会发生什么呢？</p>
<p>直接停止一个redis实例，例如7002：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br></pre></td></tr></table></figure>



<p>1）首先是该实例与其它实例失去连接</p>
<p>2）然后是疑似宕机：</p>
<p><img src="https://s2.loli.net/2022/07/16/nAJplMBeu7QdVoR.png" alt="image-20220713160349662"></p>
<p>3）最后是确定下线，自动提升一个slave为新的master：</p>
<p><img src="https://s2.loli.net/2022/07/16/W2wuTsgbmlHfYc3.png" alt="image-20220713160410461"></p>
<p>4）当7002再次启动，就会变为一个slave节点了：</p>
<p><img src="https://s2.loli.net/2022/07/16/ALqExkzwF3vgRXe.png" alt="image-20220713160431690"></p>
<h4 id="②手动故障转移"><a href="#②手动故障转移" class="headerlink" title="②手动故障转移"></a>②手动故障转移</h4><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p>
<p><img src="https://s2.loli.net/2022/07/16/yamIjFi3TEZ2g4C.png" alt="image-20220713160521484"></p>
<p>这种failover命令可以指定三种模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6歩</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li>
</ul>
<h4 id="③example"><a href="#③example" class="headerlink" title="③example"></a>③example</h4><p><strong>案例需求</strong>：</p>
<p>在7002这个slave节点执行手动故障转移，重新夺回master地位</p>
<p><strong>步骤如下：</strong></p>
<p>1）利用redis-cli连接7002这个节点，执行cluster failover命令</p>
<p>​	<img src="https://s2.loli.net/2022/07/16/oqCZ3c2EeDaw6jv.png" alt="image-20220713160714541"></p>
<p>2）结果</p>
<p><img src="https://s2.loli.net/2022/07/16/eiHRGphY8XTngw7.png" alt="image-20220713160820812"></p>
<h3 id="5）RedisTemplate访问分片集群"><a href="#5）RedisTemplate访问分片集群" class="headerlink" title="5）RedisTemplate访问分片集群"></a>5）RedisTemplate访问分片集群</h3><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<h4 id="①引入redis的starter依赖"><a href="#①引入redis的starter依赖" class="headerlink" title="①引入redis的starter依赖"></a>①引入redis的starter依赖</h4><p>在项目的pom文件中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="②配置分片集群地址"><a href="#②配置分片集群地址" class="headerlink" title="②配置分片集群地址"></a>②配置分片集群地址</h4><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意是配置cluster的所有节点，主从都要配置上</li>
</ul>
<p>以下是哨兵模式：</p>
<p>在配置文件application.yml中指定redis的sentinel相关信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span> <span class="comment">#这是给master取名字</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27003</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其实就是将所有的sentinel节点都配置上</li>
<li>java客户端其实是不知道具体的redis节点在哪儿，而是通过sentinel来获得的</li>
</ul>
<h4 id="③配置读写分离-1"><a href="#③配置读写分离-1" class="headerlink" title="③配置读写分离"></a>③配置读写分离</h4><p>在项目的启动类中，添加一个新的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li>
<li>REPLICA：从slave（replica）节点读取</li>
<li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master<ul>
<li>这是最推荐的</li>
</ul>
</li>
</ul>
<h1 id="四、多级缓存"><a href="#四、多级缓存" class="headerlink" title="四、多级缓存"></a>四、多级缓存</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：</p>
<img src="https://s2.loli.net/2022/07/16/pUMchN7sgL3tBzQ.png" alt="image-20220713170337177" style="zoom:80%;" />

<p>存在下面的问题：</p>
<ul>
<li><p>请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</p>
</li>
<li><p>Redis缓存失效时，会对数据库产生冲击</p>
</li>
</ul>
<p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p>
<ul>
<li>浏览器访问静态资源时，优先读取浏览器本地缓存<ul>
<li>游览器会存储大部分静态资源，访问的</li>
<li>访问非静态资源（ajax查询数据）时，访问服务端</li>
</ul>
</li>
<li>请求到达Nginx后，优先读取Nginx本地缓存</li>
<li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）<ul>
<li>基于nginx，使用lua语言去查询redis</li>
</ul>
</li>
<li>如果Redis查询未命中，则查询Tomcat<ul>
<li>请求进入Tomcat后，优先查询JVM进程缓存 caffeine</li>
</ul>
</li>
<li>如果JVM进程缓存未命中，则查询数据库</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/qn8ukopLbIrwU52.png" alt="image-20220713170427165" style="zoom:80%;" />

<p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>（等同于Tomact，使用lua语言操作redis）。</p>
<p>因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：</p>
<img src="https://s2.loli.net/2022/07/16/eDfPRcr5iV8GLYF.png" alt="image-20220713170919647" style="zoom:80%;" />



<p>另外，我们的Tomcat服务将来也会部署为集群模式：</p>
<img src="https://s2.loli.net/2022/07/16/wsvZqeQC2i4u8Xn.png" alt="image-20220713170944307" style="zoom:80%;" />



<p>可见，多级缓存的关键有两个：</p>
<ul>
<li><p>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询</p>
</li>
<li><p>另一个就是在Tomcat中实现JVM进程缓存</p>
</li>
</ul>
<p>其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。</p>
<h2 id="2-JVM进程缓存"><a href="#2-JVM进程缓存" class="headerlink" title="2.JVM进程缓存"></a>2.JVM进程缓存</h2><h3 id="1）Caffeine"><a href="#1）Caffeine" class="headerlink" title="1）Caffeine"></a>1）Caffeine</h3><h4 id="①基本概念-2"><a href="#①基本概念-2" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：</p>
<ul>
<li>分布式缓存，例如Redis：<ul>
<li>优点：存储容量更大、可靠性更好、可以在集群间共享</li>
<li>缺点：访问缓存有网络开销</li>
<li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li>
</ul>
</li>
<li>进程本地缓存，例如HashMap、GuavaCache：<ul>
<li>优点：读取本地内存，没有网络开销，速度更快</li>
<li>缺点：存储容量有限、可靠性较低、无法共享</li>
<li>场景：性能要求较高，缓存数据量较小</li>
</ul>
</li>
</ul>
<p>利用Caffeine框架来实现JVM进程缓存。</p>
<p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p>
<p>Caffeine的性能非常好，下图是官方给出的性能对比：</p>
<img src="https://s2.loli.net/2022/07/16/lYoEGnuHIBsZON7.png" alt="image-20220713171328180" style="zoom: 67%;" />



<p>可以看到Caffeine的性能遥遥领先！</p>
<h4 id="②API及使用"><a href="#②API及使用" class="headerlink" title="②API及使用"></a>②API及使用</h4><p>缓存使用的基本API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicOps</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建cache对象</span></span><br><span class="line">    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存数据</span></span><br><span class="line">    cache.put(<span class="string">&quot;gf&quot;</span>, <span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">gf</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;gf = &quot;</span> + gf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据，包含两个参数：</span></span><br><span class="line">    <span class="comment">// 参数一：缓存的key</span></span><br><span class="line">    <span class="comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultGF</span> <span class="operator">=</span> cache.get(<span class="string">&quot;defaultGF&quot;</span>, key -&gt; &#123;</span><br><span class="line">        <span class="comment">// 根据key去数据库查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;柳岩&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;defaultGF = &quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。</p>
<p>Caffeine提供了三种缓存驱逐策略：</p>
<ul>
<li><p><strong>基于容量</strong>：设置缓存的数量上限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1</span>) <span class="comment">// 设置缓存大小上限为 1</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基于时间</strong>：设置缓存的有效时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    <span class="comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span></span><br><span class="line">    .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>)) </span><br><span class="line">    .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p>
</blockquote>
<h3 id="2）实现JVM进程缓存"><a href="#2）实现JVM进程缓存" class="headerlink" title="2）实现JVM进程缓存"></a>2）实现JVM进程缓存</h3><h4 id="①需求"><a href="#①需求" class="headerlink" title="①需求"></a>①需求</h4><p>利用Caffeine实现下列需求：</p>
<ul>
<li>给根据id查询<strong>商品</strong>的业务添加缓存，缓存未命中时查询数据库</li>
<li>给根据id查询<strong>商品库存</strong>的业务添加缓存，缓存未命中时查询数据库</li>
<li>缓存初始大小为100</li>
<li>缓存上限为10000</li>
</ul>
<h4 id="②实现"><a href="#②实现" class="headerlink" title="②实现"></a>②实现</h4><p>首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。</p>
<p>在item-service的<code>com.heima.item.config</code>包下定义<code>CaffeineConfig</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, Item&gt; <span class="title function_">itemCache</span><span class="params">()</span>&#123;<span class="comment">//查询商品信息</span></span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)<span class="comment">//初始大小</span></span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)<span class="comment">//最大值</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="title function_">stockCache</span><span class="params">()</span>&#123;<span class="comment">//查询商品库存</span></span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>添加缓存逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, ItemStock&gt; stockCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...其它略</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//第一个参数是缓存的key，第二个参数是没有查到缓存后要执行的function</span></span><br><span class="line">        <span class="keyword">return</span> itemCache.get(id, key -&gt; itemService.query()</span><br><span class="line">                .ne(<span class="string">&quot;status&quot;</span>, <span class="number">3</span>).eq(<span class="string">&quot;id&quot;</span>, key)</span><br><span class="line">                .one()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/stock/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ItemStock <span class="title function_">findStockById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stockCache.get(id, key -&gt; stockService.getById(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-Redis预热"><a href="#3-Redis预热" class="headerlink" title="3.Redis预热"></a>3.Redis预热</h2><p>Redis缓存会面临冷启动问题：</p>
<p><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</p>
<p><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</p>
<p>我们数据量较少，并且没有数据统计相关功能，目前可以在启动时将所有数据都放入缓存中。</p>
<p>1）利用Docker安装Redis</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d redis redis-server --appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<p>2）在item-service服务中引入Redis依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3）配置Redis地址</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br></pre></td></tr></table></figure>



<p>4）编写初始化类</p>
<p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。</p>
<p>这里我们利用InitializingBean接口来实现，因为InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.从mysql中查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从mysql中查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-缓存同步"><a href="#4-缓存同步" class="headerlink" title="4.缓存同步"></a>4.缓存同步</h2><h3 id="1）基本策略"><a href="#1）基本策略" class="headerlink" title="1）基本策略"></a>1）基本策略</h3><p>缓存数据同步的常见方式有三种：</p>
<p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p>
<ul>
<li>优势：简单、方便</li>
<li>缺点：时效性差，缓存过期之前可能不一致</li>
<li>场景：更新频率较低，时效性要求低的业务</li>
</ul>
<p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p>
<ul>
<li>优势：时效性强，缓存与数据库强一致</li>
<li>缺点：有代码侵入，耦合度高；</li>
<li>场景：对一致性、时效性要求较高的缓存数据</li>
</ul>
<p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p>
<ul>
<li>优势：低耦合，可以同时通知多个缓存服务</li>
<li>缺点：时效性一般，可能存在中间不一致状态</li>
<li>场景：时效性要求一般，有多个服务需要同步</li>
</ul>
<p>而异步实现又可以基于MQ或者Canal来实现：</p>
<p>①基于MQ的异步通知：</p>
<img src="https://s2.loli.net/2022/07/16/gr5t9Vio7axydJI.png" alt="image-20220713184123867" style="zoom: 80%;" />

<p>解读：</p>
<ul>
<li>商品服务完成对数据的修改后，只需要发送一条消息到MQ中。</li>
<li>缓存服务监听MQ消息，然后完成对缓存的更新</li>
</ul>
<p>依然有少量的代码侵入</p>
<p>②基于Canal的通知</p>
<img src="https://s2.loli.net/2022/07/16/9niega2ykOZGbWD.png" alt="image-20220713184217751" style="zoom: 80%;" />

<p>解读：</p>
<ul>
<li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li>
<li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li>
<li>缓存服务接收到canal通知，更新缓存</li>
</ul>
<p>代码零侵入</p>
<h3 id="2）认识Canal"><a href="#2）认识Canal" class="headerlink" title="2）认识Canal"></a>2）认识Canal</h3><p>**Canal [kə’næl]**，译意为水道&#x2F;管道&#x2F;沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<p>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p>
<p><img src="https://s2.loli.net/2022/07/16/7YO4IzZvSokLp6a.png" alt="image-20210821115914748"></p>
<ul>
<li>1）MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li>
<li>2）MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li>
<li>3）MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li>
</ul>
<p>而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</p>
<img src="https://s2.loli.net/2022/07/16/E52aNkuZ3nSjs8D.png" alt="image-20220713184319382" style="zoom:80%;" />

<p>我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p>
<p>这里使用GitHub上的第三方开源的canal-starter客户端。地址：<a target="_blank" rel="noopener" href="https://github.com/NormanGyllenhaal/canal-client">https://github.com/NormanGyllenhaal/canal-client</a></p>
<p>与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。</p>
<h3 id="3）具体流程"><a href="#3）具体流程" class="headerlink" title="3）具体流程"></a>3）具体流程</h3><h4 id="①引入依赖-1"><a href="#①引入依赖-1" class="headerlink" title="①引入依赖"></a>①引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="②编写配置"><a href="#②编写配置" class="headerlink" title="②编写配置"></a>②编写配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">heima</span> <span class="comment"># canal的集群名字，要与安装canal时设置的名称一致</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:11111</span> <span class="comment"># canal服务地址</span></span><br></pre></td></tr></table></figure>



<h4 id="③修改Item实体类"><a href="#③修改Item实体类" class="headerlink" title="③修改Item实体类"></a>③修改Item实体类</h4><p>通过@Id、@Column、等注解完成Item与数据库表字段的映射：</p>
<img src="https://s2.loli.net/2022/07/16/iTdfkALw7H1IUBQ.png" alt="image-20220713185530493" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Transient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品标题</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">//价格（分）</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//商品图片</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String brand;<span class="comment">//品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">//规格</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;<span class="comment">//商品状态 1-正常，2-下架</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;<span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;<span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="④编写监听器"><a href="#④编写监听器" class="headerlink" title="④编写监听器"></a>④编写监听器</h4><p>通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</p>
<ul>
<li>实现类通过<code>@CanalTable(&quot;tb_item&quot;)</code>指定监听的表信息</li>
<li>EntryHandler的泛型是与表对应的实体类</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/MefLypt1dBQTXrn.png" alt="image-20220713185200551" style="zoom:67%;" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.config.RedisHandler;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CanalTable(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Item&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisHandler redisHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(item.getId(), item);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Item before, Item after)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(after.getId(), after);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(after);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除数据到JVM进程缓存</span></span><br><span class="line">        itemCache.invalidate(item.getId());</span><br><span class="line">        <span class="comment">// 删除数据到redis</span></span><br><span class="line">        redisHandler.deleteItemById(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里对Redis的操作都封装到了RedisHandler这个对象中，是我们之前做缓存预热时编写的一个类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteItemById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;item:id:&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、Redis实践"><a href="#五、Redis实践" class="headerlink" title="五、Redis实践"></a>五、Redis实践</h1><h2 id="1-Redis键值设计"><a href="#1-Redis键值设计" class="headerlink" title="1.Redis键值设计"></a>1.Redis键值设计</h2><h3 id="1）优雅的key结构"><a href="#1）优雅的key结构" class="headerlink" title="1）优雅的key结构"></a>1）优雅的key结构</h3><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p>
<ul>
<li>遵循基本格式：[业务名称]:[数据名]:[id]</li>
<li>长度不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
<p>例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：</p>
<p><img src="https://s2.loli.net/2022/08/10/xZEWf1ps53UAivX.png" alt="image-20220521120213631"></p>
<p>这样设计的好处：</p>
<ul>
<li>可读性强</li>
<li>避免key冲突<ul>
<li>可能多个业务都会用到id，所以需要id</li>
</ul>
</li>
<li>方便管理</li>
<li>更节省内存： key是string类型，底层编码包含intSet、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/ZRzKeaxDY7jrETy.png" alt="image-20220713222935068" style="zoom:80%;" />



<h3 id="2）BigKey"><a href="#2）BigKey" class="headerlink" title="2）BigKey"></a>2）BigKey</h3><h4 id="①基本概念-3"><a href="#①基本概念-3" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>BigKey指的是一条记录很大，和这一条的value有关，并只是说key很大！</p>
<p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p>
<ul>
<li>Key本身的数据量过大：一个String类型的Key，它的value为 5MB</li>
<li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</li>
<li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</li>
</ul>
<p>那么如何判断元素的大小呢？redis也给我们提供了命令</p>
<p><img src="https://s2.loli.net/2022/07/16/TdXiGZ9SjqNEHbB.png" alt="image-20220713223327466"></p>
<p>推荐值：</p>
<ul>
<li>单个key的value小于<strong>10KB</strong></li>
<li>对于集合类型的key，建议元素数量小于<strong>1000</strong></li>
</ul>
<h4 id="②BigKey的危害"><a href="#②BigKey的危害" class="headerlink" title="②BigKey的危害"></a>②BigKey的危害</h4><ul>
<li>网络阻塞<ul>
<li>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li>
</ul>
</li>
<li>数据倾斜<ul>
<li>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li>
<li>分片集群，每个集群的slots都是均分的，但是Bigkey所在的Redis的内存使用率更远超其它的实例</li>
</ul>
</li>
<li>Redis阻塞<ul>
<li>对元素较多的hash、list、zset等做运算会耗时较长，使主线程被阻塞</li>
<li>比如做diff等操作都会耗时较长</li>
</ul>
</li>
<li>CPU压力<ul>
<li>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li>
</ul>
</li>
</ul>
<h4 id="③如何发现BigKey"><a href="#③如何发现BigKey" class="headerlink" title="③如何发现BigKey"></a>③如何发现BigKey</h4><h5 id="a）redis-cli-–bigkeys"><a href="#a）redis-cli-–bigkeys" class="headerlink" title="a）redis-cli –bigkeys"></a>a）redis-cli –bigkeys</h5><p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</p>
<p>命令：<code>redis-cli -a 密码 --bigkeys</code></p>
<img src="https://s2.loli.net/2022/07/16/rFg8A5cQTqYZDwm.png" alt="image-20220713224835225" style="zoom: 80%;" />



<h5 id="b）scan扫描"><a href="#b）scan扫描" class="headerlink" title="b）scan扫描"></a>b）scan扫描</h5><p>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）</p>
<p><img src="https://s2.loli.net/2022/07/16/uEQ2ziembC6rK1f.png" alt="image-20220713225723480"></p>
<p>scan 命令调用完后每次会返回2个元素，第一个是下一次迭代的光标，第一次光标会设置为0，当最后一次scan 返回的光标等于0时，表示整个scan遍历结束了，第二个返回的是List，一个匹配的key的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STR_MAX_LEN</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">HASH_MAX_LEN</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testScan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描并获取一部分key</span></span><br><span class="line">            ScanResult&lt;String&gt; result = jedis.scan(cursor);</span><br><span class="line">            <span class="comment">// 记录cursor</span></span><br><span class="line">            cursor = result.getCursor();</span><br><span class="line">            List&lt;String&gt; list = result.getResult();</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">                <span class="comment">// 判断key的类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> jedis.type(key);</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">                        len = jedis.strlen(key);</span><br><span class="line">                        maxLen = STR_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;hash&quot;</span>:</span><br><span class="line">                        len = jedis.hlen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                        len = jedis.llen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">                        len = jedis.scard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;zset&quot;</span>:</span><br><span class="line">                        len = jedis.zcard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt;= maxLen) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;Found big key : %s, type: %s, length or size: %d %n&quot;</span>, key, type, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!cursor.equals(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="c）第三方工具"><a href="#c）第三方工具" class="headerlink" title="c）第三方工具"></a>c）第三方工具</h5><ul>
<li>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况</li>
<li><a target="_blank" rel="noopener" href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></li>
</ul>
<h5 id="d）网络监控"><a href="#d）网络监控" class="headerlink" title="d）网络监控"></a>d）网络监控</h5><ul>
<li>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</li>
<li>一般阿里云搭建的云服务器就有相关监控页面</li>
</ul>
<h4 id="④如何删除BigKey"><a href="#④如何删除BigKey" class="headerlink" title="④如何删除BigKey"></a>④如何删除BigKey</h4><p>BigKey内存占用较多，即便是删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p>
<ul>
<li>redis 3.0 及以下版本<ul>
<li>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey</li>
<li><img src="https://s2.loli.net/2022/07/16/ytxNWhp2v9kETnd.png" alt="image-20220713225916147"></li>
</ul>
</li>
</ul>
<ul>
<li><p>Redis在4.0后提供了异步删除的命令：unlink </p>
<p><img src="https://s2.loli.net/2022/07/16/g2jriIcMvlQFy3u.png" alt="image-20220713225958139"></p>
</li>
</ul>
<h3 id="3）恰当的数据类型"><a href="#3）恰当的数据类型" class="headerlink" title="3）恰当的数据类型"></a>3）恰当的数据类型</h3><h4 id="①存储User对象"><a href="#①存储User对象" class="headerlink" title="①存储User对象"></a>①存储User对象</h4><h5 id="a）方式一：json字符串"><a href="#a）方式一：json字符串" class="headerlink" title="a）方式一：json字符串"></a>a）方式一：json字符串</h5><table>
<thead>
<tr>
<th align="center">user:1</th>
<th align="center">{“name”: “Jack”, “age”: 21}</th>
</tr>
</thead>
</table>
<p>优点：实现简单粗暴</p>
<p>缺点：数据耦合，不够灵活，不能修改user的某一个field</p>
<h5 id="b）方式二：字段打散"><a href="#b）方式二：字段打散" class="headerlink" title="b）方式二：字段打散"></a>b）方式二：字段打散</h5><table>
<thead>
<tr>
<th align="center">user:1:name</th>
<th align="center">Jack</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user:1:age</td>
<td align="center">21</td>
</tr>
</tbody></table>
<p>优点：可以灵活访问对象任意字段</p>
<p>缺点：占用空间大、没办法做统一控制，不能对一个user的整体数据做操作</p>
<h5 id="c）方式三：hash（推荐）"><a href="#c）方式三：hash（推荐）" class="headerlink" title="c）方式三：hash（推荐）"></a>c）方式三：hash（推荐）</h5><table>
    <tr>
        <td rowspan="2">user:1</td>
        <td>name</td>
        <td>jack</td>
    </tr>
    <tr>
        <td>age</td>
        <td>21</td>
    </tr>
</table>


<p>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段</p>
<p>缺点：代码相对复杂，有工具类可以实现</p>
<h4 id="②优化超大hash"><a href="#②优化超大hash" class="headerlink" title="②优化超大hash"></a>②优化超大hash</h4><p>假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>field</td>
        <td>value</td>
    </tr>
    <tr>
        <td rowspan="3">someKey</td>
        <td>id:0</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:999999</td>
        <td>value999999</td>
    </tr>
</table>


<p>存在的问题：</p>
<ul>
<li>hash的entry数量超过500时，会使用<strong>哈希表</strong>Dict而不是<strong>ZipList</strong>，内存占用较多</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/LpI6nqa9MVe7rSx.png" alt="image-20220714112546292" style="zoom:80%;" />



<h5 id="a）方案一"><a href="#a）方案一" class="headerlink" title="a）方案一"></a>a）方案一</h5><p>拆分为string类型</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>value</td>
    </tr>
    <tr>
        <td>id:0</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:999999</td>
        <td>value999999</td>
    </tr>
</table>


<p>存在的问题：</p>
<ul>
<li>string结构底层没有太多内存优化，内存占用较多</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/gBXiV8461xQrWnO.png" alt="image-20220714112637577" style="zoom:80%;" />

<ul>
<li>想要批量获取这些数据比较麻烦</li>
</ul>
<h5 id="b）方案二"><a href="#b）方案二" class="headerlink" title="b）方案二"></a>b）方案二</h5><p>拆分为小的hash，将 id &#x2F; 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>field</td>
        <td>value</td>
    </tr>
    <tr>
        <td rowspan="3">key:0</td>
        <td>id:00</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value99</td>
    </tr>
    <tr>
        <td rowspan="3">key:1</td>
        <td>id:00</td>
        <td>value100</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value199</td>
    </tr>
    <tr>
        <td colspan="3">....</td>
    </tr>
    <tr>
        <td rowspan="3">key:9999</td>
        <td>id:00</td>
        <td>value999900</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value999999</td>
    </tr>
</table>

<ul>
<li>key&#x3D;1中的数据就相当于key+field&#x3D;（1+0）<del>（1+99）&#x3D;101</del>199条数据，value则是对应的值</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/16/PuOlxYv2zKpAUsc.png" alt="image-20220521144339377"></p>
<h5 id="c）test"><a href="#c）test" class="headerlink" title="c）test"></a>c）test</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSetBigKey</span><span class="params">()</span> &#123; <span class="comment">//BigKey</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">650</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;hello_&quot;</span> + i, <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;m2&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigHash</span><span class="params">()</span> &#123; <span class="comment">//超大hash</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;test:big:hash&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigString</span><span class="params">()</span> &#123; <span class="comment">//打散存入str中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;test:str:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSmallHash</span><span class="params">()</span> &#123; <span class="comment">//打散存入小的hash中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hashSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(hashSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (i - <span class="number">1</span>) / hashSize;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> i % hashSize;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + v, <span class="string">&quot;value_&quot;</span> + v);</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">                jedis.hmset(<span class="string">&quot;test:small:hash_&quot;</span> + k, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4）小结"><a href="#4）小结" class="headerlink" title="4）小结"></a>4）小结</h3><ul>
<li>Key的最佳实践<ul>
<li>固定格式：[业务名]:[数据名]:[id]</li>
<li>足够简短：不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
</li>
<li>Value的最佳实践：<ul>
<li>合理的拆分数据，拒绝BigKey</li>
<li>选择合适数据结构</li>
<li>Hash结构的entry数量不要超过1000</li>
<li>设置合理的超时时间</li>
</ul>
</li>
</ul>
<h2 id="2-批处理优化"><a href="#2-批处理优化" class="headerlink" title="2.批处理优化"></a>2.批处理优化</h2><h3 id="1）客户端与redis交互"><a href="#1）客户端与redis交互" class="headerlink" title="1）客户端与redis交互"></a>1）客户端与redis交互</h3><h4 id="①单个命令的执行流程"><a href="#①单个命令的执行流程" class="headerlink" title="①单个命令的执行流程"></a>①单个命令的执行流程</h4><p><img src="https://s2.loli.net/2022/07/16/SXqs2gzke8EFntb.png" alt="image-20220714121727477"></p>
<h4 id="②N条命令的执行流程"><a href="#②N条命令的执行流程" class="headerlink" title="②N条命令的执行流程"></a>②N条命令的执行流程</h4><p><img src="https://s2.loli.net/2022/07/16/av9DgPc7zUMSOwe.png" alt="image-20220714121800149"></p>
<ul>
<li>redis执行命令的速度是非常快的，所以大部分时间都花在了网络传输，我们可以想办法减少网络传输时间</li>
</ul>
<h4 id="③批处理"><a href="#③批处理" class="headerlink" title="③批处理"></a>③批处理</h4><p><img src="https://s2.loli.net/2022/07/16/jFAqLOyfdDvzgaQ.png" alt="image-20220714121858851"></p>
<ul>
<li>批处理的一次指令中包含了n个指令，但批处理指令是通过一次网络传输<ul>
<li>虽然批处理可以减少网络传输时间，但要注意一次批处理指令的大小<ul>
<li>如共mset了100,000次插入数据，虽然可以一次传输过去，但是这样可能会大量占用某时刻带宽，造成网络拥塞</li>
<li>我们可以分批，如循环100次批处理命令，一次批处理1000条</li>
<li>这样虽然多了一些网络传输耗时，但是减轻了带宽负担</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2）mset"><a href="#2）mset" class="headerlink" title="2）mset"></a>2）mset</h3><h4 id="①example"><a href="#①example" class="headerlink" title="①example"></a>①example</h4><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：</p>
<ul>
<li>mset</li>
<li>hmset</li>
</ul>
<p>利用mset批量插入10万条数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMxx</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2000</span>]; </span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        j = (i % <span class="number">1000</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">//最开始的1-1000个就是2,4,6,...,0</span></span><br><span class="line">        arr[j] = <span class="string">&quot;test:key_&quot;</span> + i;<span class="comment">//2,4,6,....,0</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = <span class="string">&quot;value_&quot;</span> + i;<span class="comment">//3,5,7,.....,1</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            jedis.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意通过String数组来传String类型的key-value的时候需要array是[key1],[value],[key2],[value]这样挨着的</li>
<li>mxxx作为redis内置命令，是可以保证原子性的</li>
</ul>
<h4 id="②缺点"><a href="#②缺点" class="headerlink" title="②缺点"></a>②缺点</h4><ul>
<li><p>String有mset，hash有hmset</p>
<ul>
<li>但hmset也只是能改变同一个key的field，不能传不同的key</li>
</ul>
</li>
<li><p>LPUSH key  element….，也只是能传一个key的不同node_element，并不能传不同点key</p>
</li>
<li><p>以上缺点，考虑Pipeline来解决</p>
</li>
</ul>
<h3 id="3）单机Pipeline"><a href="#3）单机Pipeline" class="headerlink" title="3）单机Pipeline"></a>3）单机Pipeline</h3><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();<span class="comment">//通过jedis获得的Pipeline</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 放入命令到管道</span></span><br><span class="line">        pipeline.set(<span class="string">&quot;test:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将管道中的1000条命令，一次性发送到redis然后批量执行</span></span><br><span class="line">            pipeline.sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Pipeline管道和操作系统类似，客户端设置了一个缓冲区接收一组指令，Redis实例设置了一个缓冲区来接收这一组指令并执行</li>
<li>除了pipeline.set，还可以pipeline.hset()</li>
<li>注意：管道是不能保证原子性的<ul>
<li>将1000条指令通过管道放入redis的缓冲区以后，这1000条指令会在redis的执行队列排队，并不能保证这1000条指令中插入其它的指令</li>
</ul>
</li>
</ul>
<h3 id="4）集群下的批处理"><a href="#4）集群下的批处理" class="headerlink" title="4）集群下的批处理"></a>4）集群下的批处理</h3><h4 id="①基本策略"><a href="#①基本策略" class="headerlink" title="①基本策略"></a>①基本策略</h4><p>​	 如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。大家可以想一想这样的要求其实很难实现，因为我们在批处理时，可能一次要插入很多条数据，这些<code>数据很有可能不会都落在相同的节点上（不同slot）</code>，这就会导致报错了</p>
<p>这个时候，我们可以找到4种解决方案：</p>
<p><img src="https://s2.loli.net/2022/07/16/HqUkSThN1y32VG5.png" alt="image-20220714124045211"></p>
<ul>
<li><p>第一种方案</p>
<ul>
<li>串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</li>
<li>其实就相当于没有批处理</li>
</ul>
</li>
<li><p>第二种方案</p>
<ul>
<li>串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</li>
</ul>
</li>
<li><p>第三种方案</p>
<ul>
<li>并行slot，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了多线程并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</li>
</ul>
</li>
<li><p>第四种方案</p>
<ul>
<li>hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。</li>
<li>如<code>&#123;a&#125;name yy</code>，<code>&#123;a&#125;age 11</code>，这样通过key计算slot的时候是根据a计算的</li>
</ul>
</li>
</ul>
<h4 id="②串行化执行代码实践"><a href="#②串行化执行代码实践" class="headerlink" title="②串行化执行代码实践"></a>②串行化执行代码实践</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        HashSet&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7003</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8003</span>));</span><br><span class="line">        jedisCluster = <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes, poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet</span><span class="params">()</span> &#123;</span><br><span class="line">        jedisCluster.mset(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet2</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Male&quot;</span>);</span><br><span class="line">        <span class="comment">//对Map数据进行分组，根据entry.getKey来计算slot，相同slot放在一个分组</span></span><br><span class="line">        <span class="comment">//key就是slot，value就是一个组</span></span><br><span class="line">        Map&lt;Integer, List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; result = map.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.groupingBy(</span><br><span class="line">                        entry -&gt; ClusterSlotHashUtil.calculateSlot(entry.getKey()))</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">//串行的去执行mset的逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Map.Entry&lt;String, String&gt;&gt; list : result.values()) &#123;</span><br><span class="line">            String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[list.size() * <span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                j = i&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                Map.Entry&lt;String, String&gt; e = list.get(<span class="number">0</span>);</span><br><span class="line">                arr[j] = e.getKey();</span><br><span class="line">                arr[j + <span class="number">1</span>] = e.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            jedisCluster.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisCluster != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②Spring中lettuce处理"><a href="#②Spring中lettuce处理" class="headerlink" title="②Spring中lettuce处理"></a>②Spring中lettuce处理</h4><p>集群环境下批处理代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">testMSetInCluster</span><span class="params">()</span> &#123;</span><br><span class="line">     Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">     map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Female&quot;</span>);</span><br><span class="line">     stringRedisTemplate.opsForValue().multiSet(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; strings = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">     strings.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理分析</strong>：</p>
<p>整体就是方案基本策略中<strong>方案3</strong>的思想</p>
<p>在RedisAdvancedClusterAsyncCommandsImpl 类中</p>
<p>首先根据slotHash算出来一个partitioned的map，map中的key就是slot，而他的value就是对应的对应相同slot的key对应的数据</p>
<p>通过 RedisFuture&lt; String &gt; mset &#x3D; super.mset(op);进行异步的消息发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RedisFuture&lt;String&gt; <span class="title function_">mset</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, map.keySet());<span class="comment">//计算slot分组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioned.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.mset(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, RedisFuture&lt;String&gt;&gt; executions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;K, V&gt; op = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        entry.getValue().forEach(k -&gt; op.put(k, map.get(k)));</span><br><span class="line"></span><br><span class="line">        RedisFuture&lt;String&gt; mset = <span class="built_in">super</span>.mset(op);<span class="comment">//可以看到是异步执行的</span></span><br><span class="line">        executions.put(entry.getKey(), mset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiNodeExecution.firstOfAsync(executions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-服务器端优化"><a href="#3-服务器端优化" class="headerlink" title="3.服务器端优化"></a>3.服务器端优化</h2><h3 id="1）持久化配置"><a href="#1）持久化配置" class="headerlink" title="1）持久化配置"></a>1）持久化配置</h3><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p>
<ul>
<li><p>用来做缓存的Redis实例尽量不要开启持久化功能</p>
<ul>
<li>因为缓存并不需要高安全性，禁用持久化可以提升性能</li>
</ul>
</li>
<li><p>建议关闭RDB持久化功能，使用AOF持久化</p>
<ul>
<li>RDB采用<strong>fork</strong>和<strong>copy-on-write</strong>，会消耗大量内存和cpu</li>
</ul>
</li>
<li><p>利用脚本定期在slave节点做RDB，实现数据备份</p>
<ul>
<li>RDB关闭后我们可以手动的在从节点上做数据备份</li>
</ul>
</li>
<li><p>设置合理的rewrite阈值，避免频繁的bgrewrite</p>
<ul>
<li>bgrewrite会进行内存读写、消耗CPU资源(计算哪些指令可以合并或删除)</li>
</ul>
</li>
<li><p>配置no-appendfsync-on-rewrite &#x3D; yes，禁止在rewrite期间做aof刷盘，避免因AOF引起的阻塞</p>
<img src="https://s2.loli.net/2022/07/16/uOi2xTI7LXReCy3.png" alt="具体过程" style="zoom: 67%;" />

<ul>
<li>fsync就是刷盘时间，如果超过2s，那么redis会认为刷盘有问题，主线程阻塞不再接收新命令并等待刷盘完成</li>
<li>rewrite和RDB的fork会涉及到大量IO，就可能导致aof的fsync阻塞，导致redis阻塞</li>
<li>要想安全性，在rewrite期间做持久化，开启；要想性能，关闭</li>
</ul>
</li>
<li><p>部署有关建议：</p>
<ul>
<li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li>
<li>单个Redis实例内存上限不要太大，例如4G或8G<ul>
<li>单个Redis内存小，意味着可以加快fork的速度、减少主从同步、数据迁移压力</li>
</ul>
</li>
<li>不要与CPU密集型应用部署在一起<ul>
<li>如elasticsearch全文搜索</li>
</ul>
</li>
<li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li>
</ul>
</li>
</ul>
<h3 id="2）服务器端优化-慢查询优化"><a href="#2）服务器端优化-慢查询优化" class="headerlink" title="2）服务器端优化-慢查询优化"></a>2）服务器端优化-慢查询优化</h3><h4 id="①什么是慢查询"><a href="#①什么是慢查询" class="headerlink" title="①什么是慢查询"></a>①什么是慢查询</h4><p>并不是很慢的查询才是慢查询，而是：在Redis执行时耗时超过某个阈值的<strong>命令</strong>，称为慢查询，所以get、set也可能是慢查询。</p>
<p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞在queue，从而引起报错，所以我们需要解决慢查询问题。</p>
<ul>
<li><p>引起慢查询的原因</p>
<ul>
<li>如keys * 这种命令本身性质就会引发慢查询</li>
<li>查询到了一个bigkey，如一个集合放了超过1000个成员</li>
<li>……</li>
</ul>
</li>
</ul>
<h4 id="②慢查询相关配置"><a href="#②慢查询相关配置" class="headerlink" title="②慢查询相关配置"></a>②慢查询相关配置</h4><ul>
<li><p>慢查询的阈值可以通过配置指定：</p>
<ul>
<li>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</li>
</ul>
</li>
<li><p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p>
<ul>
<li>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/FlSGEpHhudUcbnI.png" alt="image-20220714131635087" style="zoom:80%;" />

<ul>
<li>修改这两个配置可以使用：config set命令：</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/JLM952IEvDakpxn.png" alt="image-20220714131718817" style="zoom:80%;" />

<ul>
<li>注意这些都是动态配置重启后就没有了，持久配置需要在config文件中配置</li>
</ul>
<h4 id="③如何查看慢查询"><a href="#③如何查看慢查询" class="headerlink" title="③如何查看慢查询"></a>③如何查看慢查询</h4><ul>
<li>slowlog len：查询慢查询日志长度</li>
<li>slowlog get [n]：读取n条慢查询日志</li>
<li>slowlog reset：清空慢查询列表</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/16/m6LKxuVYIq5S42N.png" alt="image-20220714132258636"></p>
<h3 id="3）敏感命令及安全配置"><a href="#3）敏感命令及安全配置" class="headerlink" title="3）敏感命令及安全配置"></a>3）敏感命令及安全配置</h3><p>安全可以说是服务器端一个非常重要的话题，如果安全出现了问题，那么一旦这个漏洞被一些坏人知道了之后，并且进行攻击，那么这就会给咱们的系统带来很多的损失，所以我们这节课就来解决这个问题。</p>
<p>Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞.<br>漏洞重现方式：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1039000">https://cloud.tencent.com/developer/article/1039000</a></p>
<p>为什么会出现不需要密码也能够登录呢，主要是linux考虑到每次登录都比较麻烦，所以linux就有一种ssh免秘钥登录的方式，生成一对公钥和私钥，私钥放在本地，公钥放在linux端，当我们登录时服务器，再登录时候，他会去解析公钥和私钥，如果没有问题，则不需要利用linux的登录也能访问，这种做法本身也很常见，但是这里有一个前提，前提就是公钥必须保存在服务器上，才行，但是linux的漏洞在于在不登录的情况下，也能把秘钥送到linux服务器，从而产生漏洞</p>
<p>漏洞出现的核心的原因有以下几点：</p>
<ul>
<li>Redis未设置密码</li>
<li>利用了Redis的config set命令动态修改Redis配置，RDB文件的位置</li>
<li>使用了Root账号权限启动Redis</li>
</ul>
<p>所以：如何解决呢？我们可以采用如下几种方案</p>
<p>为了避免这样的漏洞，这里给出一些建议：</p>
<ul>
<li>Redis一定要设置密码</li>
<li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li>
<li>bind：限制网卡，禁止外网网卡访问</li>
<li>开启防火墙</li>
<li>不要使用Root账户启动Redis</li>
<li>尽量不是有默认的端口</li>
</ul>
<h3 id="4）Redis内存划分和内存配置"><a href="#4）Redis内存划分和内存配置" class="headerlink" title="4）Redis内存划分和内存配置"></a>4）Redis内存划分和内存配置</h3><h4 id="①基本问题"><a href="#①基本问题" class="headerlink" title="①基本问题"></a>①基本问题</h4><table>
<thead>
<tr>
<th><strong>内存占用</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据内存</td>
<td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td>
</tr>
<tr>
<td>进程内存</td>
<td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td>
</tr>
<tr>
<td>缓冲区内存</td>
<td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td>
</tr>
</tbody></table>
<p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p>
<p><strong>数据内存中碎片问题分析</strong></p>
<p>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</p>
<p><strong>进程内存问题分析：</strong></p>
<p>这片内存通常是固定的，并且很小，我们可以忽略不计</p>
<p><strong>缓冲区内存问题分析：</strong></p>
<p>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，所以这片内存也是我们需要重点分析的内存问题。</p>
<h4 id="②相关命令"><a href="#②相关命令" class="headerlink" title="②相关命令"></a>②相关命令</h4><p>我们通过一些命令，可以查看到Redis目前的内存分配状态：</p>
<ul>
<li>info memory：查看内存分配的情况</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/jZwqa7gCHvKWRLl.png" alt="1653132073570" style="zoom:80%;" />

<ul>
<li>memory xxx：查看key的主要占用情况</li>
</ul>
<img src="https://s2.loli.net/2022/07/16/yjC29HSIvlEY1DN.png" alt="1653132098823" style="zoom:80%;" />



<h4 id="③缓冲区内存"><a href="#③缓冲区内存" class="headerlink" title="③缓冲区内存"></a>③缓冲区内存</h4><p>接下来我们看到了这些配置，最关键的缓存区内存如何定位和解决呢？</p>
<p>内存缓冲区常见的有三种：</p>
<ul>
<li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li>
<li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li>
<li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li>
</ul>
<p>以上缓冲区中 **复制缓冲区 **和 <strong>AOF缓冲区</strong> 不会有问题，最关键就是客户端缓冲区的问题</p>
<p>​		客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，<strong>输入缓冲区最大1G且不能设置</strong>，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p>
<p><img src="https://s2.loli.net/2022/07/16/a8hzlGip9jkOdNs.png" alt="1653132410073"></p>
<p>​		我们在使用redis过程中，处理大量的big value，那么会导致我们的输出结果过多，如果输出缓存区过大，会导致redis直接断开，而默认配置的情况下， 其实它是没有大小的，内存可能一下子被占满，会直接导致redis断开，所以解决方案有两个</p>
<ul>
<li><p>设置输出缓冲区的大小</p>
</li>
<li><p>增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p>
</li>
</ul>
<h3 id="5）集群优化-集群还是主从"><a href="#5）集群优化-集群还是主从" class="headerlink" title="5）集群优化-集群还是主从"></a>5）集群优化-集群还是主从</h3><h4 id="①分片集群的问题"><a href="#①分片集群的问题" class="headerlink" title="①分片集群的问题"></a>①分片集群的问题</h4><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p>
<ul>
<li>集群完整性问题</li>
<li>集群带宽问题</li>
<li>数据倾斜问题</li>
<li>客户端性能问题</li>
<li>命令的集群兼容性问题</li>
<li>lua和事务问题</li>
</ul>
<p><strong>问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</strong> </p>
<p>大家可以设想一下，如果有几个slot不能使用，那么此时整个集群都不能用了，我们在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，我们的redis集群还是可以对外提供服务</p>
<p><img src="https://s2.loli.net/2022/07/16/1RBCv2xcw69PI7Y.png" alt="image-20220714143754657"></p>
<ul>
<li>shutdown 了一个节点的主从，那么这部分slots就没办法用了，这也会导致集群的down，尽管set的key计算出来的slots是在其它节点上，仍然会执行失败</li>
</ul>
<p><strong>解决途径：</strong></p>
<p>修改集群的配置文件：<code>cluster-require-full-coverage no //原来是yes</code></p>
<ul>
<li>这样就能在某一个节点down的时候，其它节点还能使用<ul>
<li>slots在其它节点仍可以进行操作，slots在down的节点还是不能操作</li>
</ul>
</li>
</ul>
<p><strong>问题2、集群带宽问题</strong></p>
<p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p>
<ul>
<li>插槽信息</li>
<li>集群状态信息</li>
</ul>
<p>​		集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p>
<p><strong>解决途径：</strong></p>
<ul>
<li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li>
<li>避免在单个物理机中运行太多Redis实例<ul>
<li>1个Redis实例ping100个，那么10个就会ping1000个</li>
</ul>
</li>
<li>配置合适的cluster-node-timeout值，也就是集群间心跳检测主观认为down的，ping的时间就是这个值的一半<ul>
<li>适量调高，可以减少ping的频率</li>
<li>如果太高会导致redis集群检测故障的能力降低</li>
</ul>
</li>
</ul>
<p><strong>问题3、命令的集群兼容性问题</strong></p>
<p>​		有关这个问题咱们已经探讨过了，当我们使用批处理的命令时，redis要求我们的key必须落在相同的slot上，然后大量的key同时操作时，是无法完成的，所以客户端必须要对这样的数据进行处理，推荐并行按slots分组，lettuce已经实现了。</p>
<p><strong>问题4、lua和事务的问题</strong></p>
<p>​		lua和事务都是要保证原子性问题，如果你的key对应的slots不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的。</p>
<h4 id="②到底是集群还是主从？"><a href="#②到底是集群还是主从？" class="headerlink" title="②到底是集群还是主从？"></a>②到底是集群还是主从？</h4><p>​		单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群。</p>
<h1 id="六、Redis原理"><a href="#六、Redis原理" class="headerlink" title="六、Redis原理"></a>六、Redis原理</h1><h2 id="1-Redis底层数据结构"><a href="#1-Redis底层数据结构" class="headerlink" title="1.Redis底层数据结构"></a>1.Redis底层数据结构</h2><h3 id="1）动态字符串：SDS"><a href="#1）动态字符串：SDS" class="headerlink" title="1）动态字符串：SDS"></a>1）动态字符串：SDS</h3><h4 id="①基本概念-4"><a href="#①基本概念-4" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。</p>
<p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：</p>
<ul>
<li>获取字符串长度的需要通过运算</li>
<li>非二进制安全</li>
<li>不可修改</li>
</ul>
<p>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。<br>  例如，我们执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set name yy</span><br></pre></td></tr></table></figure>

<p>那么Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“yy”的SDS。</p>
<p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p>
<p><img src="https://s2.loli.net/2022/07/16/Qsy6OclGdIohtSw.png" alt="image-20220714162848542"></p>
<ul>
<li>因为redis中定义了不同的SDS，他们能接受的char[]数组上限也不一样，比如SDS8就代表接收2^8的char.length</li>
</ul>
<p>例如，一个包含字符串“name”的sds结构如下：</p>
<p><img src="https://s2.loli.net/2022/07/16/n4MoGpNWaLykfmH.png" alt="image-20220714163240705"></p>
<ul>
<li>这样可以直接通过len来获得字符串长度，而不需要遍历字符串到结束标志</li>
</ul>
<h4 id="②动态扩容"><a href="#②动态扩容" class="headerlink" title="②动态扩容"></a>②动态扩容</h4><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p>
<p><img src="https://s2.loli.net/2022/07/16/7Oh5qCadAQocPEL.png" alt="image-20220714163404917"></p>
<ul>
<li><p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p>
<ul>
<li><p>如果新字符串小于1M，则新空间为<strong>扩展后字符串长度</strong>的两倍+1（+1是结束标志）</p>
</li>
<li><p>如果新字符串大于1M，则新空间为<strong>扩展后字符串长度</strong>+1M+1（+1是结束标志），称为<strong>内存预分配</strong></p>
</li>
</ul>
</li>
<li><p>内存预分配就是预先多分配一些空间，这样下次扩容的时候如果预先多分配的空间足够就不用再进行扩容操作，减少了扩容的频率</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/16/oLGXY1Qvu5STqlr.png" alt="image-20220714163547137"></p>
<p>这里<code>hi,Amy</code>共有6个字符&lt;1M，新空间就是2*6+1，但这里len是6，alloc也是12，这是因为+1的是结束标志</p>
<p>我们可以很轻易的获得字符串长度len&#x3D;6，而不再需要遍历</p>
<h3 id="2）intSet"><a href="#2）intSet" class="headerlink" title="2）intSet"></a>2）intSet</h3><h4 id="①基本概念-5"><a href="#①基本概念-5" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。<br>结构如下：</p>
<p><img src="https://s2.loli.net/2022/07/16/IxVJDO9zwj8KTsv.png" alt="1653984923322"></p>
<ul>
<li>这encodeding代表数组中int变量的编码，比如支持2^16，2^32，2^64位的数据（2,4,8字节）</li>
<li>length就代表了该数组里面有多少个数</li>
<li>contents虽然是int8_t定义的，但其实redis打破了该定义，数组中每个数字的编码还是根据encodeding了来定义<ul>
<li>这里contents仅仅是一个指针，指向了数组的其实地址</li>
</ul>
</li>
</ul>
<p>其中的encoding包含三种模式，表示存储的整数大小不同：</p>
<p><img src="https://s2.loli.net/2022/07/16/yUZAnhMH7jDBixT.png" alt="1653984942385"></p>
<p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p>
<p><img src="https://s2.loli.net/2022/07/16/cwFA5rCouWs3Ixh.png" alt="1653985149557"></p>
<p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：2字节<br>length：3<br>contents：2字节 * 3  &#x3D; 6字节</p>
<p><img src="https://s2.loli.net/2022/07/16/NKOiUGMXklEzqHT.png" alt="image-20220714170210043"></p>
<p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p>
<ul>
<li><p>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</p>
</li>
<li><p>倒序依次将数组中的元素拷贝到扩容后的正确位置</p>
<ul>
<li>若先调整5，那么5新的长度是4字节，就把原来的10给覆盖了</li>
<li>所以需要从后面调整起，20的下标是2，编码是4字节，那么20的新起点是2*4&#x3D;8</li>
</ul>
</li>
<li><p>将待添加的元素放入数组末尾</p>
</li>
<li><p>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/16/1Yd2bJ3vx7zNm9o.png" alt="1653985197214"></p>
<p><img src="https://s2.loli.net/2022/07/16/TWBR2m6CUfb1nXL.png" alt="1653985276621"></p>
<h4 id="②源码分析"><a href="#②源码分析" class="headerlink" title="②源码分析"></a>②源码分析</h4><p><img src="https://s2.loli.net/2022/07/16/pEjUs1GhWbnadw9.png" alt="1653985304075"></p>
<p><img src="https://s2.loli.net/2022/07/16/oLZHSVmbq9MrT1A.png" alt="1653985327653"></p>
<p>小总结：</p>
<p>Intset可以看做是特殊的整数数组，具备一些特点：</p>
<ul>
<li>Redis会确保Intset中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间<ul>
<li>比如说都不超过2^16的数字，那就不用去升级空间</li>
</ul>
</li>
<li>底层采用二分查找方式来查询新插入的元素要插入的位置<ul>
<li>找到了说明set已经有了，那么阻止插入（唯一性）</li>
<li>没找到就返回应该插入的位置</li>
</ul>
</li>
</ul>
<h3 id="3）Dict"><a href="#3）Dict" class="headerlink" title="3）Dict"></a>3）Dict</h3><h4 id="①基本概念-6"><a href="#①基本概念-6" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。<br>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p><img src="https://s2.loli.net/2022/07/16/BV6jl3DWQJbzfrT.png" alt="image-20220714172245867"></p>
<p>这就和java中的HashMap很类似，哈希节点就相当于Map.Entry，记录了自己的key和value，如果是链表还记录了下个entry的指针</p>
<ul>
<li><p>entry中union代表该entry的value是这里面的一种，可以是int也可以是字符串（指针）</p>
</li>
<li><p>为什么哈希表大小必须是2^n？</p>
<ul>
<li><p>若现在size&#x3D;4&#x3D;(100)，其掩码sizemask&#x3D;3&#x3D;（011），那么元素算出来的哈希值h &amp; sizemask，这样一直到倒数第二位，前面的值进行&amp;0都&#x3D;0，最后两位是1，那么元素hash这里的值是多少，最后就是多少。</p>
</li>
<li><p>这样的效果就是所有元素hash值计算后都会在00,01,10,11这个区间，也就是0,1,2,3，这就相当于将所有的元素对4取余了</p>
<img src="https://s2.loli.net/2022/07/16/91FRbHNWqO2QoEL.png" alt="image-20220714173447275" style="zoom:200%;" /></li>
</ul>
</li>
</ul>
<p>​		当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1,v1，假设k1的哈希值h &#x3D;1，则1&amp;3 &#x3D;1，因此k1,v1要存储到数组角标1位置。</p>
<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p><img src="https://s2.loli.net/2022/07/16/mzIlSj8pJPT2BU4.png" alt="image-20220714172643426"></p>
<p>它们之间的关系如下：</p>
<p><img src="https://s2.loli.net/2022/07/16/TpbwYiLQzkaxCoV.png" alt="1653985640422"></p>
<ul>
<li>可以看到ht[0]才是我们常用的</li>
</ul>
<h4 id="②rehash扩容"><a href="#②rehash扩容" class="headerlink" title="②rehash扩容"></a>②rehash扩容</h4><p>​		Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。Dict在每次新增键值对时都会检查负载因子（LoadFactor &#x3D; used&#x2F;size） ，满足以下两种情况时会触发哈希表扩容：</p>
<ul>
<li>哈希表的 LoadFactor &gt;&#x3D; 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；<ul>
<li>这时候CPU正在被大量使用，不要因为扩容来占用CPU资源</li>
</ul>
</li>
<li>哈希表的 LoadFactor &gt; 5 ；</li>
</ul>
<p><strong>具体流程</strong></p>
<p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p>
<ul>
<li><p>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</p>
<ul>
<li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li>
<li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li>
</ul>
</li>
<li><p>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</p>
</li>
<li><p>设置dict.rehashidx &#x3D; 0，标示开始rehash</p>
</li>
<li><p><strong>×并不是：</strong>将dict.ht[1]一次性赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p>
<ul>
<li>因为都是在新增、查询、修改、删除操作时区检查是否需要扩容，如果有ht[0]百万数据，这时候如果一次性进行数据的迁移，极大可能会引起主线程操作的阻塞，这是不应该的</li>
</ul>
</li>
<li><p>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</p>
<ul>
<li>这样每次迁移一点，称为<strong>渐进式rehash</strong>，不会为主线程造成压力</li>
<li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li>
</ul>
</li>
<li><p>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p>
</li>
<li><p>将rehashidx赋值为-1，代表rehash结束</p>
</li>
</ul>
<p>整个过程可以描述成：</p>
<img src="https://s2.loli.net/2022/07/16/NiGH3yIQn2grloY.png" alt="1653985824540" style="zoom:80%;" />

<h4 id="③总结"><a href="#③总结" class="headerlink" title="③总结"></a>③总结</h4><p>Dict的结构：</p>
<ul>
<li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li>
<li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li>
</ul>
<p>Dict的伸缩：</p>
<ul>
<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>
<li>当LoadFactor小于0.1时，Dict收缩</li>
<li>扩容大小为第一个大于等于used + 1的2^n</li>
<li>收缩大小为第一个大于等于used 的2^n</li>
<li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li>
<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>
</ul>
<h3 id="4）ZipList"><a href="#4）ZipList" class="headerlink" title="4）ZipList"></a>4）ZipList</h3><h4 id="①ZipList基本结构"><a href="#①ZipList基本结构" class="headerlink" title="①ZipList基本结构"></a>①ZipList基本结构</h4><p>​		ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为 O(1)。</p>
<p><img src="https://s2.loli.net/2022/07/16/r4RuXjc9WV6EqOD.png" alt="image-20220714182732677"></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>类型</strong></th>
<th align="center"><strong>长度</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td align="center">4 字节</td>
<td>记录整个压缩列表占用的内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td align="center">4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td align="center">2 字节</td>
<td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entry</td>
<td>列表节点</td>
<td align="center">不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td align="center">1 字节</td>
<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody></table>
<ul>
<li>可以通过zltail找到尾巴节点，从而实现从后往前找</li>
<li>4+4+2+1固定值</li>
</ul>
<h4 id="②ZipListEntry"><a href="#②ZipListEntry" class="headerlink" title="②ZipListEntry"></a>②ZipListEntry</h4><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p>
<p><img src="https://s2.loli.net/2022/07/16/49wLGvtAjMHNUCS.png" alt="1653986055253"></p>
<ul>
<li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p>
<ul>
<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>
<li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li>
</ul>
</li>
<li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p>
</li>
<li><p>contents：负责保存节点的数据，可以是字符串或整数</p>
</li>
<li><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p>
</li>
</ul>
<p>注意：这样我们就可以实现从前往后搜索，也可以完成从后往前搜索了</p>
<ul>
<li>从前往后<ul>
<li><strong>previous_entry_length</strong>长度固定，<strong>encoding</strong>长度固定，<strong>encoding</strong>记录了<strong>contents</strong>长度，这样三部分的长度都可以计算出来，那么就可以实现从前往后的遍历<ul>
<li>实际上还是需要遍历<strong>previous_entry_length</strong>和<strong>encoding</strong>才能知道一个entry的长度，实际上就是跳过了content的长度</li>
</ul>
</li>
</ul>
</li>
<li>从后往前<ul>
<li>因为每个结点都记录前一个节点的长度，那么从该节点头，很容易知道前一个节点头，所以很容易就能从后向前遍历</li>
</ul>
</li>
</ul>
<h4 id="③Encoding编码"><a href="#③Encoding编码" class="headerlink" title="③Encoding编码"></a>③Encoding编码</h4><p>ZipListEntry中的encoding编码分为字符串和整数两种：</p>
<ul>
<li><strong>字符串</strong>：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</li>
</ul>
<table>
<thead>
<tr>
<th><strong>编码</strong></th>
<th><strong>编码长度</strong></th>
<th><strong>字符串大小</strong></th>
</tr>
</thead>
<tbody><tr>
<td>|00pppppp|</td>
<td>1 bytes</td>
<td>&lt;&#x3D; 63 bytes</td>
</tr>
<tr>
<td>|01pppppp|qqqqqqqq|</td>
<td>2 bytes</td>
<td>&lt;&#x3D; 16383 bytes</td>
</tr>
<tr>
<td>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td>
<td>5 bytes</td>
<td>&lt;&#x3D; 4294967295 bytes</td>
</tr>
</tbody></table>
<p>例如，我们要保存字符串：“ab”和 “bc”</p>
<p><img src="https://s2.loli.net/2022/07/16/zYaEkTcgeXSprml.png" alt="1653986172002"></p>
<ul>
<li><strong>整数</strong>：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</li>
</ul>
<table>
<thead>
<tr>
<th><strong>编码</strong></th>
<th><strong>编码长度</strong></th>
<th><strong>整数类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>11000000</td>
<td>1</td>
<td>int16_t（2 bytes）</td>
</tr>
<tr>
<td>11010000</td>
<td>1</td>
<td>int32_t（4 bytes）</td>
</tr>
<tr>
<td>11100000</td>
<td>1</td>
<td>int64_t（8 bytes）</td>
</tr>
<tr>
<td>11110000</td>
<td>1</td>
<td>24位有符整数(3 bytes)</td>
</tr>
<tr>
<td>11111110</td>
<td>1</td>
<td>8位有符整数(1 bytes)</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1</td>
<td>直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td>
</tr>
</tbody></table>
<p><img src="https://s2.loli.net/2022/07/16/Hctair5ADTjlIEY.png" alt="1653986282879"></p>
<p><img src="https://s2.loli.net/2022/07/17/BrVJFOUXeTGqK3l.png" alt="1653986217182"></p>
<h4 id="④ZipList的连锁更新问题"><a href="#④ZipList的连锁更新问题" class="headerlink" title="④ZipList的连锁更新问题"></a>④ZipList的连锁更新问题</h4><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：</p>
<ul>
<li><p>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</p>
</li>
<li><p>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</p>
</li>
</ul>
<p>假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p>
<p><img src="https://s2.loli.net/2022/07/16/J9TihAc61mlSUzs.png" alt="image-20220714185737414"></p>
<p>​		在这N个entry前面插入一个大小&gt;&#x3D;254的entry，这样就会引起第二个entry的更新其<strong>previous_entry_length</strong>（从1改成5），而当第二个entry更新，这也就意味着第二个entry的总长度改变了，这样就导致后序这N个entry的长度改变，引起了连锁更新。</p>
<ul>
<li>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update），新增、删除都可能导致连锁更新的发生。</li>
<li>这要有连续的N各pre为1的entry才能发生，之间有一个pre为5的都会断掉，所以这个问题的发生几率并不高</li>
</ul>
<h4 id="⑤总结"><a href="#⑤总结" class="headerlink" title="⑤总结"></a>⑤总结</h4><p><strong>ZipList特性：</strong></p>
<ul>
<li>压缩列表的可以看做一种连续内存空间的”双向链表”</li>
<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>
<li>如果列表数据过多，导致链表过长，可能影响查询性能<ul>
<li>因为仍然是逐个遍历的方式，所以链表过长，还是有可能有性能问题</li>
</ul>
</li>
<li>增或删较大数据时有可能发生连续更新问题<ul>
<li>引入了新结构来解决，但是还没有做替换</li>
</ul>
</li>
</ul>
<h3 id="5）QuickList"><a href="#5）QuickList" class="headerlink" title="5）QuickList"></a>5）QuickList</h3><h4 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h4><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>
<p>​	答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>
<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>
<p>​	答：我们可以创建多个ZipList来分片存储数据。</p>
<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>
<p>​	答：Redis在3.2版本引入了新的数据结构QuickList，它是一个<strong>双端链表</strong>，只不过链表中的每个节点都是一个ZipList。</p>
<p><img src="https://s2.loli.net/2022/07/17/8rCQazLjOdNS2vu.png" alt="1653986474927"></p>
<h4 id="②基本设置"><a href="#②基本设置" class="headerlink" title="②基本设置"></a>②基本设置</h4><p><strong>list-max-ziplist-size：</strong></p>
<p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<strong>list-max-ziplist-size</strong>来限制。</p>
<ul>
<li><p>如果值为正，则代表ZipList的允许的entry个数的最大值</p>
<ul>
<li>限制entry个数不能很好地解决，因为可能出现单个entry数据很大的情况</li>
</ul>
</li>
<li><p>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p>
<ul>
<li><p>-1：每个ZipList的内存占用不能超过4kb</p>
</li>
<li><p>-2：每个ZipList的内存占用不能超过8kb</p>
</li>
<li><p>-3：每个ZipList的内存占用不能超过16kb</p>
</li>
<li><p>-4：每个ZipList的内存占用不能超过32kb</p>
</li>
<li><p>-5：每个ZipList的内存占用不能超过64kb</p>
</li>
</ul>
</li>
</ul>
<p>其默认值为 -2：</p>
<p><img src="https://s2.loli.net/2022/07/17/gnuAezKp2vTFf3o.png" alt="1653986642777"></p>
<p><strong>list-compress-depth：</strong></p>
<ul>
<li><p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项list-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p>
<ul>
<li><p>0：特殊值，代表不压缩</p>
</li>
<li><p>1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩</p>
</li>
<li><p>2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩</p>
</li>
<li><p>以此类推</p>
</li>
<li><p>默认值：0，意味着默认是不会进行压缩的</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/NnYkJQ6vrc3tdfb.png" alt="image-20220714213453391"></p>
<h4 id="③源码分析"><a href="#③源码分析" class="headerlink" title="③源码分析"></a>③源码分析</h4><p>以下是QuickList的和QuickListNode的结构源码：</p>
<p><img src="https://s2.loli.net/2022/07/17/9HS2LQieg8kZEtw.png" alt="1653986667228"></p>
<p>我们接下来用一段流程图来描述当前的这个结构</p>
<img src="https://s2.loli.net/2022/07/17/jZx4L3Tuags26RQ.png" alt="image-20220714213051309" style="zoom:80%;" />



<h4 id="④总结"><a href="#④总结" class="headerlink" title="④总结"></a>④总结</h4><p>QuickList的特点：</p>
<ul>
<li>是一个节点为ZipList的双端链表</li>
<li>节点采用ZipList，解决了传统链表的内存占用问题</li>
<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>
<li>中间节点可以压缩，进一步节省了内存</li>
</ul>
<h3 id="6）SkipList"><a href="#6）SkipList" class="headerlink" title="6）SkipList"></a>6）SkipList</h3><h4 id="①基本概念-7"><a href="#①基本概念-7" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p>
<ul>
<li>元素按照升序排列存储</li>
<li>节点可能包含多个指针，指针跨度不同</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/FqlCphimyZKUVN9.png" alt="image-20220714220631388"></p>
<ul>
<li>可以看到同一个节点可能包含多个跨度的指针</li>
<li>比如要查询第9，先走1-10，发现score更小，那就在下一级指正来寻找</li>
</ul>
<h4 id="②源码分析-1"><a href="#②源码分析-1" class="headerlink" title="②源码分析"></a>②源码分析</h4><p><img src="https://s2.loli.net/2022/07/17/mbwdc47U86FrHWk.png" alt="image-20220714221033908"></p>
<ul>
<li>每一个节点都有一个sds存储value，score则是排序查找用的<ul>
<li>score相同的情况下会按照字典排序</li>
</ul>
</li>
<li>节点中包含了一个指针数组（包含下一个节点指针，索引跨度）</li>
</ul>
<h4 id="③总结-1"><a href="#③总结-1" class="headerlink" title="③总结"></a>③总结</h4><p>SkipList的特点：</p>
<ul>
<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>
<li>节点按照score值排序，score值一样则按照ele字典排序</li>
<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>
<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>
<li>增删改查效率与红黑树基本一致，实现却更简单</li>
</ul>
<h3 id="7）RedisObject"><a href="#7）RedisObject" class="headerlink" title="7）RedisObject"></a>7）RedisObject</h3><h4 id="①基本概念-8"><a href="#①基本概念-8" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象：<br>        从Redis的使用者的角度来看，⼀个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：<br>string、list、hash、set、sorted set等。我们可以看到，key的类型固定是string，而value可能的类型是多个。<br>⽽从Redis内部实现的⾓度来看，database内的这个映射关系是用⼀个dict来维护的。dict的key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p>
<p><img src="https://s2.loli.net/2022/07/17/BFtRwQEb1oOI9Si.png" alt="1653986956618"></p>
<h4 id="②Redis的编码方式"><a href="#②Redis的编码方式" class="headerlink" title="②Redis的编码方式"></a>②Redis的编码方式</h4><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>编码方式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>OBJ_ENCODING_RAW</td>
<td>raw编码动态字符串</td>
</tr>
<tr>
<td>1</td>
<td>OBJ_ENCODING_INT</td>
<td>long类型的整数的字符串</td>
</tr>
<tr>
<td>2</td>
<td>OBJ_ENCODING_HT</td>
<td>hash表（字典dict）</td>
</tr>
<tr>
<td>3</td>
<td>OBJ_ENCODING_ZIPMAP</td>
<td>已废弃</td>
</tr>
<tr>
<td>4</td>
<td>OBJ_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>5</td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>6</td>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>7</td>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳表</td>
</tr>
<tr>
<td>8</td>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr的动态字符串</td>
</tr>
<tr>
<td>9</td>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>快速列表</td>
</tr>
<tr>
<td>10</td>
<td>OBJ_ENCODING_STREAM</td>
<td>Stream流</td>
</tr>
</tbody></table>
<h4 id="③五种数据结构对应的编码"><a href="#③五种数据结构对应的编码" class="headerlink" title="③五种数据结构对应的编码"></a>③五种数据结构对应的编码</h4><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>编码方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>OBJ_STRING</td>
<td>int、embstr、raw</td>
</tr>
<tr>
<td>OBJ_LIST</td>
<td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td>
</tr>
<tr>
<td>OBJ_SET</td>
<td>intset、HT</td>
</tr>
<tr>
<td>OBJ_ZSET</td>
<td>ZipList、HT、SkipList</td>
</tr>
<tr>
<td>OBJ_HASH</td>
<td>ZipList、HT</td>
</tr>
</tbody></table>
<h2 id="2-Redis基本数据结构"><a href="#2-Redis基本数据结构" class="headerlink" title="2.Redis基本数据结构"></a>2.Redis基本数据结构</h2><h3 id="1）String"><a href="#1）String" class="headerlink" title="1）String"></a>1）String</h3><h4 id="①基本概念-9"><a href="#①基本概念-9" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>String是Redis中最常见的数据存储类型：</p>
<ul>
<li><p>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</p>
</li>
<li><p>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。</p>
<ul>
<li>申请内存时只需要调用一次内存分配函数，效率更高。</li>
</ul>
</li>
<li><p>String类型的value的值是数字，那么Redis内部会把它转成long类型来存储</p>
</li>
</ul>
<p><strong>SDS：</strong></p>
<p><img src="https://s2.loli.net/2022/07/17/H59baUEce3vpZdA.png" alt="image-20220715123737387"></p>
<p><img src="https://s2.loli.net/2022/07/17/YdxzUHbWlrQ9agS.png" alt="1653987103450"></p>
<h4 id="②RAW"><a href="#②RAW" class="headerlink" title="②RAW"></a>②RAW</h4><p><img src="https://s2.loli.net/2022/07/17/c1gvXKFnphqj3Pf.png" alt="image-20220715123558419"></p>
<ul>
<li>可以看到redisObject和SDS是分开存储的，redisObject的指正指向了SDS</li>
<li>因为申请内存涉及到用户态转为内核态，比较耗费资源，而RAW的方式需要申请两次内存，分别为redisObject和SDS</li>
</ul>
<h4 id="③embStr"><a href="#③embStr" class="headerlink" title="③embStr"></a>③embStr</h4><p><img src="https://s2.loli.net/2022/07/17/2etZ8jlQKfYHhIO.png" alt="image-20220715123857176"></p>
<ul>
<li>当SDS存储的value&lt;&#x3D;44时候，会采用embStr方式<ul>
<li>这时候redisObject和SDS是连续存储的，不再是通过指针指向</li>
<li>这时候申请内存只会申请一次，只有一次用户态转核心态，效率更高</li>
</ul>
</li>
<li>为什么是44，因为这和redis的内存分配有关系，redis的内存分片是以2^n来分片的<ul>
<li>如果SDS&#x3D;44+SDS头信息+redisObject的头信息，刚好是64，正好符合一个数据分片的长度</li>
</ul>
</li>
</ul>
<h4 id="④int（Long范围）"><a href="#④int（Long范围）" class="headerlink" title="④int（Long范围）"></a>④int（Long范围）</h4><p><img src="https://s2.loli.net/2022/07/17/KqhoNVabPYkfwL7.png" alt="image-20220715124406653"></p>
<ul>
<li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节，long的编码长度），不再需要SDS了。</li>
<li>这样String的数据相当于就存在了redisObject当中，更加省空间了</li>
</ul>
<h4 id="⑤其它相关"><a href="#⑤其它相关" class="headerlink" title="⑤其它相关"></a>⑤其它相关</h4><p>确切地说，String在Redis中是⽤⼀个robj来表示的：</p>
<ul>
<li><p>用来表示String的robj可能编码成3种内部表⽰：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。</p>
</li>
<li><p>其中前两种编码使⽤的是sds来存储，最后⼀种OBJ_ENCODING_INT编码直接把string存成了long型。</p>
</li>
<li><p>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接行加减操作；</p>
<ul>
<li>如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，<ul>
<li>如果能转成功，再进行加减操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>对⼀个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即⼗进制表示的字符串），而不是针对内部表⽰的long型进⾏操作。</p>
<ul>
<li>比如字符串”32”，我们只是将其当做long存储起来，在bitmap使用时仍然是按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。</li>
<li>⽽如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，也就是2进制的<strong>100000</strong>在这个基础上执⾏setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。</li>
</ul>
</li>
</ul>
<h3 id="2）List"><a href="#2）List" class="headerlink" title="2）List"></a>2）List</h3><p>Redis的List类型可以从首、尾操作列表中的元素：</p>
<p><img src="https://s2.loli.net/2022/07/17/JjkNlQ2oAz6WcV3.png" alt="1653987240622"></p>
<p>哪一个数据结构能满足上述特征？</p>
<ul>
<li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li>
<li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li>
<li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li>
</ul>
<p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p>
<p>在3.2版本之前，Redis采用<strong>ZipList</strong>和<strong>LinkedList</strong>来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p>
<p>在3.2版本之后，Redis统一采用QuickList来实现List：</p>
<p><img src="https://s2.loli.net/2022/07/17/ba3fGMwA9Dq8m1y.png" alt="1653987313461"></p>
<h3 id="3）Set"><a href="#3）Set" class="headerlink" title="3）Set"></a>3）Set</h3><h4 id="①基本概念-10"><a href="#①基本概念-10" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>Set是Redis中的单列集合，满足下列特点：</p>
<ul>
<li>不保证有序性</li>
<li>保证元素唯一</li>
<li>求交集、并集、差集</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/iqRIsz19U5v4aVA.png" alt="1653987342550"></p>
<p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高（判断元素是否存在）</p>
<p>可以看出，Set对查询元素的效率要求非常高，思考一下，什么样的数据结构可以满足？</p>
<ul>
<li><p>SkipList也有较高的效率，但是它需要一个score来进行排序，set不需要排序</p>
</li>
<li><p>HashTable，也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对），我们可以只存key</p>
</li>
</ul>
<p>综上，Set选择了HT来作为底层数据结构</p>
<h4 id="②IntSet"><a href="#②IntSet" class="headerlink" title="②IntSet"></a>②IntSet</h4><p><img src="https://s2.loli.net/2022/07/17/XHMiSKmecYb9wat.png" alt="image-20220715140228070"></p>
<ul>
<li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</li>
<li>因为IntSet使用了二分查找，所以在数据量不大的情况下，查询的效率依然非常高</li>
<li>在创建Set的时候会判断是否是整数，然后再构建IntSet<ul>
<li>当存储的所有数据都是整数</li>
<li>元素数量不超过set-max-intset-entries</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/8GtAq4QRXJ67Dxe.png" alt="image-20220715135333462"></p>
<h4 id="③Dict"><a href="#③Dict" class="headerlink" title="③Dict"></a>③Dict</h4><p><img src="https://s2.loli.net/2022/07/17/2nVQTjD85lcCqRx.png" alt="image-20220715140256644"></p>
<p>​	IntSet是有弊端的：</p>
<ul>
<li>必须全是整数</li>
<li>整数的数量不能太多，因为毕竟使用的二分查找，如果元素太多，效率还是不能保证</li>
</ul>
<p>所以当<strong>存储的有不是整数</strong>，并且<strong>元素数量超过set-max-intset-entries</strong>的时候，会采用Dict方式：</p>
<ul>
<li>HashTable，也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对），我们可以只存key，所有的value设为null<ul>
<li>这和java中的HashMap和HashSet很类似</li>
</ul>
</li>
<li>每次插入新元素redis都回去检查是否符合IntSet的两个条件，如果不符合就会转换成Set集合</li>
</ul>
<h3 id="4）Zset"><a href="#4）Zset" class="headerlink" title="4）Zset"></a>4）Zset</h3><h4 id="①基本概念-11"><a href="#①基本概念-11" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p>
<ul>
<li>可以根据score值排序后</li>
<li>member必须唯一</li>
<li>可以根据member查询分数</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/6Ddp4FxoMCTzEhL.png" alt="1653992091967"></p>
<p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。之前学习的哪种编码结构可以满足？</p>
<ul>
<li><p>SkipList：可以排序，并且可以同时存储score和ele值（member），可以通过分数排名来获取值</p>
<ul>
<li>如果根据member查分数，这样效率并不高（遍历）</li>
<li>member需要唯一，检查其唯一效率也不高（遍历）</li>
</ul>
</li>
<li><p>HT（Dict）：可以键值存储，并且可以根据key找value</p>
<ul>
<li>但是并不能排序，不能通过分数排名来获取某个值，或者一个范围内的值</li>
</ul>
</li>
</ul>
<p>综上，redis采用两种方法结合来构建Zset，如下：</p>
<p><img src="https://s2.loli.net/2022/07/17/mEuTFvCQlWIYGsz.png" alt="1653992121692"></p>
<p>由于是两种结构结合，所以内存空间占用非常大，因此再存储的元素较少的时候会使用ZipList来进行优化</p>
<ul>
<li>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成</li>
</ul>
<h4 id="②SkipList-HT"><a href="#②SkipList-HT" class="headerlink" title="②SkipList+HT"></a>②SkipList+HT</h4><p><img src="https://s2.loli.net/2022/07/17/VseRxXDLKmTM72Y.png" alt="image-20220715143310292"></p>
<ul>
<li>Dict的entry的key是member，value是score<ul>
<li>这样我们可以快速查询member对应的score</li>
<li>并且我们能快速查询出是否已经有了member了，保证member唯一性</li>
</ul>
</li>
<li>SkipList能够帮进行排序，并行快速获取score排名的某个值，或者一个范围内的值</li>
</ul>
<h4 id="③ZipList"><a href="#③ZipList" class="headerlink" title="③ZipList"></a>③ZipList</h4><p><img src="https://s2.loli.net/2022/07/17/dZ85hQOLzMsnXr3.png" alt="image-20220715143632061"></p>
<p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p>
<ul>
<li><p>元素数量小于zset_max_ziplist_entries，默认值128</p>
</li>
<li><p>每个元素都小于zset_max_ziplist_value字节，默认值64</p>
</li>
<li><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成</p>
</li>
<li><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>
<ul>
<li><p>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</p>
</li>
<li><p>score越小越接近队首，score越大越接近队尾，按照score值升序排列</p>
</li>
<li><p>它并不能保证顺序性，所以需要代码实现</p>
</li>
<li><p>并且在大数量的时候查询效率也不能得到保证</p>
</li>
</ul>
</li>
</ul>
<h3 id="5）Hash"><a href="#5）Hash" class="headerlink" title="5）Hash"></a>5）Hash</h3><h4 id="①基本概念-12"><a href="#①基本概念-12" class="headerlink" title="①基本概念"></a>①基本概念</h4><p>Hash结构与Redis中的Zset非常类似：</p>
<ul>
<li>都是键值存储</li>
<li>都需求根据键获取值</li>
<li>键必须唯一</li>
</ul>
<p>区别如下：</p>
<ul>
<li>zset的键是member，值是score；hash的键和值都是任意值</li>
<li>zset要根据score排序；hash则无需排序</li>
</ul>
<p>因此，可以模仿Zset的实现，但是将其排序部分也就是skipList排除，所以可以使用zset或HT(Dict)来实现</p>
<h4 id="②HT-Dict"><a href="#②HT-Dict" class="headerlink" title="②HT(Dict)"></a>②HT(Dict)</h4><p><img src="https://s2.loli.net/2022/07/17/iUMXFesmb2WxQZE.png" alt="image-20220715144940083"></p>
<ul>
<li>注意当ZipList不满足条件的时候没转化为HT<ul>
<li>每次新增都会检查</li>
</ul>
</li>
</ul>
<h4 id="③Ziplist"><a href="#③Ziplist" class="headerlink" title="③Ziplist"></a>③Ziplist</h4><p><img src="https://s2.loli.net/2022/07/17/DujaCnx7h3lQ8ps.png" alt="image-20220715145119456"></p>
<p>当Hash中数据项比较少的情况下，Hash底层才⽤压缩列表ziplist进⾏存储数据，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p>
<ul>
<li><p>hash-max-ziplist-entries 512</p>
</li>
<li><p>hash-max-ziplist-value 64</p>
</li>
</ul>
<p>当满足上面两个条件其中之⼀的时候，Redis就使⽤dict字典来实现hash。</p>
<p>Redis的hash之所以这样设计，是因为当ziplist变得很⼤的时候，它有如下几个缺点：</p>
<ul>
<li>每次插⼊或修改引发的realloc操作会有更⼤的概率造成内存拷贝，从而降低性能。</li>
<li>⼀旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更⼤的⼀块数据。</li>
<li>当ziplist数据项过多的时候，在它上⾯查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li>
</ul>
<p>总之，ziplist本来就设计为各个数据项挨在⼀起组成连续的内存空间，这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存</p>
<p>realloc，可能导致内存拷贝。</p>
<h2 id="3-Redis网络模型"><a href="#3-Redis网络模型" class="headerlink" title="3.Redis网络模型"></a>3.Redis网络模型</h2><h3 id="1）-用户空间和内核态空间"><a href="#1）-用户空间和内核态空间" class="headerlink" title="1） 用户空间和内核态空间"></a>1） 用户空间和内核态空间</h3><p>​		计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件的，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行 内存管理，文件系统的管理，进程的管理等等</p>
<img src="https://s2.loli.net/2022/07/17/MvQ7fpIi8Sug1Zz.png" alt="1653896065386" style="zoom: 67%;" />



<p>​		我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而简单的实现对内核的操控，但是<strong>内核本身上来说也是一个应用</strong>，所以他本身也需要一些内存，cpu等设备资源，如windows一开始就会占用一部分内存，占用部分CPU资源。</p>
<p>​		用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，如剩余资源无法支撑内核了，因此我们需要把用户和<strong>内核隔离开</strong>。</p>
<p>进程的寻址空间划分成两部分：<strong>内核空间、用户空间</strong></p>
<p>​		什么是寻址空间呢？我们的应用程序也好，还是内核空间也好，都是没有办法直接去物理内存的，而是通过分配一些虚拟内存映射到物理内存中，我们的内核和应用程序去访问虚拟内存的时候，就需要一个虚拟地址，这个地址是一个无符号的整数，比如一个32位的操作系统，他的带宽就是32，他的虚拟地址就是2的32次方，也就是说他寻址的范围就是0~2的32次方， 这片寻址空间对应的就是2的32个字节，就是4GB，这个4GB，会有3个GB分给用户空间，会有1GB给内核系统</p>
<p><img src="https://s2.loli.net/2022/07/17/CRy81o9Nuiagw6b.png" alt="1653896377259"></p>
<p>​		在linux中，他们权限分成两个等级，0和3。</p>
<p>​		用户空间只能执行受限的命令（Ring3），而不能直接调用系统资源，必须通过内核提供的接口来访问内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，一个应用程序需要去调用一些特权资源，去调用一些内核空间的操作，所以此时他俩需要在用户态和内核态之间进行切换。</p>
<p><strong>比如：</strong></p>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>
<p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p>
<p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p>
<p>针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的buffer中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望read也好，还是wait for data也最好都不要等待，或者时间尽量的短。</p>
<p><img src="https://s2.loli.net/2022/07/17/YqaeXy7cN13dTbm.png" alt="1653896687354"></p>
<p>​		如我们现在的应用接受一个网络请求（也就是读取），需要切换到内核态，然后再内核上进行等待请求wait for data（这是第一部分消耗的时间），等到数据后会将数据读入到<strong>内核空间的buffer</strong>，然后再从<strong>内核空间的buffer</strong>读入<strong>用户空间的buffer</strong>中，切换到用户空间，用户程序才能去处理这些数据。</p>
<p>​		回应response的过程就是先从<strong>用户空间的buffer</strong>将处理好的数据写会<strong>内核空间的buffer</strong>，然后再写到网卡，返回该数据。</p>
<p>以上过程其实就是阻塞IO，这里主要有两个改进的地方：</p>
<ul>
<li>内核态等待数据的时间</li>
<li>数据拷贝时间：read时从<strong>内核空间</strong>向<strong>用户空间</strong>复制，write时从<strong>用户空间</strong>向<strong>内核空间</strong>复制</li>
</ul>
<p>为了提高IO效率，我们就要优化这两点。</p>
<h3 id="2）阻塞IO-BIO"><a href="#2）阻塞IO-BIO" class="headerlink" title="2）阻塞IO-BIO"></a>2）阻塞IO-BIO</h3><p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p>
<img src="https://s2.loli.net/2022/07/17/KUfDmZ4nlLJir6W.png" alt="1653897270074" style="zoom:80%;" />

<p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</p>
<p><strong>阶段一：</strong></p>
<ul>
<li>用户进程尝试读取数据（比如网卡数据）</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>此时用户进程也处于阻塞状态</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态</li>
<li>类似操作系统中的轮询</li>
</ul>
<h3 id="3）非阻塞IO-NIO"><a href="#3）非阻塞IO-NIO" class="headerlink" title="3）非阻塞IO-NIO"></a>3）非阻塞IO-NIO</h3><p><img src="https://s2.loli.net/2022/07/17/qDCNSUFaZ7xsu6W.png" alt="image-20220715162255842"></p>
<p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p>
<p><strong>阶段一：</strong></p>
<ul>
<li>用户进程尝试读取数据（比如网卡数据）</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>返回异常给用户进程</li>
<li>用户进程拿到error后，再次尝试读取</li>
<li><strong>循环往复</strong>，直到数据就绪</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。</li>
<li>虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。<ul>
<li>这样看非阻塞IO并不一定比阻塞IO好，但非阻塞IO在IO多路复用中有着重要作用</li>
</ul>
</li>
</ul>
<h3 id="4）IO多路复用"><a href="#4）IO多路复用" class="headerlink" title="4）IO多路复用"></a>4）IO多路复用</h3><h4 id="①基本思路"><a href="#①基本思路" class="headerlink" title="①基本思路"></a>①基本思路</h4><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p>
<ul>
<li>如果调用recvfrom时，恰好没有数据<ul>
<li>阻塞IO会使CPU阻塞</li>
<li>非阻塞IO使CPU空转，都不能充分发挥CPU的作用</li>
</ul>
</li>
<li>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</li>
</ul>
<p>所以怎么看起来以上两种方式性能都不好</p>
<p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p>
<p>就比如服务员给顾客点餐，<strong>分两步</strong>：</p>
<ul>
<li>顾客排队思考要吃什么（socket等待数据就绪），前台接收下单（前台从顾客读取数据）</li>
<li>前台上有订单了，后厨做开始接收订单（前台有了数据，后厨读取该数据)</li>
</ul>
<p>要提高效率有几种办法？</p>
<p>方案一：增加更多服务员（多线程）</p>
<ul>
<li>增加多个前台服务员，虽然可以提高效率，但是前台服务员多了，管理难度和管理花销就多了</li>
<li>线程的切换是有开销的（上下文切换）</li>
</ul>
<p>方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）</p>
<ul>
<li>后厨先就给服务员说，我在等这些顾客的单子，有单子了就给我说</li>
<li>前台在接收到各个用户数据后直接按铃，通知后厨有单子了</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/cb4zD5K6EavdWJm.png" alt="1653898691736"></p>
<p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？</p>
<ul>
<li><p>文件描述符（File Descriptor）：简称<strong>FD</strong>，是一个从0 开始的无符号整数，</p>
<ul>
<li>用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。可以用FD来关联一个Socket，看其数据是否就绪</li>
</ul>
</li>
<li><p>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
</li>
</ul>
<p><strong>阶段一：</strong></p>
<ul>
<li>用户进程调用select，指定要监听的FD集合（后厨指明等待这些顾客单子）</li>
<li>内核监听FD对应的多个socket（前台等待这些顾客下完单）</li>
<li>任意一个或多个socket数据就绪则返回readable（有单子了前台就给后厨说）</li>
<li>此过程中用户进程阻塞</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li>用户进程找到就绪的socket</li>
<li>依次调用recvfrom读取数据</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
<p>​		当用户去读取数据的时候，不再去直接调用recvfrom了，而是调用select的函数，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</p>
<p>用IO复用模式，可以确保去读数据的时候，数据是一定存在的，他的效率比原来的阻塞IO和非阻塞IO性能都要高</p>
<p><strong>分类：</strong></p>
<p>​		IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p>
<p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，咱们就省去了遍历的动作。</p>
<h4 id="②select"><a href="#②select" class="headerlink" title="②select"></a>②select</h4><p>select是Linux最早是由的I&#x2F;O多路复用技术：</p>
<p>​		简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的 ），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据，</p>
<p>​		比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再处理掉没有准备好的数据（就绪的保留，未就绪的改为0，这里就是socket1就绪了），最后再将这个FD集合写回到用户态中去，此时用户态就知道了，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点（仍然为1的bit），再去发起读请求，重复上述过程。</p>
<p>​		我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情， 比如说频繁的传递fd集合，频繁的去遍历FD等问题</p>
<p><img src="https://s2.loli.net/2022/07/17/WbJjcT7EX4BAPhd.png" alt="image-20220715170818028"></p>
<ul>
<li>nfds可以使内核态知道遍历到哪儿结束</li>
<li>用户空间要先将要监听的fdSet拷贝到内核空间，当内核空间有fd就绪了，还要将就绪的fdSet拷贝回去，重复该过程会有大量的用户态和内核态切换</li>
<li>而且内核空间并不直接知道要监听哪些fd，需要遍历fdSet，用户空间也不知道哪些fd就绪了，需要遍历fdSet，这就涉及大量的遍历操作</li>
</ul>
<h4 id="③poll"><a href="#③poll" class="headerlink" title="③poll"></a>③poll</h4><img src="https://s2.loli.net/2022/07/17/RyVwhTFb9S1WYpu.png" alt="image-20220715172158045" style="zoom:67%;" />

<p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p>
<p><strong>IO流程：</strong></p>
<ul>
<li><p>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</p>
</li>
<li><p>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</p>
</li>
<li><p>内核遍历fd，判断是否就绪</p>
</li>
<li><p>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</p>
</li>
<li><p>用户进程判断n是否大于0，大于0则遍历pollfd数组，找到就绪的fd</p>
</li>
</ul>
<p><strong>与select对比：</strong></p>
<ul>
<li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li>
<li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li>
</ul>
<h4 id="④epoll"><a href="#④epoll" class="headerlink" title="④epoll"></a>④epoll</h4><blockquote>
<p>详细：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63179839">https://zhuanlan.zhihu.com/p/63179839</a></p>
</blockquote>
<p><img src="https://s2.loli.net/2022/07/17/6ftipVMK9EQWre5.png" alt="image-20220715174015950"></p>
<ul>
<li>句柄唯一标识了一个eventpoll，内核空间可能有多个eventpoll，用户态可根据句柄来确定某一个eventpoll</li>
<li>原来select的作用被分开了<ul>
<li>ctl只会添加要监听的事件fd并加上一个监听函数，放入event的红黑树中<ul>
<li>对于每一个FD，只会被放入红黑树一次，减少了大量无意义的放入</li>
</ul>
</li>
<li>epoll_wait函数，这个函数会去校验是否有数据准备完毕（因为数据一旦准备就绪，就会被回调函数添加到list_head中）<ul>
<li>epoll_wait进行循环，每次都取检查list中是否有准备好的数据，并且epoll_wait函数中传入了一个空数组，epoll_wait会将lsit中已经准备好的节点放入这个空数组中并返回就绪的数量</li>
<li>如果FD没有，epoll_wait会将自己线程挂在eventpoll.wq等待队列上。如果在超时时间内，list上有FD就绪了，就会唤醒该eventpoll.wq上的等待线程，该线程就能够获取到该FD并放入数组中</li>
<li>这样用户空间所见即所得，不需要再去遍历数组</li>
</ul>
</li>
</ul>
</li>
<li>就绪的fd会执行一个监听函数，回调函数把对应fd从红黑树放入就绪list中，<ul>
<li>就绪list中的数据会放入用户空间的一个events数组中</li>
<li>这样就避免了用户空间遍历才能得到就绪的fds，现在是所见即所得</li>
</ul>
</li>
</ul>
<p><strong>select、poll、epoll对比：</strong></p>
<ul>
<li><p>select模式存在的三个问题：</p>
<ul>
<li><p>能监听的FD最大不超过1024</p>
</li>
<li><p>每次select都需要把所有要监听的FD都拷贝到内核空间</p>
</li>
<li><p>每次都要遍历所有FD来判断就绪状态</p>
</li>
</ul>
</li>
<li><p>poll模式的问题：</p>
<ul>
<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>
<li>其实这是伪上限，因为list并不能node越多，增删改查效率都会很低</li>
</ul>
</li>
<li><p>epoll模式中如何解决这些问题的？</p>
<ul>
<li><p>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</p>
</li>
<li><p>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</p>
<ul>
<li>拷贝的时候只拷贝就绪的FD，用户遍历的都是就绪的FD</li>
</ul>
</li>
<li><p>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</p>
<ul>
<li>FD就绪后会通过回调函数，把自己挂在list上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="⑤epoll中的ET和LT"><a href="#⑤epoll中的ET和LT" class="headerlink" title="⑤epoll中的ET和LT"></a>⑤epoll中的ET和LT</h4><img src="https://s2.loli.net/2022/07/17/XFrLPAe67qitEbV.png" alt="image-20220715180608172" style="zoom: 80%;" />

<p>当FD有数据可读时，我们调用<strong>epoll_wait（或者select、poll）可以得到通知</strong>。但是事件通知的模式有两种：</p>
<ul>
<li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li>
<li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li>
</ul>
<p>举个栗子：</p>
<ol>
<li><p>假设一个客户端socket对应的FD已经注册到了epoll实例中</p>
</li>
<li><p>客户端socket发送了2kb的数据</p>
</li>
<li><p>服务端调用epoll_wait，得到通知说FD就绪，将FD放入用户空间的数组中，并断开list中的指针</p>
</li>
<li><p>服务端从FD读取了1kb数据的时候又回到步骤3（再次调用epoll_wait，形成循环）</p>
<ul>
<li><p>LT：内核会检查FD看是否有数据没有读取完，如果没有读取完就再次将FD放入list，再次调用epoll_wait就会又一次获得这些FD，然后读取剩余的数据</p>
</li>
<li><p>ET：只能读一次，所以内核会直接移除这些FD，epoll_wait并不会得到结果</p>
</li>
</ul>
</li>
</ol>
<p>即：</p>
<ul>
<li><p>如果我们采用LT模式，因为FD中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知</p>
</li>
<li><p>如果我们采用ET模式，因为第③步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</p>
</li>
</ul>
<p><strong>问题1：为什么还要使用ET</strong>？</p>
<p>​	 	因为LT会触发<strong>惊群现象</strong>：</p>
<p>epoll_wait回去list上尝试获取FD，如果没有获取成功会将自己瓜子对应的eventpoll.wq等待队列上，在时间范围内，如果有FD就绪（被挂在了list上）那么就会通知该等待队列上的线程，A现在等待队列上，然后被唤醒了处理FD（取出放数组），FD仍然是挂在list上，那么进程B也在该eventpoll.wq等待队列上等待资源，该FD就会可能会唤醒B进程来进行处理。</p>
<blockquote>
<p>我们仔细看 <code>ep_scan_ready_list</code> 源码，当 <code>ep-&gt;rdllist</code> 不为空时，会唤醒进程。</p>
<p>当多个进程共享同一个 “epoll fd” 时，多个进程同时在等待资源，也就是多个进程通过 epoll_wait 将自己当前进程的等待事件挂在内核 epoll 实例 eventpoll.wq 等待队列上，换句话说，eventpoll.wq 等待队列上挂着多个进程的等待事件（操作系统），当某个事件触发时，等待队列上的进程会被唤醒。</p>
<p>如果是 lt 模式，epoll 在下一个 epoll_wait 执行前，fd 事件节点仍然会存在就绪队列中，不管事件是否处理完成，那么唤醒进程 A 处理事件时，如果 B 进程也在等待资源，那么同样的事件有可能将 B 进程也唤醒处理，然后 B 又是同样的逻辑唤醒 C —— 连环唤醒问题，这种情况可能是用户不愿意看到的。<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/403893498/answer/2258283710">https://www.zhihu.com/question/403893498/answer/2258283710</a></p>
</blockquote>
<p><strong>问题2：怎样解决ET不能读完的问题</strong></p>
<ul>
<li><p>方案1：因为已经读入了FD，需要在这一次通知中把通知读完</p>
<ul>
<li>设计为非阻塞IO使其while读完，读完后会返回一个error</li>
<li>不能是阻塞IO，因为读完后没内容了会一直阻塞</li>
</ul>
</li>
<li><p>方案2，手动再放入list，因为其它的进程已经读完了，开始监听其它的数据了，这时候</p>
</li>
</ul>
<h4 id="⑥基于epoll的web流程"><a href="#⑥基于epoll的web流程" class="headerlink" title="⑥基于epoll的web流程"></a>⑥基于epoll的web流程</h4><p><img src="https://s2.loli.net/2022/07/17/vOlI3GzY6FwJms4.png" alt="image-20220715182144450"></p>
<ul>
<li>服务端创建serverSocket并得到FD，记做ssfd，然后调用epoll_ctl将该fd添加到红黑树上</li>
<li>调用epoll_wait检查就绪list是否有fd，等待fd就绪<ul>
<li>如果list中有fd就绪，epoll_wait将这些fd放入用户空间的events中，让服务端知道这些fd就绪了</li>
<li>服务端会判断时间类型，判断是否是ssfd可读，有错就会返回错误响应<ul>
<li>是ssfd可读，代表有客户端socket希望要建立一个连接<ul>
<li>建立连接后又生成对应客户端的监听FD，然后epoll_ctl将该FD添加到红黑树上</li>
</ul>
</li>
<li>不是ssfd，也就是客户端socket可读，说明这是客户端要传入了一些数据，那么服务端会读取这些数据并写出响应</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5）信号驱动IO"><a href="#5）信号驱动IO" class="headerlink" title="5）信号驱动IO"></a>5）信号驱动IO</h3><img src="https://s2.loli.net/2022/07/17/LRbvW1wfOHVtrCY.png" alt="1653911776583" style="zoom:80%;" />

<p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p>
<p><strong>阶段一：</strong></p>
<ul>
<li>用户进程调用sigaction，注册信号处理函数</li>
<li>内核返回成功，开始监听FD</li>
<li>用户进程不阻塞等待，可以执行其它业务</li>
<li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li>收到SIGIO回调信号</li>
<li>调用recvfrom，读取</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，丢失信号</li>
<li>内核空间与用户空间的频繁信号交互性能也较低</li>
<li>类似于操作系统中讲的中断方式</li>
</ul>
<h3 id="6）异步IO-AIO"><a href="#6）异步IO-AIO" class="headerlink" title="6）异步IO-AIO"></a>6）异步IO-AIO</h3><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p>
<p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。</p>
<img src="https://s2.loli.net/2022/07/17/U7dYZuscDfKCP32.png" alt="1653911877542" style="zoom:80%;" />

<ul>
<li>这种模式其实就是将所有工作都交给内核去做了，自己干别的事情，在高并发的情况下会给内核很大的压力</li>
<li>实现这样一个服务有难度</li>
<li>类似操作系统中的DMA和通道，相当于维护了一个服务</li>
</ul>
<h3 id="7）各种IO方式对比"><a href="#7）各种IO方式对比" class="headerlink" title="7）各种IO方式对比"></a>7）各种IO方式对比</h3><p><img src="https://s2.loli.net/2022/07/17/cqvxMlLwJiujkU8.png" alt="image-20220715184145812"></p>
<ul>
<li>只有最后的异步IO方式才是真正的异步</li>
<li>IO操作是同步还是异步，需要判断其第二阶段：<strong>从内核空间读数据到用户空间的过程</strong>是否阻塞</li>
</ul>
<h3 id="8）redis的单线程"><a href="#8）redis的单线程" class="headerlink" title="8）redis的单线程"></a>8）redis的单线程</h3><h4 id="①Redis到底是单线程还是多线程？"><a href="#①Redis到底是单线程还是多线程？" class="headerlink" title="①Redis到底是单线程还是多线程？"></a>①Redis到底是单线程还是多线程？</h4><ul>
<li>如果仅仅聊<strong>Redis的核心业务部分（命令处理）</strong>，答案是单线程</li>
<li>如果是聊整个Redis，那么答案就是多线程</li>
</ul>
<p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p>
<ul>
<li>Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink（bigKey）</li>
<li>Redis v6.0：在核心网络模型中引入多线程，进一步提高对于多核CPU的利用率</li>
</ul>
<p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况</p>
<h4 id="②为什么Redis要选择单线程？"><a href="#②为什么Redis要选择单线程？" class="headerlink" title="②为什么Redis要选择单线程？"></a>②为什么Redis要选择单线程？</h4><ul>
<li>抛开持久化不谈，Redis是纯  <strong>内存操作</strong>，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>
</ul>
<h3 id="9）Redis网络模型解析"><a href="#9）Redis网络模型解析" class="headerlink" title="9）Redis网络模型解析"></a>9）Redis网络模型解析</h3><h4 id="①基本流程"><a href="#①基本流程" class="headerlink" title="①基本流程"></a>①基本流程</h4><p><img src="D:\Typora\TyporaPictureBed\image-20220812112844387.png" alt="image-20220812112844387"></p>
<p><img src="D:\Typora\TyporaPictureBed\image-20220812112741940.png" alt="image-20220812112741940"></p>
<p>①服务端首先会创建epoll，类似于epoll_create，也就是在内存空间创建红黑树—FD会被放在红黑树上（这里就是aeEventLoop，在这里会等待FD就绪）</p>
<ul>
<li>这里的EventLoop就等同于epoll中的eventPoll</li>
</ul>
<p>②aeApiAddEvent就类似于epoll中的epoll_ctl函数，会将对应的FD注册到eventLoop中的红黑树上</p>
<p>③aeApiPoll就类似于epoll_wait，他会不断地去获得已经就绪的FD，它会获得已经就绪的FDs，然后遍历FDs并调用对应的处理器</p>
<ul>
<li><p>如果是serverSocket可读，那么说明这是一个用户端socket连接，那就交由<strong>连接应答处理器</strong>来处理</p>
<ul>
<li><p>它会accept建立起服务端和客户端连接，并注册一个该<strong>客户端可读的FD</strong>并且设置对应的客户端socket可读的处<strong>命令请求处理器</strong></p>
</li>
<li><p>客户端socket和服务器socket连接，redis会将其封装成一个Client实例</p>
</li>
<li><p>这个FD就是以后该客户端传来命令参数，就是客户端可读的FD就会就绪，也就是然后交给<strong>命令请求处理器</strong>进行处理</p>
</li>
</ul>
</li>
<li><p>如果是客户端可读，那么就会调用<strong>命令请求处理器</strong>来进行处理</p>
<ul>
<li>说明之前该客户端已经和服务端建立了连接了，这次传的是具体的命令参数</li>
<li><strong>命令请求处理器</strong>会获得每一个clientSocket封装的client（包含了客户端所有信息：请求信息…），并且把请求数据写入对应client的输入缓冲区<ul>
<li>然后再将输入缓冲区的数据解析成redis命令并单线程执行</li>
<li>最后把结果写入客户端输出缓冲区，如果客户端输出缓冲区满了（缓冲区有上限），就写入reply（链表无上限）中</li>
<li>最后将每个client实例放入一个队列中</li>
</ul>
</li>
</ul>
</li>
<li><p>每次在aeApiPoll之前，也就是beforeSleep方法，会注册一个<strong>命令回复处理器</strong>，为<strong>监听客户端socket可写</strong></p>
<ul>
<li>它会遍历要写的队列中的client，将client中的buf中的数据写会socket中，这样客户端就可以拿到结果了</li>
</ul>
</li>
</ul>
<p>综上：其实就是一个<strong>IO多路复用+事件派发</strong>的过程，只不过回调函数都设置成了各种处理器，然后相应的去执行这些任务</p>
<h4 id="②多线程"><a href="#②多线程" class="headerlink" title="②多线程"></a>②多线程</h4><p><img src="D:\Typora\TyporaPictureBed\image-20220812120759073.png" alt="image-20220812120759073"></p>
<ol>
<li><p>命令请求处理器中需要从<strong>socket中读出请求数据（client中封装了请求信息：发了什么样的命令）</strong>，并且<strong>解析命令</strong>，这部分涉及到IO操作，所以是多线程</p>
<ul>
<li>从client读取请求数据：命令等，写入客户端的输入缓冲区，也是client中的queryBuf中，涉及到IO操作（多线程）</li>
<li>然后解析queryBuf中的命令（多线程）</li>
<li>单线程执行命令并放入client中的输出缓冲区replyBuf中，buf放不下就放入reply链表（多线程）</li>
</ul>
</li>
<li><p>命令回复处理器：将队列中的client中buf存的结果写入客户端socket，涉及到网络IO（多线程）</p>
</li>
</ol>
<h2 id="4-Redis通信协议"><a href="#4-Redis通信协议" class="headerlink" title="4.Redis通信协议"></a>4.Redis通信协议</h2><h3 id="1）RESP"><a href="#1）RESP" class="headerlink" title="1）RESP"></a>1）RESP</h3><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p>
<ul>
<li><p>客户端（client）向服务端（server）发送一条命令</p>
</li>
<li><p>服务端解析并执行命令，返回响应结果给客户端</p>
</li>
</ul>
<p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p>
<p>在Redis中采用的是RESP（Redis Serialization Protocol）协议，是一种应用层协议：</p>
<ul>
<li><p>Redis 1.2版本引入了RESP协议</p>
</li>
<li><p>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</p>
</li>
<li><p>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</p>
</li>
</ul>
<p>但目前因为RESP2和RESP3的不能兼容，所以默认使用的依然是RESP2协议，也是我们要学习的协议版本（以下简称RESP）。</p>
<blockquote>
<p>补充：<a target="_blank" rel="noopener" href="https://toutiao.io/posts/2c0g5j/preview">https://toutiao.io/posts/2c0g5j/preview</a></p>
</blockquote>
<p><strong>RESP2：</strong></p>
<p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p>
<ul>
<li><p>单行字符串：首字节是 ‘<code>+</code>’ ，后面跟上单行字符串，以CRLF（ “\r\n” ）结尾。例如返回”OK”： “+OK\r\n”</p>
</li>
<li><p>错误（Errors）：首字节是 ‘<code>-</code>’ ，与单行字符串格式一样，只是字符串是异常信息，例如：”-Error message\r\n”</p>
</li>
<li><p>数值：首字节是 ‘<code>:</code>’ ，后面跟上数字格式的字符串，以CRLF结尾。例如：”:10\r\n”</p>
</li>
<li><p>多行字符串：首字节是 ‘<code>$</code>’ ，表示二进制安全的字符串，最大支持512MB：</p>
<ul>
<li>如果大小为0，则代表空字符串：”$0\r\n\r\n”</li>
<li>如果大小为-1，则代表不存在：”$-1\r\n”</li>
</ul>
</li>
<li><p>数组：首字节是 ‘*’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/o9PeLCxTbDkUXWt.png" alt="1653982993020"></p>
<h3 id="2）基于Socket自定义Redis的客户端"><a href="#2）基于Socket自定义Redis的客户端" class="headerlink" title="2）基于Socket自定义Redis的客户端"></a>2）基于Socket自定义Redis的客户端</h3><p>Redis支持TCP通信，因此我们可以使用Socket来模拟客户端，与Redis服务端建立连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Socket s;</span><br><span class="line">    <span class="keyword">static</span> PrintWriter writer;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.建立连接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;192.168.150.101&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="comment">// 2.获取输出流、输入流</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream(), StandardCharsets.UTF_8));</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.发出请求</span></span><br><span class="line">            <span class="comment">// 3.1.获取授权 auth 123321</span></span><br><span class="line">            sendRequest(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name yy</span></span><br><span class="line">            sendRequest(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;yy&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name yy</span></span><br><span class="line">            sendRequest(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name yy</span></span><br><span class="line">            sendRequest(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;num&quot;</span>, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5.释放连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="literal">null</span>) reader.close();</span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="literal">null</span>) writer.close();</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="literal">null</span>) s.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">handleResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 读取首字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefix</span> <span class="operator">=</span> reader.read();</span><br><span class="line">        <span class="comment">// 判断数据类型标示</span></span><br><span class="line">        <span class="keyword">switch</span> (prefix) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// 单行字符串，直接读一行</span></span><br><span class="line">                <span class="keyword">return</span> reader.readLine();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// 异常，也读一行</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(reader.readLine());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>: <span class="comment">// 数字</span></span><br><span class="line">                <span class="keyword">return</span> Long.parseLong(reader.readLine());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: <span class="comment">// 多行字符串</span></span><br><span class="line">                <span class="comment">// 先读长度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化）</span></span><br><span class="line">                <span class="keyword">return</span> reader.readLine();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> readBulkString();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;错误的数据格式！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">readBulkString</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取数组大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义集合，接收多个元素</span></span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">        <span class="comment">// 遍历，依次读取每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            list.add(handleResponse());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set name yy</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">        writer.println(<span class="string">&quot;*&quot;</span> + args.length);</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            writer.println(<span class="string">&quot;$&quot;</span> + arg.getBytes(StandardCharsets.UTF_8).length);</span><br><span class="line">            writer.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-Redis过期策略"><a href="#5-Redis过期策略" class="headerlink" title="5.Redis过期策略"></a>5.Redis过期策略</h2><h3 id="1）过期key的记录"><a href="#1）过期key的记录" class="headerlink" title="1）过期key的记录"></a>1）过期key的记录</h3><p>​	Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p>
<img src="https://s2.loli.net/2022/07/17/CLlEKH9e12ixkcT.png" alt="1653983423128" style="zoom:80%;" />

<ul>
<li>可以看到redisDb中定义了很多dict<ul>
<li>dict：用来存储所有的key和value</li>
<li>expires：用来存储所有的带l的key和对应的ttl</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/OXD82HqSGlJPtUC.png" alt="image-20220716183410671"></p>
<h3 id="2）惰性删除"><a href="#2）惰性删除" class="headerlink" title="2）惰性删除"></a>2）惰性删除</h3><p>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p>
<p><img src="https://s2.loli.net/2022/07/17/RCnZKq89ixEBfAG.png" alt="1653983652865"></p>
<ul>
<li>可以看到在查找一个key执行读写操作的之前都会检查该key是否过期，如果过期了就会删除该key</li>
<li>惰性思想就是用到的时候再去处理</li>
<li>惰性删除并不能保证过期key能按时删除，如果一直没有操作到该key，那么该key就有可能永远不会被删除，所以我们还需要一个任务来周期性地检查并删除过期key</li>
</ul>
<h3 id="3）周期删除"><a href="#3）周期删除" class="headerlink" title="3）周期删除"></a>3）周期删除</h3><p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。</p>
<p>执行周期有两种：</p>
<ul>
<li>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为<strong>SLOW</strong></li>
<li>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为<strong>FAST</strong></li>
</ul>
<h4 id="①slow模式"><a href="#①slow模式" class="headerlink" title="①slow模式"></a>①slow模式</h4><p>SLOW模式规则：</p>
<ul>
<li><p>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</p>
</li>
<li><p>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</p>
</li>
<li><p>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</p>
</li>
<li><p>如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</p>
</li>
</ul>
<p>slow模式的频率是可以配置的，slow模式定时任务在初始化server的时候就会设置，有一个全局变量来记录上一次遍历到哪儿了，这一次该从哪儿遍历</p>
<p>slow模式是一种<strong>低频，长时间的清理</strong></p>
<h4 id="②fast模式"><a href="#②fast模式" class="headerlink" title="②fast模式"></a>②fast模式</h4><p>FAST模式规则（过期key比例小于10%不执行 ）：</p>
<ul>
<li><p>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</p>
</li>
<li><p>执行清理耗时不超过1ms</p>
</li>
<li><p>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期<br>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</p>
</li>
</ul>
<p>fast模式在每次beforeSleep()都会执行过期key，有一个全局变量来记录上一次遍历到哪儿了，这一次该从哪儿遍历</p>
<p>fast模式是一种<strong>高频，短时间的清理</strong></p>
<h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><ul>
<li><p>RedisKey的TTL记录方式：</p>
<ul>
<li>在RedisDB中通过一个Dict记录每个Key的TTL时间</li>
</ul>
</li>
<li><p>过期key的删除策略：</p>
<ul>
<li><p>惰性清理：每次查找key时判断是否过期，如果过期则删除</p>
</li>
<li><p>定期清理：定期抽样部分key，判断是否过期，如果过期则删除。定期清理的两种模式：</p>
<ul>
<li><p>SLOW模式执行频率默认为10，每次不超过25ms</p>
</li>
<li><p>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-内存淘汰策略"><a href="#6-内存淘汰策略" class="headerlink" title="6.内存淘汰策略"></a>6.内存淘汰策略</h2><h3 id="1）基本策略-1"><a href="#1）基本策略-1" class="headerlink" title="1）基本策略"></a>1）基本策略</h3><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰：</p>
<p><img src="https://s2.loli.net/2022/07/17/3enj7HNX4fBCIuE.png" alt="1653983978671"></p>
<p>Redis支持8种不同淘汰策略来选择要删除的key：</p>
<ul>
<li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li>
<li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li>
<li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li>
<li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</li>
<li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li>
<li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li>
<li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li>
<li>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰<br>比较容易混淆的有两个：<ul>
<li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li>
<li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li>
</ul>
</li>
</ul>
<p>可以通过修改配置来选择淘汰策略：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#The default is:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#maxmemory-policy noeviction</span></span><br></pre></td></tr></table></figure>



<h3 id="2）基本流程"><a href="#2）基本流程" class="headerlink" title="2）基本流程"></a>2）基本流程</h3><p>Redis的数据都会被封装为RedisObject结构：</p>
<p><img src="https://s2.loli.net/2022/07/17/52eNlbAV1wkxFja.png" alt="image-20220716211949857"></p>
<p>redisObject的内存淘汰参数会根据配置来进行修改：</p>
<p>LRU：</p>
<ul>
<li>记录最近一次访问时间，因为只有24bit，所以会以秒为单位</li>
</ul>
<p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p>
<ul>
<li>生成0~1之间的随机数R</li>
<li>计算1&#x2F;(旧次数 * lfu_log_factor + 1)，记录为P，lfu_log_factor默认是10</li>
<li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li>
<li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1<ul>
<li>因为可能一个key最开始被访问的很多，很快就到255了，但是后来可能近一年都没被访问</li>
<li>即LFU的高16位记录上一次访问时间，如果距离上一次访问时间间隔lfu_decay_time，计数器-1</li>
</ul>
</li>
</ul>
<p>整体的流程如下</p>
<p><img src="https://s2.loli.net/2022/07/17/s5LPMCAZwc4JDyt.png" alt="image-20220716212603095"></p>
<p>①在进行淘汰的时候不能将所有DB中的key拿来做比较，这样开销太大了。redis会逐个从DB中随机挑选一部分key放入驱逐池中</p>
<p>②驱逐池向外提供了一个统一的接口：驱逐池会按某个标准升序排序，排序越大，淘汰优先级越高，即倒序淘汰key，因此三种淘汰法都需要实现该接口：</p>
<ul>
<li>TTL越小越先被淘汰：<ul>
<li>用maxTTL-TTL&#x3D;生命已经度过的时间，那么算出来结果越大，说明越需要被淘汰</li>
</ul>
</li>
<li>LRU：<ul>
<li>用now-LRU的值（最近一次访问时间），越大说明最近一次访问时间离现在越远，越该被淘汰</li>
</ul>
</li>
<li>LFU：<ul>
<li>有255-LFU计数，说明访问的次数越小，那么就越该被淘汰</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/14/JVM/" rel="prev" title="JVM">
      <i class="fa fa-chevron-left"></i> JVM
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">一、基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%91%BD%E4%BB%A4"><span class="nav-text">1.数据类型和命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">1）通用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89String%E7%B1%BB%E5%9E%8B"><span class="nav-text">2）String类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">①基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1key%E7%9A%84%E5%B1%82%E7%BA%A7%E5%91%BD%E5%90%8D"><span class="nav-text">②key的层级命名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89Hash%E7%B1%BB%E5%9E%8B"><span class="nav-text">3）Hash类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89List%E7%B1%BB%E5%9E%8B"><span class="nav-text">4）List类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89Set%E7%B1%BB%E5%9E%8B"><span class="nav-text">5）Set类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89SortedSet%E7%B1%BB%E5%9E%8B"><span class="nav-text">6）SortedSet类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%89bitMap"><span class="nav-text">7）bitMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%EF%BC%89Geo"><span class="nav-text">8）Geo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring-Data-%E5%B0%81%E8%A3%85"><span class="nav-text">2.Spring Data 封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-text">1）准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89RedisTemplate"><span class="nav-text">2）RedisTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E9%BB%98%E8%AE%A4%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">①默认序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%85%8D%E7%BD%AERedisTemplate"><span class="nav-text">②配置RedisTemplate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2StringRedisTemplate%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">③StringRedisTemplate（推荐）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8"><span class="nav-text">二、实际使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB"><span class="nav-text">1.Redis实现session共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%8E%9F%E5%A7%8Bsession%E5%85%B1%E4%BA%AB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">1）原始session共享的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89redis%E8%A7%A3%E5%86%B3"><span class="nav-text">2）redis解决</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AD%98redis"><span class="nav-text">①验证码存redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%E5%AD%98%E5%85%A5redis"><span class="nav-text">②用户状态存入redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A0%A1%E9%AA%8C%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81"><span class="nav-text">③拦截器校验登录状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="nav-text">④一个小问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis%E7%BC%93%E5%AD%98"><span class="nav-text">2.Redis缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="nav-text">1）基本概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%B7%BB%E5%8A%A0%E7%BC%93%E5%AD%98"><span class="nav-text">2）添加缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0"><span class="nav-text">3）缓存更新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-text">①缓存更新策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88"><span class="nav-text">②主动更新方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%AE%9E%E6%96%BD%E7%BB%86%E8%8A%82"><span class="nav-text">③实施细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3example"><span class="nav-text">④example</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-text">4）缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E7%BC%93%E5%AD%98%E7%A9%BA%E5%80%BC%E5%AE%9E%E7%8E%B0"><span class="nav-text">②缓存空值实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4"><span class="nav-text">③布隆过滤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-text">5）缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-text">6）缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">①互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="nav-text">②逻辑过期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%89%E5%B0%81%E8%A3%85%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7"><span class="nav-text">7）封装缓存工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="nav-text">三、分布式缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">1.Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89RDB"><span class="nav-text">1）RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="nav-text">①执行时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1RDB%E5%8E%9F%E7%90%86"><span class="nav-text">②RDB原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2RDB%E9%97%B4%E9%9A%94"><span class="nav-text">③RDB间隔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E7%BC%BA%E7%82%B9"><span class="nav-text">④缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89AOF"><span class="nav-text">2）AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0AOF%E5%8E%9F%E7%90%86"><span class="nav-text">①AOF原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1AOF%E9%85%8D%E7%BD%AE"><span class="nav-text">②AOF配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2AOF%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99"><span class="nav-text">③AOF文件重写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89RDB%E4%B8%8EAOF%E5%AF%B9%E6%AF%94"><span class="nav-text">3）RDB与AOF对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis%E4%B8%BB%E4%BB%8E"><span class="nav-text">2.Redis主从</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1）基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="nav-text">2）全量同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">①基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="nav-text">②完整流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="nav-text">3）增量同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="nav-text">①完整流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1repl-backlog%E5%8E%9F%E7%90%86"><span class="nav-text">②repl_backlog原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="nav-text">4）主从同步优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis%E5%93%A8%E5%85%B5"><span class="nav-text">3.Redis哨兵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="nav-text">1）集群结构和作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86"><span class="nav-text">①集群监控原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%9B%86%E7%BE%A4%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86"><span class="nav-text">②集群故障恢复原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%B0%8F%E7%BB%93"><span class="nav-text">③小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89RedisTemplate%E9%85%8D%E7%BD%AE"><span class="nav-text">2）RedisTemplate配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">①引入依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%85%8D%E7%BD%AERedis%E5%9C%B0%E5%9D%80"><span class="nav-text">②配置Redis地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-text">③配置读写分离</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="nav-text">4.Redis分片集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E6%90%AD%E5%BB%BA%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="nav-text">1）搭建分片集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="nav-text">2）散列插槽</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1example"><span class="nav-text">②example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%B0%8F%E7%BB%93-1"><span class="nav-text">③小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="nav-text">3）集群伸缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-text">①相关命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="nav-text">②需求分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84redis%E5%AE%9E%E4%BE%8B"><span class="nav-text">③创建新的redis实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9%E5%88%B0redis"><span class="nav-text">④添加新节点到redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E8%BD%AC%E7%A7%BB%E6%8F%92%E6%A7%BD"><span class="nav-text">⑤转移插槽</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-text">4）故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-text">①自动故障转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%89%8B%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-text">②手动故障转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2example"><span class="nav-text">③example</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89RedisTemplate%E8%AE%BF%E9%97%AE%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="nav-text">5）RedisTemplate访问分片集群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5redis%E7%9A%84starter%E4%BE%9D%E8%B5%96"><span class="nav-text">①引入redis的starter依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%85%8D%E7%BD%AE%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E5%9C%B0%E5%9D%80"><span class="nav-text">②配置分片集群地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-1"><span class="nav-text">③配置读写分离</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">四、多级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1.基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="nav-text">2.JVM进程缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89Caffeine"><span class="nav-text">1）Caffeine</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1API%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="nav-text">②API及使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%AE%9E%E7%8E%B0JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="nav-text">2）实现JVM进程缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E9%9C%80%E6%B1%82"><span class="nav-text">①需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0"><span class="nav-text">②实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis%E9%A2%84%E7%83%AD"><span class="nav-text">3.Redis预热</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="nav-text">4.缓存同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5"><span class="nav-text">1）基本策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E8%AE%A4%E8%AF%86Canal"><span class="nav-text">2）认识Canal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-text">3）具体流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-1"><span class="nav-text">①引入依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE"><span class="nav-text">②编写配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E4%BF%AE%E6%94%B9Item%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="nav-text">③修改Item实体类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E7%BC%96%E5%86%99%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">④编写监听器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Redis%E5%AE%9E%E8%B7%B5"><span class="nav-text">五、Redis实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E9%94%AE%E5%80%BC%E8%AE%BE%E8%AE%A1"><span class="nav-text">1.Redis键值设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E4%BC%98%E9%9B%85%E7%9A%84key%E7%BB%93%E6%9E%84"><span class="nav-text">1）优雅的key结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89BigKey"><span class="nav-text">2）BigKey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1BigKey%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="nav-text">②BigKey的危害</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0BigKey"><span class="nav-text">③如何发现BigKey</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a%EF%BC%89redis-cli-%E2%80%93bigkeys"><span class="nav-text">a）redis-cli –bigkeys</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b%EF%BC%89scan%E6%89%AB%E6%8F%8F"><span class="nav-text">b）scan扫描</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c%EF%BC%89%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7"><span class="nav-text">c）第三方工具</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d%EF%BC%89%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7"><span class="nav-text">d）网络监控</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4BigKey"><span class="nav-text">④如何删除BigKey</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%81%B0%E5%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">3）恰当的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%AD%98%E5%82%A8User%E5%AF%B9%E8%B1%A1"><span class="nav-text">①存储User对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a%EF%BC%89%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Ajson%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">a）方式一：json字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b%EF%BC%89%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AD%97%E6%AE%B5%E6%89%93%E6%95%A3"><span class="nav-text">b）方式二：字段打散</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c%EF%BC%89%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9Ahash%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">c）方式三：hash（推荐）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E4%BC%98%E5%8C%96%E8%B6%85%E5%A4%A7hash"><span class="nav-text">②优化超大hash</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a%EF%BC%89%E6%96%B9%E6%A1%88%E4%B8%80"><span class="nav-text">a）方案一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b%EF%BC%89%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="nav-text">b）方案二</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c%EF%BC%89test"><span class="nav-text">c）test</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E5%B0%8F%E7%BB%93"><span class="nav-text">4）小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%89%B9%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96"><span class="nav-text">2.批处理优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8Eredis%E4%BA%A4%E4%BA%92"><span class="nav-text">1）客户端与redis交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%8D%95%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">①单个命令的执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1N%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">②N条命令的执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-text">③批处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89mset"><span class="nav-text">2）mset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0example"><span class="nav-text">①example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E7%BC%BA%E7%82%B9"><span class="nav-text">②缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%8D%95%E6%9C%BAPipeline"><span class="nav-text">3）单机Pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-text">4）集群下的批处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5"><span class="nav-text">①基本策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E4%B8%B2%E8%A1%8C%E5%8C%96%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5"><span class="nav-text">②串行化执行代码实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1Spring%E4%B8%ADlettuce%E5%A4%84%E7%90%86"><span class="nav-text">②Spring中lettuce处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="nav-text">3.服务器端优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-text">1）持久化配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BC%98%E5%8C%96-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-text">2）服务器端优化-慢查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="nav-text">①什么是慢查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-text">②慢查询相关配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="nav-text">③如何查看慢查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E6%95%8F%E6%84%9F%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE"><span class="nav-text">3）敏感命令及安全配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89Redis%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E5%92%8C%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="nav-text">4）Redis内存划分和内存配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="nav-text">①基本问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-text">②相关命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%85%E5%AD%98"><span class="nav-text">③缓冲区内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89%E9%9B%86%E7%BE%A4%E4%BC%98%E5%8C%96-%E9%9B%86%E7%BE%A4%E8%BF%98%E6%98%AF%E4%B8%BB%E4%BB%8E"><span class="nav-text">5）集群优化-集群还是主从</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">①分片集群的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9B%86%E7%BE%A4%E8%BF%98%E6%98%AF%E4%B8%BB%E4%BB%8E%EF%BC%9F"><span class="nav-text">②到底是集群还是主从？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81Redis%E5%8E%9F%E7%90%86"><span class="nav-text">六、Redis原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1.Redis底层数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9ASDS"><span class="nav-text">1）动态字符串：SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="nav-text">②动态扩容</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89intSet"><span class="nav-text">2）intSet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-5"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">②源码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89Dict"><span class="nav-text">3）Dict</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-6"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1rehash%E6%89%A9%E5%AE%B9"><span class="nav-text">②rehash扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E6%80%BB%E7%BB%93"><span class="nav-text">③总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89ZipList"><span class="nav-text">4）ZipList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0ZipList%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">①ZipList基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1ZipListEntry"><span class="nav-text">②ZipListEntry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2Encoding%E7%BC%96%E7%A0%81"><span class="nav-text">③Encoding编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3ZipList%E7%9A%84%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="nav-text">④ZipList的连锁更新问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E6%80%BB%E7%BB%93"><span class="nav-text">⑤总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89QuickList"><span class="nav-text">5）QuickList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BD%9C%E7%94%A8"><span class="nav-text">①作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE"><span class="nav-text">②基本设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">③源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E6%80%BB%E7%BB%93"><span class="nav-text">④总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89SkipList"><span class="nav-text">6）SkipList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-7"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="nav-text">②源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E6%80%BB%E7%BB%93-1"><span class="nav-text">③总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%89RedisObject"><span class="nav-text">7）RedisObject</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-8"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1Redis%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-text">②Redis的编码方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BC%96%E7%A0%81"><span class="nav-text">③五种数据结构对应的编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">2.Redis基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89String"><span class="nav-text">1）String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-9"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1RAW"><span class="nav-text">②RAW</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2embStr"><span class="nav-text">③embStr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3int%EF%BC%88Long%E8%8C%83%E5%9B%B4%EF%BC%89"><span class="nav-text">④int（Long范围）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3"><span class="nav-text">⑤其它相关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89List"><span class="nav-text">2）List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89Set"><span class="nav-text">3）Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-10"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1IntSet"><span class="nav-text">②IntSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2Dict"><span class="nav-text">③Dict</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89Zset"><span class="nav-text">4）Zset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-11"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1SkipList-HT"><span class="nav-text">②SkipList+HT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2ZipList"><span class="nav-text">③ZipList</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89Hash"><span class="nav-text">5）Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-12"><span class="nav-text">①基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1HT-Dict"><span class="nav-text">②HT(Dict)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2Ziplist"><span class="nav-text">③Ziplist</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-text">3.Redis网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%A9%BA%E9%97%B4"><span class="nav-text">1） 用户空间和内核态空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E9%98%BB%E5%A1%9EIO-BIO"><span class="nav-text">2）阻塞IO-BIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E9%9D%9E%E9%98%BB%E5%A1%9EIO-NIO"><span class="nav-text">3）非阻塞IO-NIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">4）IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-text">①基本思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1select"><span class="nav-text">②select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2poll"><span class="nav-text">③poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3epoll"><span class="nav-text">④epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4epoll%E4%B8%AD%E7%9A%84ET%E5%92%8CLT"><span class="nav-text">⑤epoll中的ET和LT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84web%E6%B5%81%E7%A8%8B"><span class="nav-text">⑥基于epoll的web流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%89%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-text">5）信号驱动IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%89%E5%BC%82%E6%AD%A5IO-AIO"><span class="nav-text">6）异步IO-AIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%89%E5%90%84%E7%A7%8DIO%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="nav-text">7）各种IO方式对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%EF%BC%89redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-text">8）redis的单线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0Redis%E5%88%B0%E5%BA%95%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">①Redis到底是单线程还是多线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E8%A6%81%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">②为什么Redis要选择单线程？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%EF%BC%89Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90"><span class="nav-text">9）Redis网络模型解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-text">①基本流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">②多线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-text">4.Redis通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89RESP"><span class="nav-text">1）RESP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%9F%BA%E4%BA%8ESocket%E8%87%AA%E5%AE%9A%E4%B9%89Redis%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">2）基于Socket自定义Redis的客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-text">5.Redis过期策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E8%BF%87%E6%9C%9Fkey%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="nav-text">1）过期key的记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-text">2）惰性删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%91%A8%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-text">3）周期删除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0slow%E6%A8%A1%E5%BC%8F"><span class="nav-text">①slow模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1fast%E6%A8%A1%E5%BC%8F"><span class="nav-text">②fast模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E6%80%BB%E7%BB%93"><span class="nav-text">4）总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-text">6.内存淘汰策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5-1"><span class="nav-text">1）基本策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-text">2）基本流程</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="f1ashades"
      src="/images/mine.jpg">
  <p class="site-author-name" itemprop="name">f1ashades</p>
  <div class="site-description" itemprop="description">once again I am a child</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">f1ashades</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">743k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">20:38</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
