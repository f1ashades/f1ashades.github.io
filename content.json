{"meta":{"title":"f1ashades' blogs","subtitle":"","description":"once again I am a child","author":"f1ashades","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-06-05T08:58:34.000Z","updated":"2022-06-05T09:42:38.092Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-05T09:03:17.000Z","updated":"2022-06-05T09:04:01.712Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"操作系统笔记","slug":"操作系统","date":"2022-06-06T11:17:48.000Z","updated":"2022-06-09T10:55:09.652Z","comments":true,"path":"2022/06/06/操作系统/","link":"","permalink":"http://example.com/2022/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"操作系统!*!","text":"操作系统!*! 一、操作系统概述1.操作系统的特征 并发： ​ 宏观上是同时发生的，实际微观上是交替进行的 共享： ​ 互斥共享：摄像头资源一段时间只能供一个进程访问 ​ 同时共享：硬盘资源一段时间可供多个进程访问，实际微观上也是交替访问 虚拟： ​ 空分复用技术：运行的程序共需8G内存，实际上只有4G ​ 时分复用技术：单核CPU在一段时间内运行多段程序，看起来是由多个CPU在完成工作 异步： ​ 由于多个程序并发执行，程序间就有可能因获取资源而被堵塞，以不可预知的速度进行。 2.操作系统的发展 3.内核态和用户态 1）内核程序负责系统资源的管理，只有内核程序可以使用特权指令 2）应用程序只能使用非特权指令 3）内核由很多内核程序组成 4）内核态-&gt;用户态，内核程序执行一条修改PSW的特权指令 5）用户态-&gt;内核态，中断引起，硬件自动完成 3.中断1）中断分类 内中断：和CPU内部执行的指令有关 ​ 陷入：用户程序主动执行，是一条特殊的非特权指令，用去请求调用系统服务 ​ 故障：故障可能被修复，被修复后会继续执行 ​ 终止：如正数&#x2F;0，用户程序非法使用特权指令，终止后不会再执行该程序 外中断：与CPU内部无关，中断信号来自外部 ​ 时钟中断：时钟定时中断用户程序1，CPU处理中断信号让用户程序2执行 ​ I&#x2F;0中断：输入输出设备发出的中断信号 2）中断原理 CPU会根据中断信号查询 中断向量表 ，通过指针找到响应的中断处理程序（内核程序） 内中断：在每条指令执行的时候检查是否有异常发生 外中断：在每个指令周期末尾，CPU都会检查外中断 4.系统调用 调用创建文件的库函数后，需要使用 系统调用 ，这时候会传入一个参数（通过传入的参数找到对应的系统调用），执行trap函数进入内核态，执行系统调用（会执行特权指令），执行完以后返回 系统调用实际上就是由操作系统执行的底层的操作：如创建文件、删除文件等 5.操作系统体系结构 大内核和微内核其实的区别就是是否将 进程管理、存储管理、设备管理 纳入内核 二、进程与锁1.进程的概念、组成、特征 进程是动态的，是一次程序运行的过程，同一程序多次启动会对应多个进程。 2.进程的状态及进程状态的转换 进程首先会进入创建态（完成新建PCB等准备工作），然后进入就绪态等待CPU的调度，当CPU运行该进程后进程进入运行态。当运行时出现异常，如整数&#x2F;0就会终止掉该进程，进程进入终止态。若进程在运行过程中需要请求资源但资源还未空闲，如IO设备，那么进程就会进入阻塞态等待资源空闲。当资源空闲，进程有了需要的资源，那么进程将进入就绪态等待CPU调动，CPU在运行该进程后又会重新进入运行态。同时运行态也有可能因为时钟中断进入就绪态。 对于同一状态的进程，操作系统会将它们的PCB组织起来：队列和索引两种方式 3.进程控制1）原语 ​ 原语是程序段，实现了原子性。主要由两条特权指令实现：关中断指令执行后，中断信号将不会影响该任务执行，等到开中断指令执行后，改程序段才能被中断。 ​ 关中断指令和开中断指令必须是特权指令，若是非特权指令，那某一程序就能够一直霸占CPU了。 2）进程控制原语 注意： ​ PCB中存储了上次进程执行的相关信息，在被唤醒后，进程可以根据这些信息还原上次的运行状态。 4. 进程通信1）共享内存 ​ 共享内存就是开辟一片空间供通信进程使用： ​ 基于数据结构—只能根据数据结构进行存储，较低级； ​ 基于存储区—划出一片共享存储区，存储的形式和位置等都由通信进程控制。 2）消息传递 直接通信： ​ 发送进程P直接将msg发送到接收进程Q，并将msg挂到接收进程Q的消息队列中，接收进程Q通过接收原语取得消息 间接通信： ​ 可以有多个发送方向信箱A发送信息，也可以有多个接收方从信箱A接收信息 3）管道通信 管道对于数据的接收相当于于一个单向队列，FIFO。 管道实际上就是一个缓冲区，只有写满数据才能取，只有取完数据管道空了才能写。 要想实现双向通信，必须要要两个管道。 5.线程的实现方式 1）用户级线程 如while（true）循环判断一个值就是一个傻瓜用户级线程，若其中一个线程堵塞了，整个进程都会被堵塞 2）内核级线程 内核级线程的管理由操作系统内核完成，一个用户进程会占用多个内核级线程，线程切换需要系统内完成，切换内核态是有成本的 3）多线程一对一： ​ 其实就是内核级线程 多对一： 一个内核级线程管理多个用户级线程，用户级线程切换不需要经过内核态，但是一个用户级线程阻塞后，其他也会被阻塞 多对多： 一个进程包含多1，2，3个用户级线程，1可由内核级线程1执行，2，3可由内核级线程2并发执行。即一个进程可能对应多个内核级线程。当一个进程对应的所有内核级线程都被阻塞后，才称该进程被阻塞。 6.调度1）高级调度 高级调度是面向队列的，启动一个程序并创建相关进程。外存的作业后备队列-&gt;调入内存，并创建响应PCB，当调出的时候才会撤销。 2）中级调度 ​ 当内存空间不足的时候，会将某些数据调出外存，这些进程的PCB会被组织成挂起队列，中级调度会根据某种策略决定将某个处于挂起状态的进程重新调入内存。 3）低级调度 按照某种策略，从就绪队列中挑选一个进程并将处理机分配给它。 4）七状态模型 挂起的进程是在外存的挂起队列中，阻塞的进程是在内存的阻塞队列中的。 ​ 当内存空间不足，会将某些进程从就绪队列调入外存的就绪挂起队列中，默写阻塞态进程夜游可能会被调入阻塞挂起队列，当需要的事件出现以后该进程就有可能从阻塞挂起变为就绪挂起。运行态的进程也有可能进入就绪挂起。 5）三种调度对比 7.进程调度的时机 切换和过程方式1）切换时机 中断处理不能调度 操作系统内核程序临界区： ​ 临界资源是互斥访问资源，一个进程访问就会上锁，临界区就是这段资源的代码 ​ 如就绪队列就是一种内核程序临界区，访问的时候会上锁，但需要快速释放，如果进行进程调度会浪费时间 ​ 而打印机设备就是普通临界区，访问的时候也会上锁，但是使用这些资源的时候，CPU处于空闲状态，可以进行调度 原语：原子性不能被中断 2）切换过程 从就绪队列中选择一个进程，然后切换该进程： 保存原来运行进程的各种数据：保存现场 恢复选择的进程的现场：通过保存的数据恢复 8.批处理调度算法1）FCFS 先来先服务 https://www.scimall.org.cn/article/detail?id=4813361 2）SJF 短作业优先非抢占式： 抢占式： 注意： 非抢占式中每个进程一旦开始运行会运行到结束，期间如果有新的进程就绪也不会被剥夺处理机。而抢占式则是每当有一个新的进程进入等待队列就会动态计算剩余时间，会产生抢占现象 3）HRRN 高响应比优先 4）对比 9.交互式处理调度算法1）时间片轮转 时间片太大： ​ 会退化成先来先服务FCFS 时间片太小： ​ 导致频繁的进程切换，浪费系统资源 2）优先级调度算法抢占式和非抢占式的区别：前者在执行完一个进程后做判断（主动失去），后者在有新的进程进入就绪队列后就会做判断（剥夺） 抢占式： 非抢占式： 3）多级反馈队列 饥饿情况：持续有高优先级的短进程进入第1级队列，那么低级队列的进程就可能会饥饿。 4）对比 10.进程的同步和互斥1）进程同步​ 制约进程的执行顺序，无论整体顺序如何，吃饭一定要在洗澡的前面 2）进程互斥 临界资源： 进入区：给该资源上锁，保证其它进程无法访问到该资源 临界区：访问临界资源的代码 退出区：解锁 11.进程互斥的软件实现1）单标志法 ​ 缺点：但是若此时turn&#x3D;0，允许进程P0访问，但P0一直不访问，那么P1就无法访问，违反“空闲让进” 2）双标志先检查法 ​ 先检查他人意愿，再表达自己意愿flag ​ 缺点：违反忙则等待，两个进程都可能会进入临界区，因为检查 和 表达意愿 操作不具原子性，违反忙则等待 3）双标志后检查法 ​ 先表达自己意愿，再检查别人意愿 ​ 缺点：可能会导致双方都有意愿，双方都堵塞住进不了，违反空闲让进和有限等待 4）Peterson算法（结合了1 3） 先表达意愿，再谦让，然后判断对方是否有意愿且自己已经谦让了：该算法后谦让的会丧失执行权（改变了之前turn的值） 12.进程互斥的硬件实现 中断屏蔽： ​ 其实就是加入了开中断和关中断（类似原语）：若有多个CPU，那么中断屏蔽只能在一个CPU1上实现互斥，若在CPU2上有对该临界资源的访问，CPU1的约束无法生效；且关中断和开中断属于特权指令，只能运行在内核态，不能让普通程序使用，所以中断屏蔽的方法只适合操作系统的内核进程 TestAndSet和Swap指令： 实际逻辑都是检查是否上锁，若没上锁，自己再上锁：类似双标志先检查法，但硬件实现具有原子性，不用考虑并发 13.信号量机制信号量代表了某一资源的值，如int src代表了打印机数量，那么int src&#x3D;2，说明打印机有两台。 1）整型信号量 ​ ​ P、V操作使用了原语，保证了原子性，但仍然不满足让权等待，会发生忙等问题。 2）记录型信号量 忙等： ​ 当某进程访问资源，但是资源不够的时候，会进入while死循环，这时候无法访问资源但是仍然在占用CPU，所以会浪费CPU资源， 进入忙等状态。 为什么记录型信号量不会发生盲等？ ​ 定义的信号量数据结构中带有等待队列的指针，可以操作相应进程挂在等待队列上等待唤醒 ​ 因为在P（wait）操作的时，当信号量&lt;0，即资源数量不够后，该进程会主动进入阻塞态，让出CPU资源。 ​ 而当V（signal）操作的时候，判断信号量++后是否&lt;&#x3D;0，如果&lt;&#x3D;0，说明仍然有进程在等待资源，那么V操作会唤醒该进程。 14.信号量实现进程互斥和同步 前驱关系1）实现进程互斥 ​ 初始化互斥信号量&#x3D;1（说明该资源只有一个，只允许一个进程使用完后再还回去），进程A在进入区前P操作（申请一个资源并让资源-1，那么唯一的一个资源已经被占用）；进程B要想P申请一个，发现mutex&lt;0，资源没了，进入阻塞状态；进程A用完该资源后会通过V操作mutex++（还回该资源），并唤醒进程B。 2）实现进程同步 ​ 保证12 4相对顺序 初始化mutex&#x3D;0（相当于没有该资源），代码1和代码2的结果相当与生成了一个该资源，那么V(S)使mutex++，代表有了一个该资源，那么P(S)就可以获得该资源并执行接下来的代码。 ​ 若向先执行4，那么P(S)操作没有获得相应的资源，所以会执行block原语进入阻塞态无法执行，只有当12执行产生了对应资源S后才能继续执行，这样就保证了同步的相对 15.各类问题1）生产者和消费者问题 为什么要互斥：因为虽然容量为5，但是多个生产者进程可能会并发修改同一个地址的数据，这样就会导致数据覆盖。 full-&gt;目前产品数量 ，一开始数量要为0，生产者v生产并放入缓冲区+1，消费者才能从缓冲区p消耗取出一个。 empty-&gt;容器剩余容量，一开始数量要为5，生产者p消耗一个容量生产，消费者才能v获得一个产品。 ​ 生产者：先消耗一个容量P(empty)，生产一个产品并放入缓冲区，增加一个目前产品数量V(full) ​ 消费者：消费者先消耗一个目前产品P(full)，从缓冲区拿出一个产平，增加一个缓冲区容量，使用产品 ​ 实现互斥的P操作一定要在实现同步的P操作之后！！！ 2）多类生产者和多类消费者问题 本体可以不用互斥信号量，因为容量总共为1，若为2就不行 3）吸烟者问题 finish：这里也可以理解为桌子上剩下的容量，当吸烟者拿走组合后并吸烟后，容量就会+1，这时候生产者就能生成组合并放桌上 4）读者写者问题 写进程1和其它所有写进程和读进程都互斥，写进程之前需要所有进程的工作都结束 rw：保证读进程和写进程之间的互斥，count：记录有多少个读进程 ②：第一个进程获得文件资源后上rw锁，并使count+1，最后一个读进程读完后count–，并释放rw锁，唤醒写进程 ①：当两个读进程同时执行，这时候两个count都&#x3D;&#x3D;0，而此时读进程A P(rw)上锁，那么读进程2就会被rw锁阻挡，这是不对的 ​ 导致这个问题的原因是这段代码不是一气呵成的，所以可以加一个mutex锁，保证各个读进程在访问该段代码的时候是互斥的 注：以上实现有一个缺点，如果有无限读进程进入，那么写进程就会因为得不到rw锁而被饿死 再增加一个w变量，该变量来保证写进程不会被饿死 ​ 当读进程1 P(w)上锁，此时后来读进程和写进程都会因为w锁没被释放而被阻塞，按照先后顺序排列在一个阻塞队列中 （读进程2-&gt;写进程1），当读进程1在读文件前V(w)释放锁，这时候队首的写进程1就会获得该锁并会堵在rw锁…… w锁保证了 读进程和写进程是按照来的顺序 来获得操作文件的机会 rw：保证读进程和所有写进程之间的互斥 w：保证读进程和写进程按照来的顺序获得机会，不会因为大量读进程而被阻塞 mutex：保证rw上锁的过程一气呵成，不会导致多个读进程的堵塞，保证对count变量操作的互斥 5）哲学家进餐问题 三种解决方案： 16.管程 管程实际上就相当于一个类，成员变量就是需要加锁的对象，一组过程就是定义的函数 每次仅允许一个进程在管程内执行某个函数，编译器负责各进程互斥进入管程 17.死锁相关1）死锁、饥饿、死循环的区别 死锁：死锁是多个进程循环等待对方手里的资源而发生的，并且死锁的进程一定处于阻塞态，等待对方释放资源将自己唤醒 饥饿：可能只有一个进程发生饥饿，如短进程优先算法，如果一直有短进程进入，那么长进程就会发生饥饿 ​ 发生饥饿的进程可能是阻塞态，长期得不到I&#x2F;O设备 ​ 可能是就绪态，如长期得不到处理机 死循环：程序员编码导致 2）死锁发生的4个条件 ​ 互斥条件：对互斥资源的争抢才会导致死锁 ​ 不剥夺条件：各进程持有的资源不能被剥夺，只能主动释放 ​ 请求和保持条件：进程在吃持有别的进程想要的资源时，又在请求其他资源 ​ 循环等待条件：存在一种进程资源的循环等待链 注意： 发生了循环等待不一定发生死锁，如有第6个哲学家持有3号能用的筷子，虽然3在循环等待，但是6若释放则不会死锁：当有其它可替代资源的时候就未必发生死锁 3）死锁的处理策略 18.预防避免死锁1）破坏发生死锁的4个条件 2）银行家算法 安全序列：一个能满足所有进程资源需求的分配序列 不安全状态：当分配了某一些资源后，如果各进程不主动归还一些资源，那么系统有可能不能再满足接下来的资源分配而导致死锁 银行家算法： 银行家算法其实就是在分配资源的时候进行检查，看手上的资源能否满足剩下进程的最大需求，通过回收进程能够得到一条安全序列 19.死锁的检测和解除1）死锁的检测 实际上就是找到了一条安全序列 死锁检测算法：依次消除不阻塞进程相连的边，直到无边可消 2）死锁的解除 剥夺某进程资源（将进程挂起），将资源给其它进程 强制终止某些死锁进程，这样对运行快结束的进程可能代价很高 回退到某一步，可以避免死锁 三、内存1.内存基本知识 2.内存管理1）内存空间的分配与回收 2）内存空间的扩展 3）地址转换 4）内存保护上限寄存器： 重定位寄存器+界地址寄存器： 重定位寄存器记录了该段数据的起始地址，起始地址+逻辑地址&#x3D;物理地址 3.内存的覆盖和交换（扩存）1）覆盖 固定区内存是一直都在的，覆盖区内存可能被覆盖 2）交换 交换其实就是中级调度，调出部分进程到外存的挂起队列，缓解内存的压力 外存分为对换区和文件区，调出的进程会在对换区，对换区IO速度&gt;文件区 4.连续分配管理方式1）单一连续分配 所有的用户区只让一个进程使用，无外部碎片，有内部碎片 2）固定分区分配 分区大小相等和分区大小不等两种，无外部碎片，有内部碎片，若某进程超过最大分区需要覆盖 3）动态分区分配 数据结构： 动态分区分配算法 回收：相邻的空闲分区进行合并 5.基本内存分页管理（离散） 1）分页存储 ​ 分页存储实际就是将内存分成一个个的大小相等的 页框，然后再将进程根据页框大小分成一个个的 页面，最后将这些一个个的页面离散地存放在一个个的页框中。进程的最后一个页面可能并没有页框那么大，这样就有可能产生内部碎片。 ​ 内部碎片：进程在使用内存中分配的空间剩余的空间，如该进程6kb，分配了8kb内存，2kb就是内部碎片 ​ 外部碎片：内存中两个划分区域间难以利用的小空间 2）页表 页表记录了该进程各个页面与页框的映射信息，页表存储在PCB中：页号是隐含的分页顺序，块号是该页在内存中的页框号。 由于一个 页框大小&#x3D;页面大小&#x3D;4KB，所以4GB内存可以有2^32&#x2F;2^12&#x3D;2^20个内存块， 那么至少需要20位来表达页框的编号，由于计算机是B来存，那么就需要3B &#x3D; 24b来表示，2B &#x3D; 16b&lt;20 3）页号、页内偏移量 ​ 该进程逻辑大小200B，页面大小为50B，逻辑地址110B&#x2F;50B&#x3D;2，该逻辑地址在2号页表中，页内偏移量&#x3D;110%50&#x3D;10，说明该地址在从该页起始地址偏移了10B。 一个页面大小为4KB，那么一页的数据量就是2^12B 那么一个逻辑地址前 20位 表示页号，后12位表示这个逻辑地址相较于该页号对应的地址块首地址偏移了多少B 通过该逻辑地址可以推出 页号 和 偏移量 ，查询页表的页号可以找到块号，通过块号可以得到该块起始地址，起始地址+偏移量&#x3D;内存真实地址 4）页表寄存器 5）逻辑地址-&gt;物理地址过程 ​ 首先逻辑地址可以分割出 页号P 和 业内偏移量W，通过页号P 和 页表寄存器的页表长度M（存了共有多少页表项）对比看地址是否越界，越界则会发生内中断。 没越界的话，就会通过页号找到对应的内存块号b，内存块号b*页框大小 + 页内偏移量W &#x3D; 物理地址E eg： 6）页表项储存 页表项是存储在内存中的，一个页面大小&#x3D;页框大小&#x3D;2^12B&#x3D;4096B，页表中一个 页表项大小&#x3D;块号大小&#x3D;3B， 这样内存中一个页框存储页表项的时候会存4096&#x2F;3&#x3D;1365个，最后一个的index是1364，该页框还剩1B内存， 但是下一个index为1365页表项则需从下一个页框中存，则其内存地址为 X+3*1365+1&#x3D;X+4096 所以为了方便，会调整页表项大小（块号大小）使其能被一个页框大小整除，这比如说扩大到4，则一个页框刚好可存2^12&#x2F;2^2&#x3D;2^10个 7）快表 页表（慢表）是存储在内存中的，快表（页表的副本）是存储在cache中的： 首先会查快表再查慢表；或者快慢表一起查 7）两级页表单级页表存在两个问题： 问题1：页表很大的时候需要连续占用多个页框 问题2：进程在运行的时候可能并不需要页表所有内容，只需要访问几个特定页面 问题1解决： 为此我们为 页表 设计一个 页目录表 来实现页表在页框的分散存储 ​ 页表大小为4KB&#x3D;2^12B，所以32位的后12位存业内偏移量，32位的前12位存 页号，则每个页框能存4K&#x2F;4B&#x3D;1K&#x3D;2^10个页表项， 存完所有页表项需要2^10个页框 若可以我们可以将整张页表分为1024个分组，每个分组有1024个页表项，最后制定一个 页目录表 记录叶分组和块号的对应关系 ​ 这样页表就可以分散存储了，这样的话本来需要1024个连续的页框（每个空间有1024个页表项），只需要多申请一个页框，就可以这张页面储存这1024个页框的位置，共1025个页框 问题2解决： 一级页表设置一个属性，说明该页面是否在内存中，如果不在就发生内中断从外存中调入 6.基本内存分段管理（离散）1）分段存储 逻辑地址&#x3D;段号+段内偏移量 过程： 段表寄存器中段表长度M（存了段表项的总数量），若段号&gt;&#x3D;段表长度则越界了 2）分段和分页的对比分段的每一段都是一个共同的逻辑，这样每段的功能相对独立，这样便于用户的管理 分段资源利于共享，因为某段的功能相对独立，而分页的话可能某页框中的一段能访问另一端不能访问 7.段页式管理 段页式实际上就是先进行分段，然后再将每一段进行分页 ​ 首先查段表，根据段号查到对应也变存放的块号，找到页表后，根据页号找到对应 页面数据 存放的块号， 块号*页框大小+页内偏移量&#x3D;物理地址 8.虚拟内存1）局部性原理 时间局部性：while指令被执行了可能还会继续执行，a变量在while指令中，所以短时间会多次访问a地址 空间局限性：指令执行后其前后的指令也有可能被执行，因为内存中大部分数据都是连续存放的 2）虚拟内存特点 实现虚拟内存的两个方向： 作业运行不需要一次性装入，可以将先要用到的先装入，然后多次调入内存 作业运行的时候不需要一直常驻内存，短时间不需要的先调入外存，用到的时候再换进来 虚拟内存在逻辑上扩充了内存的大小 3）实现 传统的非连续分配是将进程所有数据调入，虚拟内存的请求方式会灵活调出部分数据到外存，并在需要时从外存调入 9.请求分页管理相较于基本分页管理，请求分页最大的不同就是在快表没命中，慢表没有的时候，将相应页面调入内存，同时页表项修改对应数据 10.页面置换算法1）最佳置换算法 注意： 因为该算法需要知道后序将要访问到的页，所以无法实现 发生了缺页中断并不一定会发生页面置换，只有当内存满了以后才会发生调换，当页面有空闲的时候，缺页会直接调入空闲区域 2）先进先出 注意： 效率低 发生Belady异常：分配的物理块变多，效率反而越低 3）最近最久未使用 注意： 效率最接近最佳置换算法，但是需要硬件成本 4）时钟置换算法 为每个页表项添加一个访问位，当某页被访问置1，两轮扫描： 第一轮：扫描寻找访问位为0，并把1置0 第二轮：扫描寻找访问位为0（必有） 5）改进的时钟置换算法 每一个页表项设置&lt;访问位，修改位&gt;，1代表被访问或修改了，四轮扫描： 第一轮：寻找&lt;0,0&gt; 第二轮：寻找&lt;0,1&gt;，并把&lt;x,y&gt;中的x置0 第三轮：寻找&lt;0,0&gt; 第四轮：寻找&lt;0,1&gt;（必有） 11.页面(框)分配策略由于请求分页管理不是将进程所有页面一次性装入，而是装入部分后再根据实际情况调入，所以我们需要为其分配一定页框 1）分配策略、置换策略 驻留集：系统为进程分配的页框集合 固定分配：开始分配一定数量后大小不变 可变分配：开始分配一定数量，根据情况改变，驻留集大小可能改变 局部置换：置换只能是自己进程的页面 全局置换：除了自己进程，也可以置换其它进程 2）何时、何处调入页面 3）抖动和颠簸 驻留集分配不够，进程页面频繁调入调出 可以根据实际工作集大小调整驻留集 四、文件和磁盘1.文件逻辑结构（文件数据的结构） 1）无结构文件 无结构不文件中的数据就是一系列 二进制bit流 和 字符流，txt文件就是一系列 字符流 2）有结构文件 有结构文件中存储的是一条条数据，每条数据的各列可能是定长的，也有可能是不定长的 ①顺序文件 可变长记录： ​ 顺序存储无法随机存取，因为不像数组每一个[]的大小都是相等的 定长记录： ​ 串结构——对每一条记录都随机存储 ​ 顺序结构——按关键字存记录，添加删除都需要再重新调整 ②索引文件 由于不定长文件不能直接查找第i个记录，可以建立一张索引表来记录每条记录的地址 ③索引顺序文件 索引顺序文件是为了解决索引文件可能过大的问题： ​ 索引文件的每条记录记录的不再是单个记录地址，而是顺序的一组数据，如存储逻辑文件的前50个数据 多级顺序文件 我们可以建立多级索引进一步提高效率，类似于mysql中的B+树 2.文件目录（文件的逻辑组织方式） 1）FCB文件数据块 一个文件目录就是各文件FCB的集合，一个文件对应了一个目录项，也就是一个FCB，可以说一个目录中存储的就是FCB的集合 2）单级目录 整个操作系统只有一张目录表，存了所有FCB，所以文件不能重名 3）两级目录 两级目录中的主文件目录记录了各个用户文件目录，不同用户目录的文件可以重名 4）多级（树形）目录 多及目录中不同目录文件名可以重名 5）无环图目录 实际上就是允许了不同目录下的不同文件可以指向同一个地址，方便了文件的共享， 共享计数器记录了文件被几个用户共享了，只有当共享计数器&#x3D;0，每个用户都删除不需要后才会完全删除该文件 6）索引结点（FCB改进） FCB只存储文件名和指向其它结点的指针，其它所有信息都存储在索引结点中 3.文件保护 1）口令保护 相当于设置了一个密码，密码可能在FCB或索引结点中，打开时输入正确指令才能访问 2）加密保护 加密保护就是对原始数据按照一定方式加密转换成，要访问该文件的时候需要使用正确的方式解密，才能获得正确的文件数据。 3）访问控制 针对每个文件建立访问控制表，规定了各个用户的具体权限，也可以分组管理 4.文件共享1）基于索引结点的共享（硬链接） ​ 两个文件的索引结点指针指向同一个索引结点，当user1要删除该文件的时候，索引结点的count–，说明user1不再需要，但是user2还需要。只有当count&#x3D;0，没有人需要的时候才会真正删除该文件 2）基于符号链的共享（软连接） 对应的文件是link文件，link文件指向了如aaa文件，通过aaa来访问文件1，删除link文件不会导致 索引结点1的count– 其实就是windows中的快捷方式 5.已分配文件管理（非空闲管理） 该节主要是针对已为文件分配了磁盘块后，这些磁盘块的管理（组织方式），属于非空闲块（已分配块）的管理。 1）文件块（磁盘块） 类似于内存，磁盘也被划分成了一块一块的（一页一页） 2）连续分配 由于是连续分配，方便查找，但是不方便增删等拓展，顺序访问速度最快，但容易产生碎片 3）链接分配①隐式链接分配 FCB记录了起始块号和结束块号，每个磁盘块有指向下一个磁盘块的指针，拓展简单，不会产生碎片，查找的效率低 ②显式链接分配 不同隐式链接分配，显式链接中各个磁盘块没有指向下一个磁盘块的指针，所有的下一块信息存储在一张文件分配表中FAT， 每一个磁盘都有一张FAT表，开机时会读入内存并常驻内存 4）索引分配 逻辑块就是页面，磁盘块就是页框 索引表就类似于内存分配中的页表，一个进程对应一张或多张页表，一个文件对应一张或多张页表 ①链接索引 ​ 当一个文件的索引表较大，一个磁盘块存不了的时候，就可以存在多个磁盘块上，各个磁盘块用指指针相连，但是这样若需要访问最后一张索引表上记录的地址，那么就需要遍历其之前所有的索引表，效率较低 ②多层索引 ​ 多层索引方案就是分页存储中的多级页表方案，通过一级索引表来记录各个二级页表的地址，在通过二级索引表来查询逻辑地址对应的磁盘块地址 ​ 但这样有一个缺点，一个文件总共只有1KB，采用这种方式会查询三次 ③混合索引 顶级索引就是FCB对应的索引节点，如某一大文件A含几个小文件，A-1小文件只有8个磁盘块，只需要通过直接地址，2次查询就够了（访存2次），某个大文件A-3需要256*256个磁盘块，那么就可以建立二级间接索引，查询3次（访存4次）。 6.逻辑结构和物理结构回顾 ​ 用户存储的数组Stu[]，我们可以通过Stu[1]、Stu[2]这种方式来访问1、2号学生，在我们看来他们的地址是连续的，实际上他们的逻辑地址是连续的。在文件中他们的逻辑地址是数组连续存储的，但是我们需要将将这些文件分块存储在不同的磁盘块，把它们分配在不同的磁盘块，这是操作系统来解决的，这样他们的物理地址是不连续的，但对我们来说，我们可以通过其连续的逻辑地址来访问，而逻辑地址转化成物理地址的过程我们并不关心，这是操作系统需要解决的。 1——逻辑地址 5——物理地址 7.存储空间管理（空闲管理）文件的分配是指对一个文件，我们采用什么样的方式将这个文件的数据组织起来 文件的管理是指对磁盘中的空闲磁盘块，我们应该采用怎样的方式将其组织起来，方便管理 1）文件卷、目录区、文件区 文件卷：C、D、E盘就是一个个文件卷（逻辑卷） 目录区：每一个文件卷中包含了目录区，主要存储了FCB及超级块等用于磁盘存储空间管理的信息 文件区：存储数据的区域 2）空闲表法 空闲表法很类似内存管理中 连续分配管理方式中 的 动态分区分配 类似 空闲表记录了第一个空闲块的块号，并且记录了从该块开始的空闲块数量，如0、1号空闲，记录就是0 2：块号从0开始，有两块空闲 对于磁盘的回收主和动态分区分配类似： 3）空闲链表法①空闲盘块链 ​ 该方式就是将所有空闲的磁盘块连接成一个链表，操作系统记录了链头、链尾指针。 ​ 若某文件申请k个磁盘块，只需要卸掉k个node就行，并且修改操作系统所记录的联投、链尾指针。 ​ 回收的时候只需要将回收的磁盘块接在链尾即可，并且修改链尾指针。 ②空闲盘区链 空闲盘区链和空闲盘块链最大的区别就是，node不再是一个磁盘块而可能是好几块磁盘块组成的一个磁盘区。 同样，操作系统也记录了链头、链尾。 这个和空闲表法很相似，所以分配的方法也很相似。 回收的时候若周围有链表中存储的空闲区了，需要和该区合并在一起，如果没有则作为一个单独的空闲区挂到链尾 4）位示图法（常考） 位示图的每一个格子就代表了一个盘号，本例中1代表已分配，0代表空闲 每一行有0-15格子，16个空闲块0。第0行就是0-15地址块，第一行就是（1 * 16+0）- （1 *16+15）地址块 如31号地址块对应的位示图位置，31&#x2F;16&#x3D;1，31%16&#x3D;15，即第1行15号位置 如何分配：顺序扫描位示图，找到k个相邻或不相邻的0空闲块，算出盘块号并分配，填1 如何回收：计算出回收的字号、位号，在表中位置填0 5）成组链表法 文件卷（如C盘）的目录区记录了超级块，超级块在系统启动的时候需要读入内存并保证内存中的超级块与外存中的超级块数据一致 超级块实际上类似于一个链头，该链表的每个结点结构如下： ①代表了该组的第一个磁盘块，该磁盘块不用作数据存储，而是存储了下一组的磁盘块数量，并记录了下一组所有磁盘块的指针 ②出第一个磁盘块外的所有磁盘块都用作数据存储 eg：100个磁盘块，1个用于存储下一个组的信息，99个用于存储分配的信息 而超级块就是①，存储了第一个组的所有信息 如何分配： ​ 分配的时候若某一组的无剩余，那么需要将该组记录的下一组的信息，修改超级组的数据，因为分配是从前往后分配，而且每一组所挂磁盘块数是定好的 如何回收： 若每一组的限制是100块，当某一块挂的数据块不够99个的时候，直接挂在该组，若满了则作为一个分组并修改超级块的数据 8.文件的基本操作 1）创建文件 使用了“create系统调用” 需要的参数： ​ 申请的大小（盘块数量）、存放路径、文件名（有默认值） steps： ​ 1.在外存中分配所需空间（空闲管理） ​ 2.通过地址找到该目录的目录文件，根据信息创建对一个目录项FCB 2）删除文件 需要的参数： ​ 文件的存放路径、文件名 steps： ​ 1.通过文件的存放路径找到对应的目录文件，并通过文件名找到对应的目录项（FCB） ​ 2.通过FCB记录的索引结点找到对应的磁盘块，回收磁盘块 ​ 3.删除该FCB 3）打开文件 打开一个文件就是将目录文件中该文件的目录项FCB，复制到系统的的打开文件表中。 需要参数： ​ 文件的存放路径、文件名、对文件的操作类型(r、rw、rwx) steps： 1.通过文件存放路径找到对应目录文件，通过文件名找到对应FCB，检查该用户的权限 ​ 2.将目录项复制到内存的打开文件表中，并返回其在该表编号，用户打开该文件需要编号 打开文件表： 每个进程都有一张属于自己的打开文件表，系统中有一张打开文件总表，每个进程打开文件表会由指正指向，系统打开文件表的对应表项 ①读写指针记录了该进程对文件读写进行到的位置 ②访问权限限制了进程对文件的操作 ③每一个进程对应系统打开文件表的一个表项就会使打开计数器+1，只有当计数器为0才会删除该表项 ​ 打开计数器作用： ​ 如要删除一个文件，这时候该文件还在被打开，说明打开计数器!&#x3D;0，就会提醒该文件正在被使用，不能删除 4）关闭文件 某一个进程关闭该文件就会使系统的打开文件表中的打开计数器-1，当打开计数器的值&#x3D;0的时候删除该表项 5）读文件和写文件 ​ 各进程读写文件都可以从本进程的打开文件表中的该文件项的系统索引号找到其在系统打开文件表中的位置，并分别调用 read和write系统调用。 9.文件系统的层次结构 ①8.文件基本操作的知识：系统调用 ②2.文件目录的知识：根据提供的地址找到对应FCB ③3.文件保护的知识：验证访问权限 ④1.逻辑结构的知识：逻辑地址的处理 ⑤5.物理结构的知识：逻辑地址转化成物理地址 ⑥7.存储空间的知识：文件存储空间的分配和回收 ⑦：硬件设备的管理，磁盘的调度等 10.磁盘的基本知识1）磁盘、磁道、扇区 每个扇区的数据量是相等的，磁道就是一圈一圈半径不同的圆 2）读写数据 读写数据需要磁头定位到对应的磁道，磁盘spin的时候磁头滑过对应扇区就能完成读写操作 3）定位磁盘块 柱面号：对应多个盘面的半径相同的磁道 盘面号：某一盘面的编号 扇区号：找到对应盘面的某一扇区 4）一次磁盘读&#x2F;写操作所需时间 1.寻找时间： ①启动磁头臂的时间：物理因数决定 ​ ②移动磁头(寻道时间)：磁头臂移动到对应磁道的时间，可以设计算法改进 2.延迟时间 ​ 旋转磁盘到达对应扇区的时间 3.传输时间 ​ 对应磁盘块的数据读入写入的时间 11.磁盘调度算法（寻道时间） 该部分算法是用来解决寻道时间的 1）先来先服务（FCFS） ​ 按照请求到达的顺序进行移动，若磁道很分散，效率就会很低 2）最短寻找时间优先（SSTF） ​ 优先移动至与当前磁道最近的磁道（贪心，未必全局最优），若有不段近距离请求加入可能造成远距离磁道的”饥饿” 3）扫描算法（Scan） ​ 移动到最右侧才能向左侧移动，移动到最左侧才能向最右侧移动。到达最右侧慢慢想最左侧移动 4）Look调度算法 ​ 和扫描算法相似，最大的不同就是不用移动到最右侧才想左搜索，在移动到184后观察到最左边已经没有请求了，那么直接想左移动 5）循环扫描算法（C-SCAN） ​ 循环扫描算法和扫描算法最大的不同就是到达最右侧以后，不再是一步一步从右侧往左侧扫描，而是立马到达最左侧，中途不处理任何请求，从最左侧往右扫描 ​ 6）C-Look调度算法 ​ C-Lool算法对循环扫描算法的最大改进就是往右扫描的时候不需要到达最右边，到达184后观察到左边已经没有请求了，那么就直接到最左边的一个请求18，而不是最左边的0号磁道 12.延迟时间 若2、3、4逻辑上是连续区域，物理上也设计为连续区域的话是不合适的。 ​ 因为当磁头读取完一个扇区中磁盘块的内容以后，需要一段时间处理，而盘片在不断旋转，那么读取完2后，3就无法马上读取，而是要等待再spin一圈后才能读取 1）交替编号 交替编号可以解决等待磁头臂处理时间的问题，这里还有一个问题 ①为什么磁盘物理地址是 （柱面号，盘面号，扇区号）？（柱面号，盘面号，扇区号）：（000，00，000 ）~（000，01，111） ​ 这样两个相邻的地址，他们的扇区号虽然不同，但是他们的柱面号都是00，说明他们的都是00，01盘面的00号磁道，磁头臂不用移动 ​ 即这两个相邻地址的柱面号都是相同的，不用移动磁头臂（不消耗物理时间） （盘面号，柱面号，扇区号）：（000，00，000 ）~（000，01，111） ​ 这样两个地址都是在同一盘面上，但是柱面号不相同，所以需要移动磁头臂 2）错位命名 ​ 假设：两盘的对应扇区都是相对的0-0,1-1（vertically） ​ 当第一个盘面读取完第0盘0号磁道第1扇区数据后，刚好走到需要读的第1盘的0号磁道第2扇区开头，但是因为磁头臂需要一定时间处理数据，那么第1盘的0号磁道第2扇区就需要第二次spin到的时候才能读取，那么这种方式就是不对的，我们需要扇区编号在vertically 上错开 13.磁盘的管理 1）磁盘的初始化 step1： ​ 划分扇区，扇区可分为头、数据区域、尾，尾部存有FAT ​ FAT：每个磁盘独有的，FAT记录了该磁盘中磁盘块的 物理块号 和 下一块地址 2）引导块 ​ 计算机开始要执行一系列初始化工作（执行自举程序），ROM中存储的数据是不能改变的，开机先启动ROM中的自举装入程序，执行该程序后会找到磁盘启动块中存储的完整的自举程序（可以修改）完成初始化。 3）坏块的管理 坏块的处理： ①FAT上表明，对操作系统不透明（操作系统知道哪些是坏块） ​ ②保留一些备用扇区，这些扇区来替换坏块，对操作系统透明（操作系统并不知道哪些是坏块） 五、IO管理1.I&#x2F;O控制器1）I&#x2F;O控制器各部分 ①CPU通过控制线发出相关命令，通过地址线来指明需要操作的IO设备， ②数据寄存器： ​ 当CPU可以在此处放入或接收一些数据的时候，IO逻辑可从这里取得数据取得或放入数据（如CPU需要IO输出一些数据时） ③控制寄存器： ​ CPU发出的IO指令会有一些参数，这些参数会放在这里，IO逻辑可从此处读入 ④状态寄存器： ​ IO设备可以将各个IO设备的状态放在此处，CPU可读入 ⑤数据：IO逻辑可以将要输入的数据在放在这里让IO设备输出，也可以从此处获得IO输入的数据 ​ 状态：IO逻辑可以从此处获得该IO设备的状态 ​ 控制：IO根据CPU发出的指令和对应参数，在这里指明IO设备执行对应操作 注意： 一个IO控制器可能对应多个IO设备 数据寄存器、控制寄存器、状态寄存器有多个 2）寄存器的编址 ①寄存器与内存同一编址： ​ 简化了指令，控制寄存器可以直接用内存相关指令 ②寄存器独立编址： 需要设置专门的指令来控制寄存器 2.IO控制方式 1）程序直接控制 ​ CPU在发出读指令后，设置状态寄存器为1（代表IO设备还未就绪），然后while访问状态寄存器直到其值为0（IO设备已经就绪）。IO设备在准备好后，会将数据和自身状态传给IO控制器，IO逻辑修改响应寄存器，CPU收到后再进行处理。 CPU需要等待IO设备的准备，并且每一次procedure只能读一个字的数据，效率太低 2）中断驱动方式 ​ 程序直接控制CPU在循环检查等待IO就绪会浪费大量时间，中断驱动会在CPU发出指令后将IO进程阻塞执行其它进程，当IO准备好并发送相关信息给IO控制器后，IO控制器会发出一个中断信号来提醒CPU，CPU会根据该中断信号进行处理。 该方式虽然能够让CPU和IO设备并行工作，但是中断处理恢复现场会浪费时间，并且每一次procedure还是只能读一个字的数据 3）DMA方式 ​ DMA也是一种IO控制器，当CPU发出指令（读入多少数据，数据存在内存什么位置，数据存在外存什么位置），DMA会完成这一些操作，在全部处理完以后才会发出中断信号让CPU来处理。 ​ 读写的块必须是连续的，同时读入内存后这些块也是连续的 ​ 注意：DMA一次完整过程的数据传输是以块为单位的，但是内部在读入的时候还是以一个字为单位 DMA结构： 4）通道控制方式 “通道”可以理解为一种更低级的CPU，只能执行一系列通道指令，并且通道可以对应多个IO控制器 CPU会将通道程序（一系列任务、任务清单），通道读入该通道程序后执行该任务清单，在执行完任务户在发出中断让CPU来处理 DMA和通道的区别： 1.DMA对数据的读取还是由CPU下达命令的，而通道执行的是CPU给出的通道程序 2.DMA可读写单块或连续的多块数据，通道能读写一组数据 3.IO软件层次结构 4.IO核心子系统实现功能 1）IO调度 IO作为一种资源，其调度算法等和进程、磁盘的调度类似 2）设备保护 ​ 设备可以看作是一种文件，其保护机制类似于文件保护的机制，当用户要访问某个IO设备的时候，系统会根据其FCB中记录的信息来判断该用户是否有相应的访问权限。 3）假脱机技术（SPOOLing技术） ①脱机技术和SPOOLing技术的对比 脱机技术： ​ CPU读入读出数据都是通过磁带这种高速的媒介，而用户真正提供或获得的输入输出还是依靠纸带机，但这时候输入输出已经脱离了CPU的控制，CPU在这时可以处理其它更多的请求。 假脱机技术： ​ 输入设备（纸带机）输入的数据会先慢速写入输入缓冲区，输入进程（外围控制机）将输入缓冲区数据写入输入井（输入磁带），输入井中的数据会被高速读入CPU ​ CPU会将输出的数据高速写入到输出井（输出磁带），输出井会通过输出进程（外围控制机）将数据写入输出缓冲区，输出设备（纸带机）会从输出缓冲区慢速读入数据 ②共享打印机例子 ​ 进程在打印数据时会先将数据写入输出井（输出磁带）中，这样在主机层面该进程就好像完成了打印任务，实际上打印的顺序还是按照输出进程中的假脱机文件队列，但这些任务已经不受CPU控制了，这样看起来就是多个文件共享了打印机。 4）设备的分配与回收 ①考虑因数​ 固有属性：要考虑该设备是独占（打印机）还是共享设备（磁盘） ​ 分配算法：资源分配的算法和进程的调度算法类似 ​ 安全性： ​ 安全分配：IO的时候进行该进程进行阻塞 ​ 不安全分配：IO的时候进程继续运行，并且还可以请求其它IO ​ ​ ②静态分配和动态分配 ​ 静态分配：一次性分配完所有资源，否则不分配；运行结束后归还所有资源 ​ 动态分配：在运行过程中需要了再申请，可能发生死锁，可用银行家算法避免 ③设备分配管理的数据结构 一个通道控制表对应多个IO控制器表，一个IO控制器表（HP打印机）对应多个设备控制表（多台相同的打印机） 每张表都有一个等待队列指针，缺少对应资源的进程会将PCB挂在该队列上 ④设备分配的步骤 若让用户使用“物理设备名”扩展性较低，应使用逻辑设备名，每个用户可享有独立的 逻辑设备名和物理设备名映射表 5）缓冲区管理 注意缓冲区最重要的特性： ​ 缓冲区满的时候，才能读取缓冲区的数据 ​ 缓冲区空的时候，才能往缓冲区写数据 ①单缓冲 ②双缓冲 ​ ​ 单缓冲和双缓冲在通信时的区别： ​ 单缓冲： ​ 双缓冲： ​ 管道实际上就是一种缓冲区，要想实现双向通信，必须实施两个管道 ③循环缓冲 ④缓冲池","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"mysql基本语法","slug":"mysql基本语法","date":"2022-06-04T07:29:48.000Z","updated":"2022-06-06T04:09:16.256Z","comments":true,"path":"2022/06/04/mysql基本语法/","link":"","permalink":"http://example.com/2022/06/04/mysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"一些Mysql的基本语法^ ^","text":"一些Mysql的基本语法^ ^ 一、通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 1.DDL（数据定义语言）数据定义语言 1）数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名; 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 2）表操作查询当前数据库所有表：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名; 创建表： 1234567CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;; 修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;; 删除字段：ALTER TABLE 表名 DROP 字段名; 修改表名：ALTER TABLE 表名 RENAME TO 新表名 删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名; 2.DML（数据操作语言）1）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 2）更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1; 删除数据：DELETE FROM 表名 [ WHERE 条件 ]; 3.DQL（数据查询语言）语法： 1234567891011121314SELECT 字段列表FROM 表名字段WHERE 条件列表GROUP BY 分组字段列表HAVING 分组后的条件列表ORDER BY 排序字段列表LIMIT 分页参数 1）基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名; 设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录：SELECT DISTINCT 字段列表 FROM 表名; 转义：SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;&#x2F; 之后的_不作为通配符 2）条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 &gt; 大于 &gt;&#x3D; 大于等于 &lt; 小于 &lt;&#x3D; 小于等于 &#x3D; 等于 &lt;&gt; 或 !&#x3D; 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 &amp;&amp; 并且（多个条件同时成立） OR 或 &amp;#124;&amp;#124; 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： 123456789101112131415161718192021222324252627-- 年龄等于30select * from employee where age = 30;-- 年龄小于30select * from employee where age &lt; 30;-- 小于等于select * from employee where age &lt;= 30;-- 没有身份证select * from employee where idcard is null or idcard = &#x27;&#x27;;-- 有身份证select * from employee where idcard;select * from employee where idcard is not null;-- 不等于select * from employee where age != 30;-- 年龄在20到30之间select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;-- 下面语句不报错，但查不到任何信息select * from employee where age between 30 and 20;-- 性别为女且年龄小于30select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;-- 年龄等于25或30或35select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);-- 姓名为两个字select * from employee where name like &#x27;__&#x27;;-- 身份证最后为Xselect * from employee where idcard like &#x27;%X&#x27;; 3）聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = &quot;广东省&quot;; 4）分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： 12345678910-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）select count(*) from employee group by gender;-- 根据性别分组，统计男性和女性数量select gender, count(*) from employee group by gender;-- 根据性别分组，统计男性和女性的平均年龄select gender, avg(age) from employee group by gender;-- 年龄小于45，并根据工作地址分组select workaddress, count(*) from employee where age &lt; 45 group by workaddress;-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3; 注意事项 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 5）排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： 12345-- 根据年龄升序排序SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;-- 两字段排序，根据年龄升序排序，入职时间降序排序SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 注意事项 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 6）分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： 1234-- 查询第一页数据，展示10条SELECT * FROM employee LIMIT 0, 10;-- 查询第二页SELECT * FROM employee LIMIT 10, 10; 注意事项 起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 7）DQL执行顺序 FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT ①先确定查询的是那些表 from ②根据查询条件来进行查询 where ③根据条件查询完的结果进行分组查询，分组查询完以后再通过having条件筛选 group by having ④将结果最终需要展示的列进行筛选 select ⑤将结果排序 order by ⑥最后确认显示数据的条数 limit 4.DCL1）管理用户查询用户： 12USER mysql;SELECT * FROM user; 创建用户:CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 修改用户密码：ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;; 删除用户：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 例子： 123456789-- 创建用户test，只能在当前主机localhost访问create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;-- 创建用户test，能在任意主机访问create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;create user &#x27;test&#x27; identified by &#x27;123456&#x27;;-- 修改密码alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;-- 删除用户drop user &#x27;test&#x27;@&#x27;localhost&#x27;; 注意事项 主机名可以使用 % 通配 2）权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库&#x2F;表&#x2F;视图 CREATE 创建数据库&#x2F;表 更多权限请看权限一览表 查询权限：SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; 授予权限：GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;; 撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;; 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 5.函数 字符串函数 数值函数 日期函数 流程函数 1）字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 使用示例： 1234567891011121314-- 拼接SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);-- 小写SELECT LOWER(&#x27;Hello&#x27;);-- 大写SELECT UPPER(&#x27;Hello&#x27;);-- 左填充SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- 右填充SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- 去除空格SELECT TRIM(&#x27; Hello World &#x27;);-- 切片（起始索引为1）SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5); 2）数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x&#x2F;y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 3）日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子： 123-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);-- 这样求出来就是now的日期+时间，往后推70年的结果，往前推就是-70 4）流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： 12345678select name, (case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)from employee;select name, (case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;from employee; 6.约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。 1）常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子： 1234567create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age &gt; 0 and age &lt; 120), status char(1) default &#x27;1&#x27;, gender char(1)); 2）外键约束添加外键： 123456789CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 删除&#x2F;更新行为 行为 说明 NO ACTION 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致） RESTRICT 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致） CASCADE 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录 SET NULL 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除&#x2F;更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; 7.多表查询1）多表关系 一对多（多对一） 多对多 一对一 一对多 案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键 多对多 案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 一对一 案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） 2）查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id; 3）内连接查询内连接查询的是两张表交集的部分 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： 12345-- 查询员工姓名，及关联的部门的名称-- 隐式select e.name, d.name from employee as e, dept as d where e.dept = d.id;-- 显式select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; 4）外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： 12345-- 左select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样-- 右select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept 5）自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： 1234-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id; 6）联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： 123SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ... 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 7）子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 ①标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 例子： 123456789-- 查询销售部所有员工select id from dept where name = &#x27;销售部&#x27;;-- 根据销售部部门ID，查询员工信息select * from employee where dept = 4;-- 合并（子查询）select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);-- 查询xxx入职之后的员工信息select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;); ②列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： 123456-- 查询销售部和市场部的所有员工信息select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);-- 查询比财务部所有人工资都高的员工信息select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));-- 查询比研发部任意一人工资高的员工信息select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;)); ③行子查询返回的结果是一行（可以是多列）。常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN 例子： 123-- 查询与xxx的薪资及直属领导相同的员工信息select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;); ④表子查询返回的结果是多行多列常用操作符：IN 例子： 1234-- 查询与xxx1，xxx2的职位和薪资相同的员工select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);-- 查询入职日期是2006-01-01之后的员工，及其部门信息select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id; 二、数据类型1）整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。 2）浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 3）日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 4）字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;&#x3D;M&lt;&#x3D;255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 5）二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)&#x2F;8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 三、权限一览表 具体权限的作用详见官方文档 GRANT 和 REVOKE 允许的静态权限 Privilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限 Privilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration 四、test","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"mysql深入","slug":"mysql深入","date":"2022-06-04T07:29:48.000Z","updated":"2022-06-09T10:57:37.890Z","comments":true,"path":"2022/06/04/mysql深入/","link":"","permalink":"http://example.com/2022/06/04/mysql%E6%B7%B1%E5%85%A5/","excerpt":"一些Mysql的深入0.0","text":"一些Mysql的深入0.0 一、事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作： 1234567891011121314151617181920212223-- 1. 查询张三账户余额select * from account where name = &#x27;张三&#x27;;-- 2. 将张三账户余额-1000update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;-- 查看事务提交方式SELECT @@AUTOCOMMIT;-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效SET @@AUTOCOMMIT = 0;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 设置手动提交后上面代码改为：select * from account where name = &#x27;张三&#x27;;update account set money = money - 1000 where name = &#x27;张三&#x27;;update account set money = money + 1000 where name = &#x27;李四&#x27;;commit; 操作方式二： 开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK; 操作实例： 12345start transaction;select * from account where name = &#x27;张三&#x27;;update account set money = money - 1000 where name = &#x27;张三&#x27;;update account set money = money + 1000 where name = &#x27;李四&#x27;;commit; 1.四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 2.并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 ①脏读（Dirty read）： ​ 数据库中A&#x3D;200，事务1中修改了A&#x3D;100，但是这时候事务1还没有commit，而此时事务2要读取A的值，事务2读取A&#x3D;100，这是事务A修改了但是还没有commit的数据，这种数据就称为’脏数据’，此时就发生了’脏读’。 ②不可重复读（Unrepeatable read） ​ 数据库中id&#x3D;1的数据有一个值为A&#x3D;200，事务A第一次selectid=1的数据查询出A&#x3D;200，此时事务2修改updateid=1的数据使A&#x3D;100并且commit了，此时数据库中的id=1的数据A&#x3D;100，然后事务1第二次读取selectid=1的数据查询出A&#x3D;100和第一次查询出的A&#x3D;200不一致，此时就发生了’不可重复读现象’。 ③幻读（Phantom read） ​ 幻读与不可重复读类似，事务1第一步select查询id&#x3D;1的数据，此时数据库为空没有查到，刚好此时事务2向数据库中插入了id&#x3D;1的数据，此时事务1第二步要插入id&#x3D;1的数据的时候就会报错，当事务1再次查询数据库的时候发现id为1的数据还是没有（因为已经解决了不可重复读的问题，两次查询的结果一致），这时候就发生了’幻读’。因为在插入数据的时候会因为事务2插入的数据失败，事务1会发现已经有了插入的数据，但是查询的时候又看见，就像幻觉一样’Phantom’ ④丢失更新（Lost to modify） 事务1想要修改A&#x3D;20并且读取到了A&#x3D;20数据（此时事务2页读取到了A&#x3D;20），使A&#x3D;A-1，修改的结果为19；事务2读取到A&#x3D;20数据后也要进行修改，使A&#x3D;A-3，得到的结果为17；最终结果为17，看起来就是事务1的结果丢失了。 注： 不可重复读和幻读类似，不可重复读是发生在事务A因为事务B的修改导致两次read的数据不一致，幻读是因为事务A因为事务B的插入数据导致自身插入数据失败，但是两次查询（特别是第二次）发现没有数据（解决了不可重复度的基础上），好像出现了幻觉。 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd 丢失更新相关博客：https://blog.csdn.net/sun8112133/article/details/89853755 并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效 二、存储引擎1. MySQL体系结构 Mysql结构（4层）： ①连接层 ​ 处理来自各个客户端的连接（验证密码等），授权认证及相关安全信息 ②服务层 ​ 最核心的一层，mysql在这一层中完成各类服务，执行sql、sql分析和优化，过程函数都在这一层实行 ③引擎层 ​ mysql实现的是可插拔存储引擎，想用哪个插哪个，默认为InnoDB。同时索引(index)也在这一层，所以各个存储引擎实现索引的方式可能不一样。存储引擎是数据库存储数据、建立索引、更新&#x2F;查询等技术的实现方式，存储引擎是基于表的 ④存储层 ​ 主要是将存储的数据存入系统硬盘上，完成与存储引擎的交互 存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。 相关操作： 12345678-- 查询建表语句show create table account;-- 建表时指定存储引擎CREATE TABLE 表名( ...) ENGINE=INNODB;-- 查看当前数据库支持的存储引擎show engines; 2. 常见引擎1）InnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。 特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性 文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。 参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间 知识点： 查看 Mysql 变量：show variables like &#39;innodb_file_per_table&#39;; 从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibd InnoDB 逻辑存储结构： 2）MyISAMMyISAM 是 MySQL 早期的默认存储引擎。 特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 3）MemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。 特点： 存放在内存中，速度快 hash索引（默认） 文件： xxx.sdi: 存储表结构信息 3. 存储引擎特点比较 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N&#x2F;A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 4. 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性 电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。 三、 索引1. 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 1）二叉搜索树 二叉树的缺点可以用红黑树来解决：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 2）B TreeB Tree相较于二叉搜索树维护了自平衡（左右高度差距不会过大）并且增加了一个节点的字节点数量，eg： 如下图degree&#x3D;5（子节点个数），一共可存4个key（值），x&lt;20，20&lt;&#x3D;x&lt;30，…，…，89&#x3D;&lt;x 为了解决上述问题，可以使用 B-Tree 结构： ​ B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html 3）B+TreeB+ Tree 相较于B Tree就是将数据全部存储在了叶子节点，如下图左下角x&lt;16，16&lt;&#x3D;x&lt;29，29&lt;&#x3D;x 这样key&#x3D;16的数据就存储在了第二个叶子节点 结构图： 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B Tree 的区别： 所有的数据都会出现在叶子节点 叶子节点形成一个单向链表 4）InooDB的改进B+ TreeMySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。 ​ mysql中的B+树对经典的B+树做了优化，1.在叶子相邻叶子节点间添加了一个向前的指针使其成为了双向链表（首尾也是双向指针），这是便于范围搜索和排序 5）Hash索引哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 特点： Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 6）面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 mine： 二叉搜索树在顺序插入的时候会形成一个链表，查询的过程就变成线性的一条一条查询；如果数据量较大，层级变深，搜索效率变慢 B Tree 无论节点还是非叶子节点都会保存数据，而每一个节点都是存储在一页中的，如果非叶子节点要保存value，那么这一页存储的keys就会减少，指针也变少了，要存储更多的数据，只能增加树的高度，导致性能降低了 同时因为改进后的B+树在叶子节点间添加了双向指针，便于范围匹配和排序，而Hash索引不能 2. 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图： 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 思考题 1. 以下 SQL 语句，哪个执行效率高？为什么？ 123select * from user where id = 10;select * from user where name = &#x27;Arm&#x27;;-- 备注：id为主键，name字段创建的有索引 答：第一条语句，因为第二条需要回表查询，相当于两个步骤。 2. InnoDB 主键索引的 B+Tree 高度为多少？ 答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。 如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。 另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。 3. 索引语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引 查看索引：SHOW INDEX FROM table_name; 删除索引：DROP INDEX index_name ON table_name; 案例： 1234567891011-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引create index idx_user_name on tb_user(name);-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引create unique index idx_user_phone on tb_user (phone);-- 为profession, age, status创建联合索引create index idx_user_pro_age_stat on tb_user(profession, age, status);-- 为email建立合适的索引来提升查询效率create index idx_user_email on tb_user(email);-- 删除索引drop index idx_user_email on tb_user; 4. sql性能分析①首先查看执行频次来分析当前数据库，是增删改语句执行的多，还是select语句执行的多 ②通过慢查询日志可以定位哪台主机通过哪个user执行了哪条sql语句，执行效率较低 ③慢查询日志只会记录超过设定时间的sql，如果要查看没有超过时限的sql则需要通过profiles来查询 ④explain会查看sql具体的执行信息 1）查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：全局：SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 会话：SHOW SESSION STATUS LIKE &#39;Com_______&#39;; 例：show global status like &#39;Com_______&#39; 2）慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息： #开启慢查询日志开关 slow_query_log=1 #设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志： long_query_time=2 更改后重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log systemctl restart mysqld 查看慢查询日志开关状态： show variables like &#39;slow_query_log&#39;; 3）profileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作： SELECT @@have_profiling; profiling 默认关闭，可查询其开启情况（0是关闭） select @@profiling; 可以通过set语句在session&#x2F;global级别开启 profiling： SET profiling = 1; 查看所有语句的耗时： show profiles; 查看指定query_id的SQL语句各个阶段的耗时： show profile for query query_id; 查看指定query_id的SQL语句CPU的使用情况 show profile cpu for query query_id; 4）explainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法： # 直接在select语句之前加上关键字 explain &#x2F; desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件; EXPLAIN 各字段含义： id*：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type： 表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等 type*： 表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all 用主键索引或者唯一索引查询，const 用普通索引，ref select ‘A’，NULL possible_key*： 可能应用在这张表上的索引，一个或多个 Key*： 实际使用的索引，如果为 NULL，则没有使用索引 Key_len*： 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows： MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered： 表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 5. 使用规则1）最左前缀法则（联合索引）如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。 ​ 在这样一条联合索引中，索引的顺序分别是：profession（47），age（2），status（5）， profession列一定存在，但在where中的顺序不影响 这样两条sql都会走该联合索引，只是索引长度可能不一致，第一条会按顺序查询 pro，age，status三条索引（54） 下面一条没有status，只会顺序查询pro，age两条索引（49） 中间跳过某一列后，后面的索引就会失效 这样两条sql都会走联合查询，因为有pro在（最左边的列在）（where后and的顺序不重要） 但是只会查询pro索引，因为跳过了中间的age索引（没有），那么age后status索引也不会查询（47） 可以这样说：age单说是没有索引的，因为如果只根据age去查，没有pro的话，age的索引也不会用到 注：如果select字段中包含了该联合查询的字段而不需要回表查询也会使用联合查询 ​ 因为select字段在pro_age_sta的联合索引中都含有，而id则是联合索引的叶子节点值，所以通过索引能将这些值全部查询出来，这样就会使用索引，虽然不满足最左前缀原则，之前不使用是因为select * ，不能直接通过该联合索引获取所有值，需要回表查询 联合索引失效tips： 跳过联合索引中的某一列，该列右边的所有索引都会失效 若在索引上使用了&gt;，&lt; 等范围查询会让该索引右边的列索引失效（自身不会失效） 上面这条查询会查询pro，age，但是age使用了范围查询&gt;，所以age不会失效，status索引会失效（49） 解决办法：在业务允许的情况下，尽量使用&gt;&#x3D;和&lt;&#x3D; 这样查询就会查询pro，age，status三条索引 ​ 2）普通索引失效情况 在索引列上进行运算操作（如函数运算），索引将失效。 如：查询手机号后两位是15的用户 explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;; 这样不会走phone索引，因为在phone索引上进行了函数运算 字符串类型字段使用时，不加引号，索引将失效。 如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 虽然可以查询出来，但是并不会走phone的索引 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。 如：explain select * from tb_user where profession like &#39;%工程&#39;; 前面有%会失效 ​ explain select * from tb_user where profession like &#39;工程%&#39;;后面有%不会失效 注：’_’ 和 ‘%’ 的情况是一样的 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如该条数据，可能会走主键索引，但是最后没走索引，因为age没有索引，解决办法就是为age添加上索引 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 如：explain select * from tb_user where profession is null; pro字段只有少部分是null，所以会走索引 ​ explain select * from tb_user where profession is not null; pro字段大部分都不是null，这样还不如扫描all，所以不会走索引 3）SQL 提示​ 是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的： 如用户告诉mysql在有多个索引的情况下，选择哪个索引而不是让mysql的优化选择器自己选择 例如： 在可能多个索引的情况下： 使用哪个索引： explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;; 不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 4）覆盖索引&amp;回表查询 覆盖索引：根据索引可以查询出所有数据 查询的数据中id值在该联合索引（二级索引）的叶子节点，所以只需要查一次联合索引就可以查询出所有值而不需要回表查询 回表查询：二级索引不能查询出所有值，需要通过查询出的主键id来查询聚集索引获取值 虽然使用了索引查询，但是因为查询的字段中的gender和email是无法通过该联合索引查询出来的，所以在通过二级索引获取了id，profession，age后，还需要通过id值查询聚集索引来获取剩下的gender和email，这就进行了回表查询 5）前缀索引当字段类型为字符串（varchar, text等）时，如果在这些字段上建立索引会导致建立的索引较大，查询时，也会浪费大量的磁盘IO，影响 查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 比如要在email上建立索引，我们可以截取email的前几个char作为索引，这样就可以减小索引长度，可以根据一个比值选择性k来判断取值的合理性：不同的subString&#x2F;all，eg：当我们截取email字段前5个的时候，10个email中8个的前5个char都不一样，只有两个的前5个char是一样的，这时候k&#x3D;8&#x2F;10&#x3D;0.8，我就可以在k和长度之间做取舍 求选择性公式： 12select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user; 语法：create index idx_xxxx on table_name(columnn(n)); show index 里面的sub_part可以看到接取的长度 6）单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况：explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;这句只会用到phone索引字段，该sql会进行回表查询，因为phone的单列索引中并不包含name列 所以我们可以根据查询条件构建联合索引（注意顺序——最左前缀法则） create index idx_user_phone_name on tb_user(phone,name); 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 7）设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 四、 sql优化 1.插入数据（insert，load）普通插入： 采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务（mysql默认自动提交事务，执行3条insert就会有三次事务，可以直接start transaction (3条insert) commit） 主键顺序插入 大批量插入（load本地文件）：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。 ①客户端连接服务端时，加上参数 –local-infile（这一行在bash&#x2F;cmd界面输入）mysql --local-infile -u root -p ②设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 set global local_infile = 1;select @@local_infile; ③执行load指令将准备好的数据，加载到表结构中 load data local infile &#39;/root/sql1.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\\n&#39;; 2.主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT） a. 页分裂： 若不按顺序排列，在后面就会涉及到一个重新排序的页分裂动作 b. 页合并： 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。 如图中14，15，16三条数据已经被标记不被使用，如果此时page2的删除达到阈值，就会尝试将右边的17，18，19合并进一个page MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90 个主键设计原则： 满足业务需求的情况下，尽量降低主键的长度 二级索引叶子节点挂的是主键，如果主键较长，二级索引较大会占用IO，效率变低 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 因为这些是无序插入，会产生页分裂现象，并且长度可能较长 业务操作时，避免对主键的修改 3.order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引 总结： 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 order by phone，age; 在index&#x3D;age，phone的情况下是不会使用索引的，因为首先按phone排序，但是索引第一个是age 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k） 4.group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的 如索引为idx_user_pro_age_stat， select profession,age,coun(*) from tb_user group by profession select age where profession group by age （where 后有了profession，也算是最左） 以上两条都符合最左前缀法则 注意： explain select age,count(age) from tb_user group by age; 虽然也用到了索引，但是也用到了临时表，其实效率并不高 5.limit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化 例如： 12345678-- 此语句耗时很长select * from tb_sku limit 9000000, 10;-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询select id from tb_sku order by id limit 9000000, 10;-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id; 6.count优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis ​ 从上面可以看出，count(1)和count(*)是没有取值的过程，所以小 7.update优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。 如以下两条语句：update student set no = &#39;123&#39; where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = &#39;123&#39; where name = &#39;test&#39;;，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引 五、视图&#x2F;存储过程&#x2F;触发器 1. 视图①语法 1）with cascaded check option v1 通过 user基表建立，v2通过v1建立，v3通过v2建立 当v2表cascaded后，它在insert数据的时候也会检查其所依赖的v1条件；v3没有cascaded，虽然它依赖了cascaded的v2，但是insert的数据检查也只会检查v1，v2的条件，并不会检查v3 2）with local check option local就是会递归的去寻找，满足v2后会看v1的option，如果没有则不会管v1的条件 3）相关事项及实例 注意： 视图的增删改操作必须是视图中的一条数据对应基表的一条数据，若使用了聚合函数、group by、distinct、having、union(all)等，视图是无法更新的 视图的作用： 简单：方便用户对数据理解，可以将经常查询的数据定义成一张视图 安全：视图能让用户只浏览和修改到他们被允许的数据（mysql的表权限中不包含columns的权限） 数据独立：屏蔽真实表结构变化带来的影响 name -&gt; stuName ​ 三表联查： ​ 2. 存储过程1）变量1）系统变量（@@） ​ session：会话变量，在另外一个会话中则不存在，未指定默认是session ​ global：全局变量，在所有会话中都存在，但是在restart mysql后还是不会改变（持久改变需要在配置文件中配置） 2）用户自定义变量（@） 3）局部变量 ​ 只在存储过程中生效 2）存储过程中的语法①if ​ ②case ​ ③while ④repeat ⑤loop ⑥cursor 游标游标类似于一个集合、迭代器，每次从游标中取一行数据 ​ eg： ⑦handler 条件处理程序类似于异常处理，根据捕获的异常码来处理 eg： 这个对游标的改进就是在，游标抛出异常02000（not found）后关闭cursor 3）存储函数 3. 触发器触发器可以在insert&#x2F;update&#x2F;delete 语句执行之后，执行触发器中定义的sql，可以完成日志记录、数据校验等工作 触发器目前只支持 行级触发：如一条语句影响了5行数据，那么触发器会被执行5次 ​ 语句级触发：如一条语句影响了多行数据，但是触发器只会触发一次 1）语法 2）案例 eg1：insert案例 eg2：update案例 eg3：delete案例 六、锁 1. 全局锁​ 1）全局锁是对整个数据库加锁，加锁后可以查询DQL，但是DDL和DML语句都不能执行，主要用于备份： ​ 如在备份库存的过程中，用户下单后，库存扣减，但是备份后的库存还是扣减前的数据，然后开始备份订单表和订单日志表，下单后这些数据都会增加，这两个的备份库都会有新的用户下单的数据，这样就和备份的库存数据不一致了，丧失了数据一致性 2）使用过程 2. 表级锁1）表锁 读锁（表共享读锁）：读锁本会话可读不可写，其他会话也是可读不可写 写锁（表独占写锁）：写锁本会话可读可写，其他会话不可读不可写（会被阻塞，释放锁以后会继续执行） 2）元数据锁在事务中使用sql语句的时候，系统会自动添加 事务A在做select查询并且事务没结束，那么这时候通过alter改变表结构（元数据）是不被允许的 3）意向锁意向锁的作用，一个例子： ​ 当线程A中的事务中执行update语句的时候（根据id索引）会锁住这一行的数据，如果此时有另外一个线程要为该表加read&#x2F;write lock，那么这个线程有需要一条一条的检查看是否有行锁，这样效率太低了 ​ 为解决这一问题，在事务中执行sql语句的时候，mysql除了添加行锁，还会为整张表添加一个意向锁，当其他线程要为该表加锁的时候，就可以根据所加的意向锁判断是否能加锁，而不需要一条一条检查数据 select …. lock in share mode 会添加意向共享锁，可以与表共享读锁（read）兼容，与表独占写锁（write）互斥（会发生阻塞） 增删改、查询for update 会添加意向排他锁，与read和write都互斥 意向锁直接都是兼容的，意向共享锁和read锁兼容和write锁互斥，意向排他锁与read锁和write都互锁 3. 行级锁 1）行锁行锁有两种：s（共享锁）、x（排他锁） 总结： 增删改操作都是加排他锁 普通select不加锁 select语句后加lock in share mode 共享锁，加for update 加排他锁 注意： mysql的行级锁是针对索引的锁，锁住的是聚集索引叶子结点的一个数据，若在增删改的时候没有用到索引，那么行锁就会升级成为表锁 查询元数据锁和行锁的语句 select object_schema,object_name,index_name,lock_type,lock_mode,lock_data fromperformance_schema.data_locks; 2）间隙锁、临键锁 默认情况下，使用的是next-key临键锁来进行搜索和索引扫描，当某些情况下临键锁可以优化成间隙锁： 如当用主键查询不存在的数据的时候： 事务A我们想插入一条id&#x3D;4的数据，第一次查询id&#x3D;4发现没有数据，这时候临键锁优化为间隙锁，将3与5的间隙锁起来（B+树结构中，这两个row是相邻的），那么事务B就不能在3和5间插入id&#x3D;4的事务，那么事务A在插入id&#x3D;4的数据的时候就不会出现幻读的现象 七、InnoDB引擎1. 架构图1）逻辑结构 2）物理结构 逻辑结构： 2. 事务原理 ​ MVCC（无锁）+锁保证了事务的隔离性，redo log 保证了事务的持久性，undo log 保证了事务的原子性，redo log 和 undo log 一起保证了事务的一致性。 1）redo log​ redo log保证了事务的持久性 问题情境： ​ InnoDB内存结构中，主要的内存区就是缓冲池，缓冲池中缓冲了很多的数据页。当我们在一个事务中执行增删改操作的时候，InnoDB会先操作缓冲池中的数据，将缓冲池中的数据修改，在缓冲区中被修改过的数据页称为脏页。脏页会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区中数据和磁盘中的数据一致。因此缓冲区的脏页数据并不是实时刷新的，若过一段时间后在从缓冲区向磁盘刷新数据的过程中出错了，但提示给用户事务提交成功，但是数据却没持久化下来。 解决办法redo log： ​ 有了redo log 后，在对缓冲区的数据进行增删改操作后，会首先将数据页的变化记录在redo log buffer中，在事务提交时会将redo log buffer中的数据刷新到redo log磁盘文件中。如果脏页数据出错，此时就可以借助于redo log来进行数据恢复，以此来保护数据持久性。若 脏页数据已经成功刷新到磁盘 或 涉及到的数据已经落盘，那么redo log就没用了，可以删除了，所以存在的两个redo log文件是循环写的（一个没用了删掉用另一个） 总结： redo log 有两部分 内存：redo log buffer 在事务提交后马上刷新给磁盘中的redo log 磁盘：两个redo log 循环写 为什么不能直接将脏页数据实时刷新，而是刷新redo log buffer中的数据？ 因为操作的数据页地址是随机的，如果实时刷新脏数据，那么就是随机IO（随机读写磁盘），性能低 redo log的刷新是顺序IO（日志按顺序写的），数据效率高 2）undo log​ undo log 保证了事务的原子性 ​ undo log 主要是为了 回滚事务 和 MVCC，不同于redo log 是物理日志，undo log 是逻辑日志： ​ 当在事务中执行了一条insert语句后，undo log就会记录一条相反逻辑的delete语句，执行一条update语句后，undo log就会记录一条相反逻辑的update语句 undo log 的销毁： 在执行完事务后（commit 或 rollback后），并不会马上删除，因为MVCC还可能用到undo log undo log 的存储：undo log 通过段segment的方式存储，（segment有 数据段—B+树叶子节点，索引段—非叶子节点，回滚段—undo log） 两个作用： 回滚：回滚是在事务结束的时候（commit或rollback），如果选择回滚，那么mysql会执行undo log中的逻辑记录 MVCC：undo log 中记录了版本链，版本链配合readview来完成MVCC版本控制 3）MVCC MVCC是在快照读的时候通过事务id，undo log 版本链，ReadView来查找返回的历史版本数据。 MVCC就是通过表中的隐藏字段事务id，undo log 版本链，ReadView（事务确定）三者来实现的： 查询的时候会根据当前的事务活动情况和事务id来确定ReadView，然后再从undo log版本链头部开始通过查看事务id是否满足ReadView的匹配条件，满足条件则返回该版本 ①当前读和快照读a）当前读 当前读读取的是记录的最新版本，读取的需要保证其他并发事务，所以会对读取的数据加锁 eg： ​ 当A事务开启后，①的查询结果id&#x3D;2是PHP，此时开启B事务并执行修改id&#x3D;2为JSP数据操作，再次通过事务A的①查，查不出该次变化，因为当前隔离级别是可重复读，保证了两次读取事务的一致性；如果读取到当前事务的最新数据，可以使用select …. lock in share mode 来进行当前读，这样读取到的就是最新的数据id&#x3D;2是JSP。 b）快照读 ​ 快照读是根据一定规则MVCC读取记录数据的可见版本，有可能是历史数据，这个过程是不加锁的 * 读已提交：每次的select都是一个快照读 * 可重复读：开启事务后的第一个select是快照读，后续的select只是直接使用第一个快照读的数据（查询的实际上是第一个快照数据） * 串行化：快照读退化成当前读 ②隐藏字段 ​ 每一张表都会有两个隐藏字段：最近事务id、回滚指针，如果该表结构未指定主键，那么会生成隐藏字段row_id。 ③undo logundo log 是回滚日志，在insert、update、delete的时候会产生回滚数据来产生。 当insert的时候，数据只需要回滚的时候使用，所以commit后（证明没有rollback）可以直接删除 update、delete，数据不仅在回滚的时候需要使用，在快照读的时候也需要，所以不能删除 https://www.bilibili.com/video/BV1Kr4y1i7ru?p=143&amp;spm_id_from=pageDriver undo log 版本链： 每当要修改一条记录的时候，就会在undo log存储该版本（包括事务id，回滚指针指向上个版本），最新记录的回滚指针指向该版本 版本之间通过回滚指针连接，头部是最新记录，尾部是最旧记录 ④readview(读视图）readview是每个事务独有的，主要内容有两部分：有四个字段、定义了 快照读sql访问版本链的规则 a）字段 注意max_trx_id 并不是目前最大id，而是最大事务id+1（下一个分配的id） b）定义的访问undo log 版本链的规则 trx_id 代表的当前版本链中隐藏字段中的 事务id 注意：不同的隔离级别，会在不同的时机生成readview来进行快照读 读已提交 会在每次select时都生成一个readview来作为此次快照读的依据（读已提交每次select都是一个快照读） 可重复读 会在第一次select时生成一个readview来作为本次快照读的依据（可重复读只有第一次select是快照读，后序select都是复用该次数据） ⑤RC和RR的MVCCa）RC 隔离级别 PC的每次select都是一个快照读，所以事务5的两次select会有两个ReadView ​ MVCC就是在快照读的时候，根据该次select产生的readView，将undo log 的版本链中从头开始 通过每条数据中隐藏字段中的事务id与readView指定的规则做匹配，如果匹配了则返回该条版本记录。 b）RR 隔离级别 ​ 在RR隔离级别下，只有在第一个select快照读的时候会生成ReadView，后序的select都是复用该ReadView，所以可以保证多次select的数据是一致的。 八、数据库1. 基本表","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]}